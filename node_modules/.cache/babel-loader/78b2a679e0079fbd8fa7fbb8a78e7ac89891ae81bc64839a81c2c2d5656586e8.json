{"ast":null,"code":"\"use strict\";\n\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallSettings = exports.RetryOptions = void 0;\nexports.convertRetryOptions = convertRetryOptions;\nexports.createRetryOptions = createRetryOptions;\nexports.createBackoffSettings = createBackoffSettings;\nexports.createDefaultBackoffSettings = createDefaultBackoffSettings;\nexports.createMaxRetriesBackoffSettings = createMaxRetriesBackoffSettings;\nexports.createBundleOptions = createBundleOptions;\nexports.constructSettings = constructSettings;\nexports.createByteLengthFunction = createByteLengthFunction;\nconst warnings_1 = require(\"./warnings\");\nconst util_1 = require(\"./util\");\nconst status_1 = require(\"./status\");\n/**\r\n * Encapsulates the overridable settings for a particular API call.\r\n *\r\n * ``CallOptions`` is an optional arg for all GAX API calls.  It is used to\r\n * configure the settings of a specific API call.\r\n *\r\n * When provided, its values override the GAX service defaults for that\r\n * particular call.\r\n *\r\n * Typically the API clients will accept this as the second to the last\r\n * argument. See the examples below.\r\n * @typedef {Object} CallOptions\r\n * @property {number=} timeout - The client-side timeout for API calls.\r\n * @property {RetryOptions=} retry - determines whether and how to retry\r\n *   on transient errors. When set to null, the call will not retry.\r\n * @property {boolean=} autoPaginate - If set to false and the call is\r\n *   configured for paged iteration, page unrolling is not performed, instead\r\n *   the callback will be called with the response object.\r\n * @property {Object=} pageToken - If set and the call is configured for\r\n *   paged iteration, paged iteration is not performed and requested with this\r\n *   pageToken.\r\n * @property {number} maxResults - If set and the call is configured for\r\n *   paged iteration, the call will stop when the number of response elements\r\n *   reaches to the specified size. By default, it will unroll the page to\r\n *   the end of the list.\r\n * @property {boolean=} isBundling - If set to false and the call is configured\r\n *   for bundling, bundling is not performed.\r\n * @property {BackoffSettings=} longrunning - BackoffSettings used for polling.\r\n * @example\r\n * // suppress bundling for bundled method.\r\n * api.bundlingMethod(\r\n *     param, {optParam: aValue, isBundling: false}, function(err, response) {\r\n *   // handle response.\r\n * });\r\n * @example\r\n * // suppress streaming for page-streaming method.\r\n * api.pageStreamingMethod(\r\n *     param, {optParam: aValue, autoPaginate: false}, function(err, page) {\r\n *   // not returning a stream, but callback is called with the paged response.\r\n * });\r\n */\n/**\r\n * Per-call configurable settings for retrying upon transient failure.\r\n * @implements {RetryOptionsType}\r\n * @typedef {Object} RetryOptions\r\n * @property {number[]} retryCodes\r\n * @property {BackoffSettings} backoffSettings\r\n * @property {(function)} shouldRetryFn\r\n * @property {(function)} getResumptionRequestFn\r\n */\nclass RetryOptions {\n  constructor(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn) {\n    this.retryCodes = retryCodes;\n    this.backoffSettings = backoffSettings;\n    this.shouldRetryFn = shouldRetryFn;\n    this.getResumptionRequestFn = getResumptionRequestFn;\n  }\n}\nexports.RetryOptions = RetryOptions;\nclass CallSettings {\n  /**\r\n   * @param {Object} settings - An object containing parameters of this settings.\r\n   * @param {number} settings.timeout - The client-side timeout for API calls.\r\n   *   This parameter is ignored for retrying calls.\r\n   * @param {RetryOptions} settings.retry - The configuration for retrying upon\r\n   *   transient error. If set to null, this call will not retry.\r\n   * @param {boolean} settings.autoPaginate - If there is no `pageDescriptor`,\r\n   *   this attrbute has no meaning. Otherwise, determines whether a page\r\n   * streamed response should make the page structure transparent to the user by\r\n   *   flattening the repeated field in the returned generator.\r\n   * @param {number} settings.pageToken - If there is no `pageDescriptor`,\r\n   *   this attribute has no meaning. Otherwise, determines the page token used\r\n   * in the page streaming request.\r\n   * @param {Object} settings.otherArgs - Additional arguments to be passed to\r\n   *   the API calls.\r\n   *\r\n   * @constructor\r\n   */\n  constructor(settings) {\n    var _a;\n    settings = settings || {};\n    this.timeout = settings.timeout || 30 * 1000;\n    this.retry = settings.retry;\n    this.autoPaginate = 'autoPaginate' in settings ? settings.autoPaginate : true;\n    this.maxResults = settings.maxResults;\n    this.otherArgs = settings.otherArgs || {};\n    this.bundleOptions = settings.bundleOptions;\n    this.isBundling = 'isBundling' in settings ? settings.isBundling : true;\n    this.longrunning = 'longrunning' in settings ? settings.longrunning : undefined;\n    this.apiName = (_a = settings.apiName) !== null && _a !== void 0 ? _a : undefined;\n    this.retryRequestOptions = settings.retryRequestOptions;\n  }\n  /**\r\n   * Returns a new CallSettings merged from this and a CallOptions object.\r\n   *\r\n   * @param {CallOptions} options - an instance whose values override\r\n   *   those in this object. If null, ``merge`` returns a copy of this\r\n   *   object\r\n   * @return {CallSettings} The merged CallSettings instance.\r\n   */\n  merge(options) {\n    if (!options) {\n      return new CallSettings(this);\n    }\n    let timeout = this.timeout;\n    let retry = this.retry;\n    let autoPaginate = this.autoPaginate;\n    let maxResults = this.maxResults;\n    let otherArgs = this.otherArgs;\n    let isBundling = this.isBundling;\n    let longrunning = this.longrunning;\n    let apiName = this.apiName;\n    let retryRequestOptions = this.retryRequestOptions;\n    // If the user provides a timeout to the method, that timeout value will be used\n    // to override the backoff settings.\n    if ('timeout' in options) {\n      timeout = options.timeout;\n    }\n    // If a method-specific timeout is set in the service config, and the retry codes for that\n    // method are non-null, then that timeout value will be used to\n    // override backoff settings.\n    if (retry === null || retry === void 0 ? void 0 : retry.retryCodes) {\n      retry.backoffSettings.initialRpcTimeoutMillis = timeout;\n      retry.backoffSettings.maxRpcTimeoutMillis = timeout;\n      retry.backoffSettings.totalTimeoutMillis = timeout;\n    }\n    if ('retry' in options) {\n      retry = mergeRetryOptions(retry || {}, options.retry);\n    }\n    if ('autoPaginate' in options && !options.autoPaginate) {\n      autoPaginate = false;\n    }\n    if ('maxResults' in options) {\n      maxResults = options.maxResults;\n    }\n    if ('otherArgs' in options) {\n      otherArgs = {};\n      for (const key in this.otherArgs) {\n        otherArgs[key] = this.otherArgs[key];\n      }\n      for (const optionsKey in options.otherArgs) {\n        otherArgs[optionsKey] = options.otherArgs[optionsKey];\n      }\n    }\n    if ('isBundling' in options) {\n      isBundling = options.isBundling;\n    }\n    if ('maxRetries' in options && options.maxRetries !== undefined) {\n      retry.backoffSettings.maxRetries = options.maxRetries;\n      delete retry.backoffSettings.totalTimeoutMillis;\n    }\n    if ('longrunning' in options) {\n      longrunning = options.longrunning;\n    }\n    if ('apiName' in options) {\n      apiName = options.apiName;\n    }\n    if ('retryRequestOptions' in options) {\n      retryRequestOptions = options.retryRequestOptions;\n    }\n    return new CallSettings({\n      timeout,\n      retry,\n      bundleOptions: this.bundleOptions,\n      longrunning,\n      autoPaginate,\n      maxResults,\n      otherArgs,\n      isBundling,\n      apiName,\n      retryRequestOptions\n    });\n  }\n}\nexports.CallSettings = CallSettings;\n/**\r\n * Validates passed retry options in preparation for eventual parameter deprecation\r\n * converts retryRequestOptions to retryOptions\r\n * then sets retryRequestOptions to null\r\n *\r\n * @param {CallOptions} options - a list of passed retry option\r\n * @return {CallOptions} A new CallOptions object.\r\n *\r\n */\nfunction convertRetryOptions(options, gaxStreamingRetries) {\n  var _a, _b, _c, _d;\n  // options will be undefined if no CallOptions object is passed at call time\n  if (!options) {\n    return options;\n  }\n  // if a user provided retry AND retryRequestOptions at call time, throw an error\n  // otherwise, convert supported parameters\n  if (!gaxStreamingRetries) {\n    return options;\n  }\n  if (options.retry && options.retryRequestOptions) {\n    throw new Error('Only one of retry or retryRequestOptions may be set');\n  } // handles parameter conversion from retryRequestOptions to retryOptions\n  if (options.retryRequestOptions) {\n    if (options.retryRequestOptions.objectMode !== undefined) {\n      (0, warnings_1.warn)('retry_request_options', 'objectMode override is not supported. It is set to true internally by default in gax.', 'UnsupportedParameterWarning');\n    }\n    if (options.retryRequestOptions.noResponseRetries !== undefined) {\n      (0, warnings_1.warn)('retry_request_options', 'noResponseRetries override is not supported. Please specify retry codes or a function to determine retry eligibility.', 'UnsupportedParameterWarning');\n    }\n    if (options.retryRequestOptions.currentRetryAttempt !== undefined) {\n      (0, warnings_1.warn)('retry_request_options', 'currentRetryAttempt override is not supported. Retry attempts are tracked internally.', 'UnsupportedParameterWarning');\n    }\n    let retryCodes = [status_1.Status.UNAVAILABLE];\n    let shouldRetryFn;\n    if (options.retryRequestOptions.shouldRetryFn) {\n      retryCodes = [];\n      shouldRetryFn = options.retryRequestOptions.shouldRetryFn;\n    }\n    //Backoff settings\n    options.maxRetries = (_b = (_a = options === null || options === void 0 ? void 0 : options.retryRequestOptions) === null || _a === void 0 ? void 0 : _a.retries) !== null && _b !== void 0 ? _b : options.maxRetries;\n    // create a default backoff settings object in case the user didn't provide overrides for everything\n    const backoffSettings = createDefaultBackoffSettings();\n    let maxRetryDelayMillis;\n    let totalTimeoutMillis;\n    // maxRetryDelay - this is in seconds, need to convert to milliseconds\n    if (options.retryRequestOptions.maxRetryDelay !== undefined) {\n      maxRetryDelayMillis = options.retryRequestOptions.maxRetryDelay * 1000;\n    }\n    // retryDelayMultiplier - should be a one to one mapping to retryDelayMultiplier\n    const retryDelayMultiplier = (_d = (_c = options === null || options === void 0 ? void 0 : options.retryRequestOptions) === null || _c === void 0 ? void 0 : _c.retryDelayMultiplier) !== null && _d !== void 0 ? _d : backoffSettings.retryDelayMultiplier;\n    // this is in seconds and needs to be converted to milliseconds and the totalTimeoutMillis parameter\n    if (options.retryRequestOptions.totalTimeout !== undefined) {\n      totalTimeoutMillis = options.retryRequestOptions.totalTimeout * 1000;\n    }\n    // for the variables the user wants to override, override in the backoff settings object we made\n    backoffSettings.maxRetryDelayMillis = maxRetryDelayMillis !== null && maxRetryDelayMillis !== void 0 ? maxRetryDelayMillis : backoffSettings.maxRetryDelayMillis;\n    backoffSettings.retryDelayMultiplier = retryDelayMultiplier !== null && retryDelayMultiplier !== void 0 ? retryDelayMultiplier : backoffSettings.retryDelayMultiplier;\n    backoffSettings.totalTimeoutMillis = totalTimeoutMillis !== null && totalTimeoutMillis !== void 0 ? totalTimeoutMillis : backoffSettings.totalTimeoutMillis;\n    const convertedRetryOptions = createRetryOptions(retryCodes, backoffSettings, shouldRetryFn);\n    options.retry = convertedRetryOptions;\n    delete options.retryRequestOptions; // completely remove them to avoid any further confusion\n    (0, warnings_1.warn)('retry_request_options', 'retryRequestOptions will be deprecated in a future release. Please use retryOptions to pass retry options at call time', 'DeprecationWarning');\n  }\n  return options;\n}\n/**\r\n * Per-call configurable settings for retrying upon transient failure.\r\n * @param {number[]} retryCodes - a list of Google API canonical error codes OR a function that returns a boolean to determine retry behavior\r\n *   upon which a retry should be attempted.\r\n * @param {BackoffSettings} backoffSettings - configures the retry\r\n *   exponential backoff algorithm.\r\n * @param {function} shouldRetryFn - a function that determines whether a call should retry. If this is defined retryCodes must be empty\r\n * @param {function} getResumptionRequestFn - a function with a resumption strategy - only used with server streaming retries\r\n * @return {RetryOptions} A new RetryOptions object.\r\n *\r\n */\nfunction createRetryOptions(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn) {\n  return {\n    retryCodes,\n    backoffSettings,\n    shouldRetryFn,\n    getResumptionRequestFn\n  };\n}\n/**\r\n * Parameters to the exponential backoff algorithm for retrying.\r\n *\r\n * @param {number} initialRetryDelayMillis - the initial delay time,\r\n *   in milliseconds, between the completion of the first failed request and the\r\n *   initiation of the first retrying request.\r\n * @param {number} retryDelayMultiplier - the multiplier by which to\r\n *   increase the delay time between the completion of failed requests, and the\r\n *   initiation of the subsequent retrying request.\r\n * @param {number} maxRetryDelayMillis - the maximum delay time, in\r\n *   milliseconds, between requests. When this value is reached,\r\n *   ``retryDelayMultiplier`` will no longer be used to increase delay time.\r\n * @param {number} initialRpcTimeoutMillis - the initial timeout parameter\r\n *   to the request.\r\n * @param {number} rpcTimeoutMultiplier - the multiplier by which to\r\n *   increase the timeout parameter between failed requests.\r\n * @param {number} maxRpcTimeoutMillis - the maximum timeout parameter, in\r\n *   milliseconds, for a request. When this value is reached,\r\n *   ``rpcTimeoutMultiplier`` will no longer be used to increase the timeout.\r\n * @param {number} totalTimeoutMillis - the total time, in milliseconds,\r\n *   starting from when the initial request is sent, after which an error will\r\n *   be returned, regardless of the retrying attempts made meanwhile.\r\n * @return {BackoffSettings} a new settings.\r\n *\r\n */\nfunction createBackoffSettings(initialRetryDelayMillis, retryDelayMultiplier, maxRetryDelayMillis, initialRpcTimeoutMillis, rpcTimeoutMultiplier, maxRpcTimeoutMillis, totalTimeoutMillis) {\n  return {\n    initialRetryDelayMillis,\n    retryDelayMultiplier,\n    maxRetryDelayMillis,\n    initialRpcTimeoutMillis,\n    rpcTimeoutMultiplier,\n    maxRpcTimeoutMillis,\n    totalTimeoutMillis\n  };\n}\nfunction createDefaultBackoffSettings() {\n  return createBackoffSettings(100, 1.3, 60000, null, null, null, null);\n}\n/**\r\n * Parameters to the exponential backoff algorithm for retrying.\r\n * This function is unsupported, and intended for internal use only.\r\n *\r\n * @param {number} initialRetryDelayMillis - the initial delay time,\r\n *   in milliseconds, between the completion of the first failed request and the\r\n *   initiation of the first retrying request.\r\n * @param {number} retryDelayMultiplier - the multiplier by which to\r\n *   increase the delay time between the completion of failed requests, and the\r\n *   initiation of the subsequent retrying request.\r\n * @param {number} maxRetryDelayMillis - the maximum delay time, in\r\n *   milliseconds, between requests. When this value is reached,\r\n *   ``retryDelayMultiplier`` will no longer be used to increase delay time.\r\n * @param {number} initialRpcTimeoutMillis - the initial timeout parameter\r\n *   to the request.\r\n * @param {number} rpcTimeoutMultiplier - the multiplier by which to\r\n *   increase the timeout parameter between failed requests.\r\n * @param {number} maxRpcTimeoutMillis - the maximum timeout parameter, in\r\n *   milliseconds, for a request. When this value is reached,\r\n *   ``rpcTimeoutMultiplier`` will no longer be used to increase the timeout.\r\n * @param {number} maxRetries - the maximum number of retrying attempts that\r\n *   will be made. If reached, an error will be returned.\r\n * @return {BackoffSettings} a new settings.\r\n *\r\n */\nfunction createMaxRetriesBackoffSettings(initialRetryDelayMillis, retryDelayMultiplier, maxRetryDelayMillis, initialRpcTimeoutMillis, rpcTimeoutMultiplier, maxRpcTimeoutMillis, maxRetries) {\n  return {\n    initialRetryDelayMillis,\n    retryDelayMultiplier,\n    maxRetryDelayMillis,\n    initialRpcTimeoutMillis,\n    rpcTimeoutMultiplier,\n    maxRpcTimeoutMillis,\n    maxRetries\n  };\n}\n/**\r\n * Creates a new {@link BundleOptions}.\r\n *\r\n * @private\r\n * @param {Object} options - An object to hold optional parameters. See\r\n *   properties for the content of options.\r\n * @return {BundleOptions} - A new options.\r\n */\nfunction createBundleOptions(options) {\n  const params = ['element_count_threshold', 'element_count_limit', 'request_byte_threshold', 'request_byte_limit', 'delay_threshold_millis'];\n  params.forEach(param => {\n    if (param in options && typeof options[param] !== 'number') {\n      throw new Error(`${param} should be a number`);\n    }\n  });\n  const elementCountThreshold = options.element_count_threshold || 0;\n  const elementCountLimit = options.element_count_limit || 0;\n  const requestByteThreshold = options.request_byte_threshold || 0;\n  const requestByteLimit = options.request_byte_limit || 0;\n  const delayThreshold = options.delay_threshold_millis || 0;\n  if (elementCountThreshold === 0 && requestByteThreshold === 0 && delayThreshold === 0) {\n    throw new Error('one threshold should be > 0');\n  }\n  return {\n    elementCountThreshold,\n    elementCountLimit,\n    requestByteThreshold,\n    requestByteLimit,\n    delayThreshold\n  };\n}\n/**\r\n * Helper for {@link constructSettings}\r\n *\r\n * @private\r\n *\r\n * @param {Object} methodConfig - A dictionary representing a single\r\n *   `methods` entry of the standard API client config file. (See\r\n *   {@link constructSettings} for information on this yaml.)\r\n * @param {?Object} retryCodes - A dictionary parsed from the\r\n *   `retry_codes_def` entry of the standard API client config\r\n *   file. (See {@link constructSettings} for information on this yaml.)\r\n * @param {Object} retryParams - A dictionary parsed from the\r\n *   `retry_params` entry of the standard API client config\r\n *   file. (See {@link constructSettings} for information on this yaml.)\r\n * @param {Object} retryNames - A dictionary mapping the string names\r\n *   used in the standard API client config file to API response\r\n *   status codes.\r\n * @return {?RetryOptions} The new retry options.\r\n */\nfunction constructRetry(methodConfig, retryCodes, retryParams, retryNames) {\n  if (!methodConfig) {\n    return null;\n  }\n  let codes = null; // this is one instance where it will NOT be an array OR a function because we do not allow shouldRetryFn in the client\n  if (retryCodes && 'retry_codes_name' in methodConfig) {\n    const retryCodesName = methodConfig['retry_codes_name'];\n    codes = (retryCodes[retryCodesName] || []).map(name => {\n      return Number(retryNames[name]);\n    });\n  }\n  let backoffSettings = null;\n  if (retryParams && 'retry_params_name' in methodConfig) {\n    const params = retryParams[methodConfig.retry_params_name];\n    backoffSettings = createBackoffSettings(params.initial_retry_delay_millis, params.retry_delay_multiplier, params.max_retry_delay_millis, params.initial_rpc_timeout_millis, params.rpc_timeout_multiplier, params.max_rpc_timeout_millis, params.total_timeout_millis);\n  }\n  return createRetryOptions(codes, backoffSettings);\n}\n/**\r\n * Helper for {@link constructSettings}\r\n *\r\n * Takes two retry options, and merges them into a single RetryOption instance.\r\n *\r\n * @private\r\n *\r\n * @param {RetryOptions} retry - The base RetryOptions.\r\n * @param {RetryOptions} overrides - The RetryOptions used for overriding\r\n *   `retry`. Use the values if it is not null. If entire `overrides` is null,\r\n *   ignore the base retry and return null.\r\n * @return {?RetryOptions} The merged RetryOptions.\r\n */\nfunction mergeRetryOptions(retry, overrides) {\n  if (!overrides) {\n    return null;\n  }\n  if (!overrides.retryCodes && !overrides.backoffSettings && !overrides.shouldRetryFn && !overrides.getResumptionRequestFn) {\n    return retry;\n  }\n  const retryCodes = overrides.retryCodes ? overrides.retryCodes : retry.retryCodes;\n  const backoffSettings = overrides.backoffSettings ? overrides.backoffSettings : retry.backoffSettings;\n  const shouldRetryFn = overrides.shouldRetryFn ? overrides.shouldRetryFn : retry.shouldRetryFn;\n  const getResumptionRequestFn = overrides.getResumptionRequestFn ? overrides.getResumptionRequestFn : retry.getResumptionRequestFn;\n  return createRetryOptions(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn);\n}\n/**\r\n * Constructs a dictionary mapping method names to {@link CallSettings}.\r\n *\r\n * The `clientConfig` parameter is parsed from a client configuration JSON\r\n * file of the form:\r\n *\r\n *     {\r\n *       \"interfaces\": {\r\n *         \"google.fake.v1.ServiceName\": {\r\n *           \"retry_codes\": {\r\n *             \"idempotent\": [\"UNAVAILABLE\", \"DEADLINE_EXCEEDED\"],\r\n *             \"non_idempotent\": []\r\n *           },\r\n *           \"retry_params\": {\r\n *             \"default\": {\r\n *               \"initial_retry_delay_millis\": 100,\r\n *               \"retry_delay_multiplier\": 1.2,\r\n *               \"max_retry_delay_millis\": 1000,\r\n *               \"initial_rpc_timeout_millis\": 2000,\r\n *               \"rpc_timeout_multiplier\": 1.5,\r\n *               \"max_rpc_timeout_millis\": 30000,\r\n *               \"total_timeout_millis\": 45000\r\n *             }\r\n *           },\r\n *           \"methods\": {\r\n *             \"CreateFoo\": {\r\n *               \"retry_codes_name\": \"idempotent\",\r\n *               \"retry_params_name\": \"default\"\r\n *             },\r\n *             \"Publish\": {\r\n *               \"retry_codes_name\": \"non_idempotent\",\r\n *               \"retry_params_name\": \"default\",\r\n *               \"bundling\": {\r\n *                 \"element_count_threshold\": 40,\r\n *                 \"element_count_limit\": 200,\r\n *                 \"request_byte_threshold\": 90000,\r\n *                 \"request_byte_limit\": 100000,\r\n *                 \"delay_threshold_millis\": 100\r\n *               }\r\n *             }\r\n *           }\r\n *         }\r\n *       }\r\n *     }\r\n *\r\n * @param {String} serviceName - The fully-qualified name of this\r\n *   service, used as a key into the client config file (in the\r\n *   example above, this value should be 'google.fake.v1.ServiceName').\r\n * @param {Object} clientConfig - A dictionary parsed from the\r\n *   standard API client config file.\r\n * @param {Object} configOverrides - A dictionary in the same structure of\r\n *   client_config to override the settings.\r\n * @param {Object.<string, string[]>} retryNames - A dictionary mapping the strings\r\n *   referring to response status codes to objects representing\r\n *   those codes.\r\n * @param {Object} otherArgs - the non-request arguments to be passed to the API\r\n *   calls.\r\n * @return {Object} A mapping from method name to CallSettings, or null if the\r\n *   service is not found in the config.\r\n */\nfunction constructSettings(serviceName, clientConfig, configOverrides, retryNames, otherArgs) {\n  otherArgs = otherArgs || {};\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const defaults = {};\n  const serviceConfig = (clientConfig.interfaces || {})[serviceName];\n  if (!serviceConfig) {\n    return null;\n  }\n  // users can override the config from client side, like bundling options.\n  // The detailed structure of the clientConfig can be found here: https://github.com/googleapis/gax-nodejs/blob/main/src/gax.ts#L546\n  // The way to override bundling options:\n  //\n  // const customConfig = {\"interfaces\": {\"service\": {\"methods\": {\"methodName\": {\"bundling\": {..}}}}}}\n  // const client = new Client({ projectId, customConfig });\n  const overrides = (configOverrides.interfaces || {})[serviceName] || {};\n  const methods = serviceConfig.methods;\n  const overridingMethods = overrides.methods || {};\n  for (const methodName in methods) {\n    const methodConfig = methods[methodName];\n    const jsName = (0, util_1.toLowerCamelCase)(methodName);\n    let retry = constructRetry(methodConfig, serviceConfig.retry_codes, serviceConfig.retry_params, retryNames);\n    let bundlingConfig = methodConfig.bundling;\n    let timeout = methodConfig.timeout_millis;\n    if (methodName in overridingMethods) {\n      const overridingMethod = overridingMethods[methodName];\n      if (overridingMethod) {\n        if ('bundling' in overridingMethod) {\n          bundlingConfig = overridingMethod.bundling;\n        }\n        if ('timeout_millis' in overridingMethod) {\n          timeout = overridingMethod.timeout_millis;\n        }\n      }\n      retry = mergeRetryOptions(retry, constructRetry(overridingMethod, overrides.retry_codes, overrides.retry_params, retryNames));\n    }\n    const apiName = serviceName;\n    defaults[jsName] = new CallSettings({\n      timeout,\n      retry,\n      bundleOptions: bundlingConfig ? createBundleOptions(bundlingConfig) : null,\n      otherArgs,\n      apiName\n    });\n  }\n  return defaults;\n}\nfunction createByteLengthFunction(message) {\n  return function getByteLength(obj) {\n    try {\n      return message.encode(obj).finish().length;\n    } catch (err) {\n      const stringified = JSON.stringify(obj);\n      (0, warnings_1.warn)('error_encoding_protobufjs_object', `Cannot encode protobuf.js object: ${stringified}: ${err}`);\n      // We failed to encode the object properly, let's just return an upper boundary of its length.\n      // It's only needed for calculating the size of the batch, so it's safe if it's bigger than needed.\n      return stringified.length;\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","CallSettings","RetryOptions","convertRetryOptions","createRetryOptions","createBackoffSettings","createDefaultBackoffSettings","createMaxRetriesBackoffSettings","createBundleOptions","constructSettings","createByteLengthFunction","warnings_1","require","util_1","status_1","constructor","retryCodes","backoffSettings","shouldRetryFn","getResumptionRequestFn","settings","_a","timeout","retry","autoPaginate","maxResults","otherArgs","bundleOptions","isBundling","longrunning","undefined","apiName","retryRequestOptions","merge","options","initialRpcTimeoutMillis","maxRpcTimeoutMillis","totalTimeoutMillis","mergeRetryOptions","key","optionsKey","maxRetries","gaxStreamingRetries","_b","_c","_d","Error","objectMode","warn","noResponseRetries","currentRetryAttempt","Status","UNAVAILABLE","retries","maxRetryDelayMillis","maxRetryDelay","retryDelayMultiplier","totalTimeout","convertedRetryOptions","initialRetryDelayMillis","rpcTimeoutMultiplier","params","forEach","param","elementCountThreshold","element_count_threshold","elementCountLimit","element_count_limit","requestByteThreshold","request_byte_threshold","requestByteLimit","request_byte_limit","delayThreshold","delay_threshold_millis","constructRetry","methodConfig","retryParams","retryNames","codes","retryCodesName","map","name","Number","retry_params_name","initial_retry_delay_millis","retry_delay_multiplier","max_retry_delay_millis","initial_rpc_timeout_millis","rpc_timeout_multiplier","max_rpc_timeout_millis","total_timeout_millis","overrides","serviceName","clientConfig","configOverrides","defaults","serviceConfig","interfaces","methods","overridingMethods","methodName","jsName","toLowerCamelCase","retry_codes","retry_params","bundlingConfig","bundling","timeout_millis","overridingMethod","message","getByteLength","obj","encode","finish","length","err","stringified","JSON","stringify"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/google-gax/build/src/gax.js"],"sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CallSettings = exports.RetryOptions = void 0;\r\nexports.convertRetryOptions = convertRetryOptions;\r\nexports.createRetryOptions = createRetryOptions;\r\nexports.createBackoffSettings = createBackoffSettings;\r\nexports.createDefaultBackoffSettings = createDefaultBackoffSettings;\r\nexports.createMaxRetriesBackoffSettings = createMaxRetriesBackoffSettings;\r\nexports.createBundleOptions = createBundleOptions;\r\nexports.constructSettings = constructSettings;\r\nexports.createByteLengthFunction = createByteLengthFunction;\r\nconst warnings_1 = require(\"./warnings\");\r\nconst util_1 = require(\"./util\");\r\nconst status_1 = require(\"./status\");\r\n/**\r\n * Encapsulates the overridable settings for a particular API call.\r\n *\r\n * ``CallOptions`` is an optional arg for all GAX API calls.  It is used to\r\n * configure the settings of a specific API call.\r\n *\r\n * When provided, its values override the GAX service defaults for that\r\n * particular call.\r\n *\r\n * Typically the API clients will accept this as the second to the last\r\n * argument. See the examples below.\r\n * @typedef {Object} CallOptions\r\n * @property {number=} timeout - The client-side timeout for API calls.\r\n * @property {RetryOptions=} retry - determines whether and how to retry\r\n *   on transient errors. When set to null, the call will not retry.\r\n * @property {boolean=} autoPaginate - If set to false and the call is\r\n *   configured for paged iteration, page unrolling is not performed, instead\r\n *   the callback will be called with the response object.\r\n * @property {Object=} pageToken - If set and the call is configured for\r\n *   paged iteration, paged iteration is not performed and requested with this\r\n *   pageToken.\r\n * @property {number} maxResults - If set and the call is configured for\r\n *   paged iteration, the call will stop when the number of response elements\r\n *   reaches to the specified size. By default, it will unroll the page to\r\n *   the end of the list.\r\n * @property {boolean=} isBundling - If set to false and the call is configured\r\n *   for bundling, bundling is not performed.\r\n * @property {BackoffSettings=} longrunning - BackoffSettings used for polling.\r\n * @example\r\n * // suppress bundling for bundled method.\r\n * api.bundlingMethod(\r\n *     param, {optParam: aValue, isBundling: false}, function(err, response) {\r\n *   // handle response.\r\n * });\r\n * @example\r\n * // suppress streaming for page-streaming method.\r\n * api.pageStreamingMethod(\r\n *     param, {optParam: aValue, autoPaginate: false}, function(err, page) {\r\n *   // not returning a stream, but callback is called with the paged response.\r\n * });\r\n */\r\n/**\r\n * Per-call configurable settings for retrying upon transient failure.\r\n * @implements {RetryOptionsType}\r\n * @typedef {Object} RetryOptions\r\n * @property {number[]} retryCodes\r\n * @property {BackoffSettings} backoffSettings\r\n * @property {(function)} shouldRetryFn\r\n * @property {(function)} getResumptionRequestFn\r\n */\r\nclass RetryOptions {\r\n    constructor(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn) {\r\n        this.retryCodes = retryCodes;\r\n        this.backoffSettings = backoffSettings;\r\n        this.shouldRetryFn = shouldRetryFn;\r\n        this.getResumptionRequestFn = getResumptionRequestFn;\r\n    }\r\n}\r\nexports.RetryOptions = RetryOptions;\r\nclass CallSettings {\r\n    /**\r\n     * @param {Object} settings - An object containing parameters of this settings.\r\n     * @param {number} settings.timeout - The client-side timeout for API calls.\r\n     *   This parameter is ignored for retrying calls.\r\n     * @param {RetryOptions} settings.retry - The configuration for retrying upon\r\n     *   transient error. If set to null, this call will not retry.\r\n     * @param {boolean} settings.autoPaginate - If there is no `pageDescriptor`,\r\n     *   this attrbute has no meaning. Otherwise, determines whether a page\r\n     * streamed response should make the page structure transparent to the user by\r\n     *   flattening the repeated field in the returned generator.\r\n     * @param {number} settings.pageToken - If there is no `pageDescriptor`,\r\n     *   this attribute has no meaning. Otherwise, determines the page token used\r\n     * in the page streaming request.\r\n     * @param {Object} settings.otherArgs - Additional arguments to be passed to\r\n     *   the API calls.\r\n     *\r\n     * @constructor\r\n     */\r\n    constructor(settings) {\r\n        var _a;\r\n        settings = settings || {};\r\n        this.timeout = settings.timeout || 30 * 1000;\r\n        this.retry = settings.retry;\r\n        this.autoPaginate =\r\n            'autoPaginate' in settings ? settings.autoPaginate : true;\r\n        this.maxResults = settings.maxResults;\r\n        this.otherArgs = settings.otherArgs || {};\r\n        this.bundleOptions = settings.bundleOptions;\r\n        this.isBundling = 'isBundling' in settings ? settings.isBundling : true;\r\n        this.longrunning =\r\n            'longrunning' in settings ? settings.longrunning : undefined;\r\n        this.apiName = (_a = settings.apiName) !== null && _a !== void 0 ? _a : undefined;\r\n        this.retryRequestOptions = settings.retryRequestOptions;\r\n    }\r\n    /**\r\n     * Returns a new CallSettings merged from this and a CallOptions object.\r\n     *\r\n     * @param {CallOptions} options - an instance whose values override\r\n     *   those in this object. If null, ``merge`` returns a copy of this\r\n     *   object\r\n     * @return {CallSettings} The merged CallSettings instance.\r\n     */\r\n    merge(options) {\r\n        if (!options) {\r\n            return new CallSettings(this);\r\n        }\r\n        let timeout = this.timeout;\r\n        let retry = this.retry;\r\n        let autoPaginate = this.autoPaginate;\r\n        let maxResults = this.maxResults;\r\n        let otherArgs = this.otherArgs;\r\n        let isBundling = this.isBundling;\r\n        let longrunning = this.longrunning;\r\n        let apiName = this.apiName;\r\n        let retryRequestOptions = this.retryRequestOptions;\r\n        // If the user provides a timeout to the method, that timeout value will be used\r\n        // to override the backoff settings.\r\n        if ('timeout' in options) {\r\n            timeout = options.timeout;\r\n        }\r\n        // If a method-specific timeout is set in the service config, and the retry codes for that\r\n        // method are non-null, then that timeout value will be used to\r\n        // override backoff settings.\r\n        if (retry === null || retry === void 0 ? void 0 : retry.retryCodes) {\r\n            retry.backoffSettings.initialRpcTimeoutMillis = timeout;\r\n            retry.backoffSettings.maxRpcTimeoutMillis = timeout;\r\n            retry.backoffSettings.totalTimeoutMillis = timeout;\r\n        }\r\n        if ('retry' in options) {\r\n            retry = mergeRetryOptions(retry || {}, options.retry);\r\n        }\r\n        if ('autoPaginate' in options && !options.autoPaginate) {\r\n            autoPaginate = false;\r\n        }\r\n        if ('maxResults' in options) {\r\n            maxResults = options.maxResults;\r\n        }\r\n        if ('otherArgs' in options) {\r\n            otherArgs = {};\r\n            for (const key in this.otherArgs) {\r\n                otherArgs[key] = this.otherArgs[key];\r\n            }\r\n            for (const optionsKey in options.otherArgs) {\r\n                otherArgs[optionsKey] = options.otherArgs[optionsKey];\r\n            }\r\n        }\r\n        if ('isBundling' in options) {\r\n            isBundling = options.isBundling;\r\n        }\r\n        if ('maxRetries' in options && options.maxRetries !== undefined) {\r\n            retry.backoffSettings.maxRetries = options.maxRetries;\r\n            delete retry.backoffSettings.totalTimeoutMillis;\r\n        }\r\n        if ('longrunning' in options) {\r\n            longrunning = options.longrunning;\r\n        }\r\n        if ('apiName' in options) {\r\n            apiName = options.apiName;\r\n        }\r\n        if ('retryRequestOptions' in options) {\r\n            retryRequestOptions = options.retryRequestOptions;\r\n        }\r\n        return new CallSettings({\r\n            timeout,\r\n            retry,\r\n            bundleOptions: this.bundleOptions,\r\n            longrunning,\r\n            autoPaginate,\r\n            maxResults,\r\n            otherArgs,\r\n            isBundling,\r\n            apiName,\r\n            retryRequestOptions,\r\n        });\r\n    }\r\n}\r\nexports.CallSettings = CallSettings;\r\n/**\r\n * Validates passed retry options in preparation for eventual parameter deprecation\r\n * converts retryRequestOptions to retryOptions\r\n * then sets retryRequestOptions to null\r\n *\r\n * @param {CallOptions} options - a list of passed retry option\r\n * @return {CallOptions} A new CallOptions object.\r\n *\r\n */\r\nfunction convertRetryOptions(options, gaxStreamingRetries) {\r\n    var _a, _b, _c, _d;\r\n    // options will be undefined if no CallOptions object is passed at call time\r\n    if (!options) {\r\n        return options;\r\n    }\r\n    // if a user provided retry AND retryRequestOptions at call time, throw an error\r\n    // otherwise, convert supported parameters\r\n    if (!gaxStreamingRetries) {\r\n        return options;\r\n    }\r\n    if (options.retry && options.retryRequestOptions) {\r\n        throw new Error('Only one of retry or retryRequestOptions may be set');\r\n    } // handles parameter conversion from retryRequestOptions to retryOptions\r\n    if (options.retryRequestOptions) {\r\n        if (options.retryRequestOptions.objectMode !== undefined) {\r\n            (0, warnings_1.warn)('retry_request_options', 'objectMode override is not supported. It is set to true internally by default in gax.', 'UnsupportedParameterWarning');\r\n        }\r\n        if (options.retryRequestOptions.noResponseRetries !== undefined) {\r\n            (0, warnings_1.warn)('retry_request_options', 'noResponseRetries override is not supported. Please specify retry codes or a function to determine retry eligibility.', 'UnsupportedParameterWarning');\r\n        }\r\n        if (options.retryRequestOptions.currentRetryAttempt !== undefined) {\r\n            (0, warnings_1.warn)('retry_request_options', 'currentRetryAttempt override is not supported. Retry attempts are tracked internally.', 'UnsupportedParameterWarning');\r\n        }\r\n        let retryCodes = [status_1.Status.UNAVAILABLE];\r\n        let shouldRetryFn;\r\n        if (options.retryRequestOptions.shouldRetryFn) {\r\n            retryCodes = [];\r\n            shouldRetryFn = options.retryRequestOptions.shouldRetryFn;\r\n        }\r\n        //Backoff settings\r\n        options.maxRetries =\r\n            (_b = (_a = options === null || options === void 0 ? void 0 : options.retryRequestOptions) === null || _a === void 0 ? void 0 : _a.retries) !== null && _b !== void 0 ? _b : options.maxRetries;\r\n        // create a default backoff settings object in case the user didn't provide overrides for everything\r\n        const backoffSettings = createDefaultBackoffSettings();\r\n        let maxRetryDelayMillis;\r\n        let totalTimeoutMillis;\r\n        // maxRetryDelay - this is in seconds, need to convert to milliseconds\r\n        if (options.retryRequestOptions.maxRetryDelay !== undefined) {\r\n            maxRetryDelayMillis = options.retryRequestOptions.maxRetryDelay * 1000;\r\n        }\r\n        // retryDelayMultiplier - should be a one to one mapping to retryDelayMultiplier\r\n        const retryDelayMultiplier = (_d = (_c = options === null || options === void 0 ? void 0 : options.retryRequestOptions) === null || _c === void 0 ? void 0 : _c.retryDelayMultiplier) !== null && _d !== void 0 ? _d : backoffSettings.retryDelayMultiplier;\r\n        // this is in seconds and needs to be converted to milliseconds and the totalTimeoutMillis parameter\r\n        if (options.retryRequestOptions.totalTimeout !== undefined) {\r\n            totalTimeoutMillis = options.retryRequestOptions.totalTimeout * 1000;\r\n        }\r\n        // for the variables the user wants to override, override in the backoff settings object we made\r\n        backoffSettings.maxRetryDelayMillis =\r\n            maxRetryDelayMillis !== null && maxRetryDelayMillis !== void 0 ? maxRetryDelayMillis : backoffSettings.maxRetryDelayMillis;\r\n        backoffSettings.retryDelayMultiplier =\r\n            retryDelayMultiplier !== null && retryDelayMultiplier !== void 0 ? retryDelayMultiplier : backoffSettings.retryDelayMultiplier;\r\n        backoffSettings.totalTimeoutMillis =\r\n            totalTimeoutMillis !== null && totalTimeoutMillis !== void 0 ? totalTimeoutMillis : backoffSettings.totalTimeoutMillis;\r\n        const convertedRetryOptions = createRetryOptions(retryCodes, backoffSettings, shouldRetryFn);\r\n        options.retry = convertedRetryOptions;\r\n        delete options.retryRequestOptions; // completely remove them to avoid any further confusion\r\n        (0, warnings_1.warn)('retry_request_options', 'retryRequestOptions will be deprecated in a future release. Please use retryOptions to pass retry options at call time', 'DeprecationWarning');\r\n    }\r\n    return options;\r\n}\r\n/**\r\n * Per-call configurable settings for retrying upon transient failure.\r\n * @param {number[]} retryCodes - a list of Google API canonical error codes OR a function that returns a boolean to determine retry behavior\r\n *   upon which a retry should be attempted.\r\n * @param {BackoffSettings} backoffSettings - configures the retry\r\n *   exponential backoff algorithm.\r\n * @param {function} shouldRetryFn - a function that determines whether a call should retry. If this is defined retryCodes must be empty\r\n * @param {function} getResumptionRequestFn - a function with a resumption strategy - only used with server streaming retries\r\n * @return {RetryOptions} A new RetryOptions object.\r\n *\r\n */\r\nfunction createRetryOptions(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn) {\r\n    return {\r\n        retryCodes,\r\n        backoffSettings,\r\n        shouldRetryFn,\r\n        getResumptionRequestFn,\r\n    };\r\n}\r\n/**\r\n * Parameters to the exponential backoff algorithm for retrying.\r\n *\r\n * @param {number} initialRetryDelayMillis - the initial delay time,\r\n *   in milliseconds, between the completion of the first failed request and the\r\n *   initiation of the first retrying request.\r\n * @param {number} retryDelayMultiplier - the multiplier by which to\r\n *   increase the delay time between the completion of failed requests, and the\r\n *   initiation of the subsequent retrying request.\r\n * @param {number} maxRetryDelayMillis - the maximum delay time, in\r\n *   milliseconds, between requests. When this value is reached,\r\n *   ``retryDelayMultiplier`` will no longer be used to increase delay time.\r\n * @param {number} initialRpcTimeoutMillis - the initial timeout parameter\r\n *   to the request.\r\n * @param {number} rpcTimeoutMultiplier - the multiplier by which to\r\n *   increase the timeout parameter between failed requests.\r\n * @param {number} maxRpcTimeoutMillis - the maximum timeout parameter, in\r\n *   milliseconds, for a request. When this value is reached,\r\n *   ``rpcTimeoutMultiplier`` will no longer be used to increase the timeout.\r\n * @param {number} totalTimeoutMillis - the total time, in milliseconds,\r\n *   starting from when the initial request is sent, after which an error will\r\n *   be returned, regardless of the retrying attempts made meanwhile.\r\n * @return {BackoffSettings} a new settings.\r\n *\r\n */\r\nfunction createBackoffSettings(initialRetryDelayMillis, retryDelayMultiplier, maxRetryDelayMillis, initialRpcTimeoutMillis, rpcTimeoutMultiplier, maxRpcTimeoutMillis, totalTimeoutMillis) {\r\n    return {\r\n        initialRetryDelayMillis,\r\n        retryDelayMultiplier,\r\n        maxRetryDelayMillis,\r\n        initialRpcTimeoutMillis,\r\n        rpcTimeoutMultiplier,\r\n        maxRpcTimeoutMillis,\r\n        totalTimeoutMillis,\r\n    };\r\n}\r\nfunction createDefaultBackoffSettings() {\r\n    return createBackoffSettings(100, 1.3, 60000, null, null, null, null);\r\n}\r\n/**\r\n * Parameters to the exponential backoff algorithm for retrying.\r\n * This function is unsupported, and intended for internal use only.\r\n *\r\n * @param {number} initialRetryDelayMillis - the initial delay time,\r\n *   in milliseconds, between the completion of the first failed request and the\r\n *   initiation of the first retrying request.\r\n * @param {number} retryDelayMultiplier - the multiplier by which to\r\n *   increase the delay time between the completion of failed requests, and the\r\n *   initiation of the subsequent retrying request.\r\n * @param {number} maxRetryDelayMillis - the maximum delay time, in\r\n *   milliseconds, between requests. When this value is reached,\r\n *   ``retryDelayMultiplier`` will no longer be used to increase delay time.\r\n * @param {number} initialRpcTimeoutMillis - the initial timeout parameter\r\n *   to the request.\r\n * @param {number} rpcTimeoutMultiplier - the multiplier by which to\r\n *   increase the timeout parameter between failed requests.\r\n * @param {number} maxRpcTimeoutMillis - the maximum timeout parameter, in\r\n *   milliseconds, for a request. When this value is reached,\r\n *   ``rpcTimeoutMultiplier`` will no longer be used to increase the timeout.\r\n * @param {number} maxRetries - the maximum number of retrying attempts that\r\n *   will be made. If reached, an error will be returned.\r\n * @return {BackoffSettings} a new settings.\r\n *\r\n */\r\nfunction createMaxRetriesBackoffSettings(initialRetryDelayMillis, retryDelayMultiplier, maxRetryDelayMillis, initialRpcTimeoutMillis, rpcTimeoutMultiplier, maxRpcTimeoutMillis, maxRetries) {\r\n    return {\r\n        initialRetryDelayMillis,\r\n        retryDelayMultiplier,\r\n        maxRetryDelayMillis,\r\n        initialRpcTimeoutMillis,\r\n        rpcTimeoutMultiplier,\r\n        maxRpcTimeoutMillis,\r\n        maxRetries,\r\n    };\r\n}\r\n/**\r\n * Creates a new {@link BundleOptions}.\r\n *\r\n * @private\r\n * @param {Object} options - An object to hold optional parameters. See\r\n *   properties for the content of options.\r\n * @return {BundleOptions} - A new options.\r\n */\r\nfunction createBundleOptions(options) {\r\n    const params = [\r\n        'element_count_threshold',\r\n        'element_count_limit',\r\n        'request_byte_threshold',\r\n        'request_byte_limit',\r\n        'delay_threshold_millis',\r\n    ];\r\n    params.forEach(param => {\r\n        if (param in options && typeof options[param] !== 'number') {\r\n            throw new Error(`${param} should be a number`);\r\n        }\r\n    });\r\n    const elementCountThreshold = options.element_count_threshold || 0;\r\n    const elementCountLimit = options.element_count_limit || 0;\r\n    const requestByteThreshold = options.request_byte_threshold || 0;\r\n    const requestByteLimit = options.request_byte_limit || 0;\r\n    const delayThreshold = options.delay_threshold_millis || 0;\r\n    if (elementCountThreshold === 0 &&\r\n        requestByteThreshold === 0 &&\r\n        delayThreshold === 0) {\r\n        throw new Error('one threshold should be > 0');\r\n    }\r\n    return {\r\n        elementCountThreshold,\r\n        elementCountLimit,\r\n        requestByteThreshold,\r\n        requestByteLimit,\r\n        delayThreshold,\r\n    };\r\n}\r\n/**\r\n * Helper for {@link constructSettings}\r\n *\r\n * @private\r\n *\r\n * @param {Object} methodConfig - A dictionary representing a single\r\n *   `methods` entry of the standard API client config file. (See\r\n *   {@link constructSettings} for information on this yaml.)\r\n * @param {?Object} retryCodes - A dictionary parsed from the\r\n *   `retry_codes_def` entry of the standard API client config\r\n *   file. (See {@link constructSettings} for information on this yaml.)\r\n * @param {Object} retryParams - A dictionary parsed from the\r\n *   `retry_params` entry of the standard API client config\r\n *   file. (See {@link constructSettings} for information on this yaml.)\r\n * @param {Object} retryNames - A dictionary mapping the string names\r\n *   used in the standard API client config file to API response\r\n *   status codes.\r\n * @return {?RetryOptions} The new retry options.\r\n */\r\nfunction constructRetry(methodConfig, retryCodes, retryParams, retryNames) {\r\n    if (!methodConfig) {\r\n        return null;\r\n    }\r\n    let codes = null; // this is one instance where it will NOT be an array OR a function because we do not allow shouldRetryFn in the client\r\n    if (retryCodes && 'retry_codes_name' in methodConfig) {\r\n        const retryCodesName = methodConfig['retry_codes_name'];\r\n        codes = (retryCodes[retryCodesName] || []).map(name => {\r\n            return Number(retryNames[name]);\r\n        });\r\n    }\r\n    let backoffSettings = null;\r\n    if (retryParams && 'retry_params_name' in methodConfig) {\r\n        const params = retryParams[methodConfig.retry_params_name];\r\n        backoffSettings = createBackoffSettings(params.initial_retry_delay_millis, params.retry_delay_multiplier, params.max_retry_delay_millis, params.initial_rpc_timeout_millis, params.rpc_timeout_multiplier, params.max_rpc_timeout_millis, params.total_timeout_millis);\r\n    }\r\n    return createRetryOptions(codes, backoffSettings);\r\n}\r\n/**\r\n * Helper for {@link constructSettings}\r\n *\r\n * Takes two retry options, and merges them into a single RetryOption instance.\r\n *\r\n * @private\r\n *\r\n * @param {RetryOptions} retry - The base RetryOptions.\r\n * @param {RetryOptions} overrides - The RetryOptions used for overriding\r\n *   `retry`. Use the values if it is not null. If entire `overrides` is null,\r\n *   ignore the base retry and return null.\r\n * @return {?RetryOptions} The merged RetryOptions.\r\n */\r\nfunction mergeRetryOptions(retry, overrides) {\r\n    if (!overrides) {\r\n        return null;\r\n    }\r\n    if (!overrides.retryCodes &&\r\n        !overrides.backoffSettings &&\r\n        !overrides.shouldRetryFn &&\r\n        !overrides.getResumptionRequestFn) {\r\n        return retry;\r\n    }\r\n    const retryCodes = overrides.retryCodes\r\n        ? overrides.retryCodes\r\n        : retry.retryCodes;\r\n    const backoffSettings = overrides.backoffSettings\r\n        ? overrides.backoffSettings\r\n        : retry.backoffSettings;\r\n    const shouldRetryFn = overrides.shouldRetryFn\r\n        ? overrides.shouldRetryFn\r\n        : retry.shouldRetryFn;\r\n    const getResumptionRequestFn = overrides.getResumptionRequestFn\r\n        ? overrides.getResumptionRequestFn\r\n        : retry.getResumptionRequestFn;\r\n    return createRetryOptions(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn);\r\n}\r\n/**\r\n * Constructs a dictionary mapping method names to {@link CallSettings}.\r\n *\r\n * The `clientConfig` parameter is parsed from a client configuration JSON\r\n * file of the form:\r\n *\r\n *     {\r\n *       \"interfaces\": {\r\n *         \"google.fake.v1.ServiceName\": {\r\n *           \"retry_codes\": {\r\n *             \"idempotent\": [\"UNAVAILABLE\", \"DEADLINE_EXCEEDED\"],\r\n *             \"non_idempotent\": []\r\n *           },\r\n *           \"retry_params\": {\r\n *             \"default\": {\r\n *               \"initial_retry_delay_millis\": 100,\r\n *               \"retry_delay_multiplier\": 1.2,\r\n *               \"max_retry_delay_millis\": 1000,\r\n *               \"initial_rpc_timeout_millis\": 2000,\r\n *               \"rpc_timeout_multiplier\": 1.5,\r\n *               \"max_rpc_timeout_millis\": 30000,\r\n *               \"total_timeout_millis\": 45000\r\n *             }\r\n *           },\r\n *           \"methods\": {\r\n *             \"CreateFoo\": {\r\n *               \"retry_codes_name\": \"idempotent\",\r\n *               \"retry_params_name\": \"default\"\r\n *             },\r\n *             \"Publish\": {\r\n *               \"retry_codes_name\": \"non_idempotent\",\r\n *               \"retry_params_name\": \"default\",\r\n *               \"bundling\": {\r\n *                 \"element_count_threshold\": 40,\r\n *                 \"element_count_limit\": 200,\r\n *                 \"request_byte_threshold\": 90000,\r\n *                 \"request_byte_limit\": 100000,\r\n *                 \"delay_threshold_millis\": 100\r\n *               }\r\n *             }\r\n *           }\r\n *         }\r\n *       }\r\n *     }\r\n *\r\n * @param {String} serviceName - The fully-qualified name of this\r\n *   service, used as a key into the client config file (in the\r\n *   example above, this value should be 'google.fake.v1.ServiceName').\r\n * @param {Object} clientConfig - A dictionary parsed from the\r\n *   standard API client config file.\r\n * @param {Object} configOverrides - A dictionary in the same structure of\r\n *   client_config to override the settings.\r\n * @param {Object.<string, string[]>} retryNames - A dictionary mapping the strings\r\n *   referring to response status codes to objects representing\r\n *   those codes.\r\n * @param {Object} otherArgs - the non-request arguments to be passed to the API\r\n *   calls.\r\n * @return {Object} A mapping from method name to CallSettings, or null if the\r\n *   service is not found in the config.\r\n */\r\nfunction constructSettings(serviceName, clientConfig, configOverrides, retryNames, otherArgs) {\r\n    otherArgs = otherArgs || {};\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const defaults = {};\r\n    const serviceConfig = (clientConfig.interfaces || {})[serviceName];\r\n    if (!serviceConfig) {\r\n        return null;\r\n    }\r\n    // users can override the config from client side, like bundling options.\r\n    // The detailed structure of the clientConfig can be found here: https://github.com/googleapis/gax-nodejs/blob/main/src/gax.ts#L546\r\n    // The way to override bundling options:\r\n    //\r\n    // const customConfig = {\"interfaces\": {\"service\": {\"methods\": {\"methodName\": {\"bundling\": {..}}}}}}\r\n    // const client = new Client({ projectId, customConfig });\r\n    const overrides = (configOverrides.interfaces || {})[serviceName] || {};\r\n    const methods = serviceConfig.methods;\r\n    const overridingMethods = overrides.methods || {};\r\n    for (const methodName in methods) {\r\n        const methodConfig = methods[methodName];\r\n        const jsName = (0, util_1.toLowerCamelCase)(methodName);\r\n        let retry = constructRetry(methodConfig, serviceConfig.retry_codes, serviceConfig.retry_params, retryNames);\r\n        let bundlingConfig = methodConfig.bundling;\r\n        let timeout = methodConfig.timeout_millis;\r\n        if (methodName in overridingMethods) {\r\n            const overridingMethod = overridingMethods[methodName];\r\n            if (overridingMethod) {\r\n                if ('bundling' in overridingMethod) {\r\n                    bundlingConfig = overridingMethod.bundling;\r\n                }\r\n                if ('timeout_millis' in overridingMethod) {\r\n                    timeout = overridingMethod.timeout_millis;\r\n                }\r\n            }\r\n            retry = mergeRetryOptions(retry, constructRetry(overridingMethod, overrides.retry_codes, overrides.retry_params, retryNames));\r\n        }\r\n        const apiName = serviceName;\r\n        defaults[jsName] = new CallSettings({\r\n            timeout,\r\n            retry,\r\n            bundleOptions: bundlingConfig\r\n                ? createBundleOptions(bundlingConfig)\r\n                : null,\r\n            otherArgs,\r\n            apiName,\r\n        });\r\n    }\r\n    return defaults;\r\n}\r\nfunction createByteLengthFunction(message) {\r\n    return function getByteLength(obj) {\r\n        try {\r\n            return message.encode(obj).finish().length;\r\n        }\r\n        catch (err) {\r\n            const stringified = JSON.stringify(obj);\r\n            (0, warnings_1.warn)('error_encoding_protobufjs_object', `Cannot encode protobuf.js object: ${stringified}: ${err}`);\r\n            // We failed to encode the object properly, let's just return an upper boundary of its length.\r\n            // It's only needed for calculating the size of the batch, so it's safe if it's bigger than needed.\r\n            return stringified.length;\r\n        }\r\n    };\r\n}\r\n//# sourceMappingURL=gax.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}