{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BulkWriter = exports.BulkWriterError = exports.DEFAULT_JITTER_FACTOR = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = exports.RETRY_MAX_BATCH_SIZE = void 0;\nconst assert = require(\"assert\");\nconst backoff_1 = require(\"./backoff\");\nconst rate_limiter_1 = require(\"./rate-limiter\");\nconst timestamp_1 = require(\"./timestamp\");\nconst util_1 = require(\"./util\");\nconst write_batch_1 = require(\"./write-batch\");\nconst validate_1 = require(\"./validate\");\nconst logger_1 = require(\"./logger\");\nconst trace_util_1 = require(\"./telemetry/trace-util\");\n/*!\r\n * The maximum number of writes that can be in a single batch.\r\n */\nconst MAX_BATCH_SIZE = 20;\n/*!\r\n * The maximum number of writes can be can in a single batch that is being retried.\r\n */\nexports.RETRY_MAX_BATCH_SIZE = 10;\n/*!\r\n * The starting maximum number of operations per second as allowed by the\r\n * 500/50/5 rule.\r\n *\r\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\r\n */\nexports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = 500;\n/*!\r\n * The maximum number of operations per second as allowed by the 500/50/5 rule.\r\n * By default the rate limiter will not exceed this value.\r\n *\r\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\r\n */\nexports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = 10000;\n/*!\r\n * The default jitter to apply to the exponential backoff used in retries. For\r\n * example, a factor of 0.3 means a 30% jitter is applied.\r\n */\nexports.DEFAULT_JITTER_FACTOR = 0.3;\n/*!\r\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\r\n */\nconst RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\r\n * How often the operations per second capacity should increase in milliseconds\r\n * as specified by the 500/50/5 rule.\r\n */\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\r\n * The default maximum number of pending operations that can be enqueued onto a\r\n * BulkWriter instance. An operation is considered pending if BulkWriter has\r\n * sent it via RPC and is awaiting the result. BulkWriter buffers additional\r\n * writes after this many pending operations in order to avoiding going OOM.\r\n */\nconst DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT = 500;\n/**\r\n * Represents a single write for BulkWriter, encapsulating operation dispatch\r\n * and error handling.\r\n * @private\r\n * @internal\r\n */\nclass BulkWriterOperation {\n  /**\r\n   * @param ref The document reference being written to.\r\n   * @param type The type of operation that created this write.\r\n   * @param sendFn A callback to invoke when the operation should be sent.\r\n   * @param errorFn The user provided global error callback.\r\n   * @param successFn The user provided global success callback.\r\n   */\n  constructor(ref, type, sendFn, errorFn, successFn) {\n    this.ref = ref;\n    this.type = type;\n    this.sendFn = sendFn;\n    this.errorFn = errorFn;\n    this.successFn = successFn;\n    this.deferred = new util_1.Deferred();\n    this.failedAttempts = 0;\n    this._backoffDuration = 0;\n    /** Whether flush() was called when this was the last enqueued operation. */\n    this._flushed = false;\n  }\n  get promise() {\n    return this.deferred.promise;\n  }\n  get backoffDuration() {\n    return this._backoffDuration;\n  }\n  markFlushed() {\n    this._flushed = true;\n  }\n  get flushed() {\n    return this._flushed;\n  }\n  onError(error) {\n    ++this.failedAttempts;\n    try {\n      const bulkWriterError = new BulkWriterError(error.code, error.message, this.ref, this.type, this.failedAttempts);\n      const shouldRetry = this.errorFn(bulkWriterError);\n      (0, logger_1.logger)('BulkWriter.errorFn', null, 'Ran error callback on error code:', error.code, ', shouldRetry:', shouldRetry, ' for document:', this.ref.path);\n      if (shouldRetry) {\n        this.lastStatus = error.code;\n        this.updateBackoffDuration();\n        this.sendFn(this);\n      } else {\n        this.deferred.reject(bulkWriterError);\n      }\n    } catch (userCallbackError) {\n      this.deferred.reject(userCallbackError);\n    }\n  }\n  updateBackoffDuration() {\n    if (this.lastStatus === 8 /* StatusCode.RESOURCE_EXHAUSTED */) {\n      this._backoffDuration = backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS;\n    } else if (this._backoffDuration === 0) {\n      this._backoffDuration = backoff_1.DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n    } else {\n      this._backoffDuration *= backoff_1.DEFAULT_BACKOFF_FACTOR;\n    }\n  }\n  onSuccess(result) {\n    try {\n      this.successFn(this.ref, result);\n      this.deferred.resolve(result);\n    } catch (userCallbackError) {\n      this.deferred.reject(userCallbackError);\n    }\n  }\n}\n/**\r\n * Used to represent a batch on the BatchQueue.\r\n *\r\n * @private\r\n * @internal\r\n */\nclass BulkCommitBatch extends write_batch_1.WriteBatch {\n  constructor(firestore, maxBatchSize) {\n    super(firestore);\n    // The set of document reference paths present in the WriteBatch.\n    this.docPaths = new Set();\n    // An array of pending write operations. Only contains writes that have not\n    // been resolved.\n    this.pendingOps = [];\n    this._maxBatchSize = maxBatchSize;\n  }\n  get maxBatchSize() {\n    return this._maxBatchSize;\n  }\n  setMaxBatchSize(size) {\n    assert(this.pendingOps.length <= size, 'New batch size cannot be less than the number of enqueued writes');\n    this._maxBatchSize = size;\n  }\n  has(documentRef) {\n    return this.docPaths.has(documentRef.path);\n  }\n  async bulkCommit(options = {}) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_BULK_WRITER_COMMIT, async () => {\n      var _a;\n      const tag = (_a = options === null || options === void 0 ? void 0 : options.requestTag) !== null && _a !== void 0 ? _a : (0, util_1.requestTag)();\n      // Capture the error stack to preserve stack tracing across async calls.\n      const stack = Error().stack;\n      let response;\n      try {\n        (0, logger_1.logger)('BulkCommitBatch.bulkCommit', tag, `Sending next batch with ${this._opCount} writes`);\n        const retryCodes = (0, util_1.getRetryCodes)('batchWrite');\n        response = await this._commit({\n          retryCodes,\n          methodName: 'batchWrite',\n          requestTag: tag\n        });\n      } catch (err) {\n        // Map the failure to each individual write's result.\n        const ops = Array.from({\n          length: this.pendingOps.length\n        });\n        response = {\n          writeResults: ops.map(() => {\n            return {};\n          }),\n          status: ops.map(() => err)\n        };\n      }\n      for (let i = 0; i < (response.writeResults || []).length; ++i) {\n        // Since delete operations currently do not have write times, use a\n        // sentinel Timestamp value.\n        // TODO(b/158502664): Use actual delete timestamp.\n        const DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);\n        const status = (response.status || [])[i];\n        if (status.code === 0 /* StatusCode.OK */) {\n          const updateTime = timestamp_1.Timestamp.fromProto(response.writeResults[i].updateTime || DELETE_TIMESTAMP_SENTINEL);\n          this.pendingOps[i].onSuccess(new write_batch_1.WriteResult(updateTime));\n        } else {\n          const error = new (require('google-gax/build/src/fallback').GoogleError)(status.message || undefined);\n          error.code = status.code;\n          this.pendingOps[i].onError((0, util_1.wrapError)(error, stack));\n        }\n      }\n    }, {\n      [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: this._opCount\n    });\n  }\n  /**\r\n   * Helper to update data structures associated with the operation and returns\r\n   * the result.\r\n   */\n  processLastOperation(op) {\n    assert(!this.docPaths.has(op.ref.path), 'Batch should not contain writes to the same document');\n    this.docPaths.add(op.ref.path);\n    this.pendingOps.push(op);\n  }\n}\n/**\r\n * Used to represent a buffered BulkWriterOperation.\r\n *\r\n * @private\r\n * @internal\r\n */\nclass BufferedOperation {\n  constructor(operation, sendFn) {\n    this.operation = operation;\n    this.sendFn = sendFn;\n  }\n}\n/**\r\n * The error thrown when a BulkWriter operation fails.\r\n *\r\n * @class BulkWriterError\r\n */\nclass BulkWriterError extends Error {\n  /**\r\n   * @private\r\n   * @internal\r\n   */\n  constructor(/** The status code of the error. */\n  code, /** The error message of the error. */\n  message, /** The document reference the operation was performed on. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  documentRef, /** The type of operation performed. */\n  operationType, /** How many times this operation has been attempted unsuccessfully. */\n  failedAttempts) {\n    super(message);\n    this.code = code;\n    this.message = message;\n    this.documentRef = documentRef;\n    this.operationType = operationType;\n    this.failedAttempts = failedAttempts;\n  }\n}\nexports.BulkWriterError = BulkWriterError;\n/**\r\n * A Firestore BulkWriter that can be used to perform a large number of writes\r\n * in parallel.\r\n *\r\n * @class BulkWriter\r\n */\nclass BulkWriter {\n  // Visible for testing.\n  /**\r\n   * @private\r\n   * @internal\r\n   */\n  _getBufferedOperationsCount() {\n    return this._bufferedOperations.length;\n  }\n  // Visible for testing.\n  /**\r\n   * @private\r\n   * @internal\r\n   */\n  _setMaxBatchSize(size) {\n    assert(this._bulkCommitBatch.pendingOps.length === 0, 'BulkCommitBatch should be empty');\n    this._maxBatchSize = size;\n    this._bulkCommitBatch = new BulkCommitBatch(this.firestore, size);\n  }\n  // Visible for testing.\n  /**\r\n   * @private\r\n   * @internal\r\n   */\n  _setMaxPendingOpCount(newMax) {\n    this._maxPendingOpCount = newMax;\n  }\n  /** @private */\n  constructor(firestore, options) {\n    var _a, _b;\n    this.firestore = firestore;\n    /**\r\n     * The maximum number of writes that can be in a single batch.\r\n     * Visible for testing.\r\n     * @private\r\n     * @internal\r\n     */\n    this._maxBatchSize = MAX_BATCH_SIZE;\n    /**\r\n     * The batch that is currently used to schedule operations. Once this batch\r\n     * reaches maximum capacity, a new batch is created.\r\n     * @private\r\n     * @internal\r\n     */\n    this._bulkCommitBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);\n    /**\r\n     * A pointer to the tail of all active BulkWriter operations. This pointer\r\n     * is advanced every time a new write is enqueued.\r\n     * @private\r\n     * @internal\r\n     */\n    this._lastOp = Promise.resolve();\n    /**\r\n     * Whether this BulkWriter instance has started to close. Afterwards, no\r\n     * new operations can be enqueued, except for retry operations scheduled by\r\n     * the error handler.\r\n     * @private\r\n     * @internal\r\n     */\n    this._closing = false;\n    /**\r\n     * The number of pending operations enqueued on this BulkWriter instance.\r\n     * An operation is considered pending if BulkWriter has sent it via RPC and\r\n     * is awaiting the result.\r\n     * @private\r\n     * @internal\r\n     */\n    this._pendingOpsCount = 0;\n    /**\r\n     * An array containing buffered BulkWriter operations after the maximum number\r\n     * of pending operations has been enqueued.\r\n     * @private\r\n     * @internal\r\n     */\n    this._bufferedOperations = [];\n    /**\r\n     * Whether a custom error handler has been set. BulkWriter only swallows\r\n     * errors if an error handler is set. Otherwise, an UnhandledPromiseRejection\r\n     * is thrown by Node if an operation promise is rejected without being\r\n     * handled.\r\n     * @private\r\n     * @internal\r\n     */\n    this._errorHandlerSet = false;\n    /**\r\n     * The maximum number of pending operations that can be enqueued onto this\r\n     * BulkWriter instance. Once the this number of writes have been enqueued,\r\n     * subsequent writes are buffered.\r\n     * @private\r\n     * @internal\r\n     */\n    this._maxPendingOpCount = DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT;\n    /**\r\n     * The user-provided callback to be run every time a BulkWriter operation\r\n     * successfully completes.\r\n     * @private\r\n     * @internal\r\n     */\n    this._successFn = () => {};\n    /**\r\n     * The user-provided callback to be run every time a BulkWriter operation\r\n     * fails.\r\n     * @private\r\n     * @internal\r\n     */\n    this._errorFn = error => {\n      const isRetryableDeleteError = error.operationType === 'delete' && error.code === 13 /* StatusCode.INTERNAL */;\n      const retryCodes = (0, util_1.getRetryCodes)('batchWrite');\n      return (retryCodes.includes(error.code) || isRetryableDeleteError) && error.failedAttempts < backoff_1.MAX_RETRY_ATTEMPTS;\n    };\n    this.firestore._incrementBulkWritersCount();\n    validateBulkWriterOptions(options);\n    if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {\n      this._rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n    } else {\n      let startingRate = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT;\n      let maxRate = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT;\n      if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {\n        if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {\n          maxRate = options.throttling.maxOpsPerSecond;\n        }\n        if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {\n          startingRate = options.throttling.initialOpsPerSecond;\n        }\n        // The initial validation step ensures that the maxOpsPerSecond is\n        // greater than initialOpsPerSecond. If this inequality is true, that\n        // means initialOpsPerSecond was not set and maxOpsPerSecond is less\n        // than the default starting rate.\n        if (maxRate < startingRate) {\n          startingRate = maxRate;\n        }\n        // Ensure that the batch size is not larger than the number of allowed\n        // operations per second.\n        if (startingRate < this._maxBatchSize) {\n          this._maxBatchSize = startingRate;\n        }\n      }\n      this._rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);\n    }\n  }\n  /**\r\n   * Create a document with the provided data. This single operation will fail\r\n   * if a document exists at its location.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * created.\r\n   * @param {T} data The object to serialize as the document.\r\n   * @throws {Error} If the provided input is not a valid Firestore document.\r\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n   * the write. If the write fails, the promise is rejected with a\r\n   * [BulkWriterError]{@link BulkWriterError}.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   * let documentRef = firestore.collection('col').doc();\r\n   *\r\n   * bulkWriter\r\n   *  .create(documentRef, {foo: 'bar'})\r\n   *  .then(result => {\r\n   *    console.log('Successfully executed write at: ', result);\r\n   *  })\r\n   *  .catch(err => {\r\n   *    console.log('Write failed with: ', err);\r\n   *  });\r\n   * });\r\n   * ```\r\n   */\n  create(documentRef, data) {\n    this._verifyNotClosed();\n    return this._enqueue(documentRef, 'create', bulkCommitBatch => bulkCommitBatch.create(documentRef, data));\n  }\n  /**\r\n   * Delete a document from the database.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * deleted.\r\n   * @param {Precondition=} precondition A precondition to enforce for this\r\n   * delete.\r\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n   * document was last updated at lastUpdateTime. Fails the batch if the\r\n   * document doesn't exist or was last updated at a different time.\r\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n   * the delete. If the delete fails, the promise is rejected with a\r\n   * [BulkWriterError]{@link BulkWriterError}.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * bulkWriter\r\n   *  .delete(documentRef)\r\n   *  .then(result => {\r\n   *    console.log('Successfully deleted document');\r\n   *  })\r\n   *  .catch(err => {\r\n   *    console.log('Delete failed with: ', err);\r\n   *  });\r\n   * });\r\n   * ```\r\n   */\n  delete(documentRef, precondition) {\n    this._verifyNotClosed();\n    return this._enqueue(documentRef, 'delete', bulkCommitBatch => bulkCommitBatch.delete(documentRef, precondition));\n  }\n  /**\r\n   * Write to the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. If the document does not\r\n   * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\r\n   * the provided data can be merged into the existing document.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * set.\r\n   * @param {T} data The object to serialize as the document.\r\n   * @param {SetOptions=} options An object to configure the set behavior.\r\n   * @throws {Error} If the provided input is not a valid Firestore document.\r\n   * @param {boolean=} options.merge - If true, set() merges the values\r\n   * specified in its data argument. Fields omitted from this set() call remain\r\n   * untouched. If your input sets any field to an empty map, all nested fields\r\n   * are overwritten.\r\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\r\n   * only replaces the specified field paths. Any field path that is not\r\n   * specified is ignored and remains untouched. If your input sets any field to\r\n   * an empty map, all nested fields are overwritten.\r\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n   * the write. If the write fails, the promise is rejected with a\r\n   * [BulkWriterError]{@link BulkWriterError}.\r\n   *\r\n   *\r\n   * @example\r\n   * ```\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   * let documentRef = firestore.collection('col').doc();\r\n   *\r\n   * bulkWriter\r\n   *  .set(documentRef, {foo: 'bar'})\r\n   *  .then(result => {\r\n   *    console.log('Successfully executed write at: ', result);\r\n   *  })\r\n   *  .catch(err => {\r\n   *    console.log('Write failed with: ', err);\r\n   *  });\r\n   * });\r\n   * ```\r\n   */\n  set(documentRef, data, options) {\n    this._verifyNotClosed();\n    return this._enqueue(documentRef, 'set', bulkCommitBatch => {\n      if (options) {\n        return bulkCommitBatch.set(documentRef, data, options);\n      } else {\n        return bulkCommitBatch.set(documentRef, data);\n      }\n    });\n  }\n  /**\r\n   * Update fields of the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\r\n   * exist, the update fails and the entire batch will be rejected.\r\n   *\r\n   * The update() method accepts either an object with field paths encoded as\r\n   * keys and field values encoded as values, or a variable number of arguments\r\n   * that alternate between field paths and field values. Nested fields can be\r\n   * updated by providing dot-separated field path strings or by providing\r\n   * FieldPath objects.\r\n   *\r\n   *\r\n   * A Precondition restricting this update can be specified as the last\r\n   * argument.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * updated.\r\n   * @param {UpdateData|string|FieldPath} dataOrField An object containing the\r\n   * fields and values with which to update the document or the path of the\r\n   * first field to update.\r\n   * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\r\n   * alternating list of field paths and values to update or a Precondition to\r\n   * restrict this update\r\n   * @throws {Error} If the provided input is not valid Firestore data.\r\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n   * the write. If the write fails, the promise is rejected with a\r\n   * [BulkWriterError]{@link BulkWriterError}.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * bulkWriter\r\n   *  .update(documentRef, {foo: 'bar'})\r\n   *  .then(result => {\r\n   *    console.log('Successfully executed write at: ', result);\r\n   *  })\r\n   *  .catch(err => {\r\n   *    console.log('Write failed with: ', err);\r\n   *  });\r\n   * });\r\n   * ```\r\n   */\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    this._verifyNotClosed();\n    return this._enqueue(documentRef, 'update', bulkCommitBatch => bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues));\n  }\n  /**\r\n   * Callback function set by {@link BulkWriter#onWriteResult} that is run\r\n   * every time a {@link BulkWriter} operation successfully completes.\r\n   *\r\n   * @callback BulkWriter~successCallback\r\n   * @param {DocumentReference} documentRef The document reference the\r\n   * operation was performed on\r\n   * @param {WriteResult} result The server write time of the operation.\r\n   */\n  /**\r\n   * Attaches a listener that is run every time a BulkWriter operation\r\n   * successfully completes.\r\n   *\r\n   * @param {BulkWriter~successCallback} successCallback A callback to be\r\n   * called every time a BulkWriter operation successfully completes.\r\n   * @example\r\n   * ```\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   *\r\n   * bulkWriter\r\n   *   .onWriteResult((documentRef, result) => {\r\n   *     console.log(\r\n   *       'Successfully executed write on document: ',\r\n   *       documentRef,\r\n   *       ' at: ',\r\n   *       result\r\n   *     );\r\n   *   });\r\n   * ```\r\n   */\n  onWriteResult(successCallback) {\n    this._successFn = successCallback;\n  }\n  /**\r\n   * Callback function set by {@link BulkWriter#onWriteError} that is run when\r\n   * a write fails in order to determine whether {@link BulkWriter} should\r\n   * retry the operation.\r\n   *\r\n   * @callback BulkWriter~shouldRetryCallback\r\n   * @param {BulkWriterError} error The error object with information about the\r\n   * operation and error.\r\n   * @returns {boolean} Whether or not to retry the failed operation. Returning\r\n   * `true` retries the operation. Returning `false` will stop the retry loop.\r\n   */\n  /**\r\n   * Attaches an error handler listener that is run every time a BulkWriter\r\n   * operation fails.\r\n   *\r\n   * BulkWriter has a default error handler that retries UNAVAILABLE and\r\n   * ABORTED errors up to a maximum of 10 failed attempts. When an error\r\n   * handler is specified, the default error handler will be overwritten.\r\n   *\r\n   * @param shouldRetryCallback {BulkWriter~shouldRetryCallback} A callback to\r\n   * be called every time a BulkWriter operation fails. Returning `true` will\r\n   * retry the operation. Returning `false` will stop the retry loop.\r\n   * @example\r\n   * ```\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   *\r\n   * bulkWriter\r\n   *   .onWriteError((error) => {\r\n   *     if (\r\n   *       error.code === GrpcStatus.UNAVAILABLE &&\r\n   *       error.failedAttempts < MAX_RETRY_ATTEMPTS\r\n   *     ) {\r\n   *       return true;\r\n   *     } else {\r\n   *       console.log('Failed write at document: ', error.documentRef);\r\n   *       return false;\r\n   *     }\r\n   *   });\r\n   * ```\r\n   */\n  onWriteError(shouldRetryCallback) {\n    this._errorHandlerSet = true;\n    this._errorFn = shouldRetryCallback;\n  }\n  /**\r\n   * Commits all writes that have been enqueued up to this point in parallel.\r\n   *\r\n   * Returns a Promise that resolves when all currently queued operations have\r\n   * been committed. The Promise will never be rejected since the results for\r\n   * each individual operation are conveyed via their individual Promises.\r\n   *\r\n   * The Promise resolves immediately if there are no pending writes. Otherwise,\r\n   * the Promise waits for all previously issued writes, but it does not wait\r\n   * for writes that were added after the method is called. If you want to wait\r\n   * for additional writes, call `flush()` again.\r\n   *\r\n   * @return {Promise<void>} A promise that resolves when all enqueued writes\r\n   * up to this point have been committed.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   *\r\n   * bulkWriter.create(documentRef, {foo: 'bar'});\r\n   * bulkWriter.update(documentRef2, {foo: 'bar'});\r\n   * bulkWriter.delete(documentRef3);\r\n   * await flush().then(() => {\r\n   *   console.log('Executed all writes');\r\n   * });\r\n   * ```\r\n   */\n  flush() {\n    this._verifyNotClosed();\n    this._scheduleCurrentBatch(/* flush= */true);\n    // Mark the most recent operation as flushed to ensure that the batch\n    // containing it will be sent once it's popped from the buffer.\n    if (this._bufferedOperations.length > 0) {\n      this._bufferedOperations[this._bufferedOperations.length - 1].operation.markFlushed();\n    }\n    return this._lastOp;\n  }\n  /**\r\n   * Commits all enqueued writes and marks the BulkWriter instance as closed.\r\n   *\r\n   * After calling `close()`, calling any method will throw an error. Any\r\n   * retries scheduled as part of an `onWriteError()` handler will be run\r\n   * before the `close()` promise resolves.\r\n   *\r\n   * Returns a Promise that resolves when there are no more pending writes. The\r\n   * Promise will never be rejected. Calling this method will send all requests.\r\n   * The promise resolves immediately if there are no pending writes.\r\n   *\r\n   * @return {Promise<void>} A promise that resolves when all enqueued writes\r\n   * up to this point have been committed.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   *\r\n   * bulkWriter.create(documentRef, {foo: 'bar'});\r\n   * bulkWriter.update(documentRef2, {foo: 'bar'});\r\n   * bulkWriter.delete(documentRef3);\r\n   * await close().then(() => {\r\n   *   console.log('Executed all writes');\r\n   * });\r\n   * ```\r\n   */\n  close() {\n    this._verifyNotClosed();\n    this.firestore._decrementBulkWritersCount();\n    const flushPromise = this.flush();\n    this._closing = true;\n    return flushPromise;\n  }\n  /**\r\n   * Throws an error if the BulkWriter instance has been closed.\r\n   * @private\r\n   * @internal\r\n   */\n  _verifyNotClosed() {\n    if (this._closing) {\n      throw new Error('BulkWriter has already been closed.');\n    }\n  }\n  /**\r\n   * Sends the current batch and resets `this._bulkCommitBatch`.\r\n   *\r\n   * @param flush If provided, keeps re-sending operations until no more\r\n   * operations are enqueued. This allows retries to resolve as part of a\r\n   * `flush()` or `close()` call.\r\n   * @private\r\n   * @internal\r\n   */\n  _scheduleCurrentBatch(flush = false) {\n    if (this._bulkCommitBatch._opCount === 0) return;\n    const pendingBatch = this._bulkCommitBatch;\n    this._bulkCommitBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);\n    // Use the write with the longest backoff duration when determining backoff.\n    const highestBackoffDuration = pendingBatch.pendingOps.reduce((prev, cur) => prev.backoffDuration > cur.backoffDuration ? prev : cur).backoffDuration;\n    const backoffMsWithJitter = BulkWriter._applyJitter(highestBackoffDuration);\n    const delayedExecution = new util_1.Deferred();\n    if (backoffMsWithJitter > 0) {\n      (0, backoff_1.delayExecution)(() => delayedExecution.resolve(), backoffMsWithJitter);\n    } else {\n      delayedExecution.resolve();\n    }\n    delayedExecution.promise.then(() => this._sendBatch(pendingBatch, flush));\n  }\n  /**\r\n   * Sends the provided batch once the rate limiter does not require any delay.\r\n   * @private\r\n   * @internal\r\n   */\n  async _sendBatch(batch, flush = false) {\n    const tag = (0, util_1.requestTag)();\n    // Send the batch if it is does not require any delay, or schedule another\n    // attempt after the appropriate timeout.\n    const underRateLimit = this._rateLimiter.tryMakeRequest(batch._opCount);\n    if (underRateLimit) {\n      await batch.bulkCommit({\n        requestTag: tag\n      });\n      if (flush) this._scheduleCurrentBatch(flush);\n    } else {\n      const delayMs = this._rateLimiter.getNextRequestDelayMs(batch._opCount);\n      (0, logger_1.logger)('BulkWriter._sendBatch', tag, `Backing off for ${delayMs} seconds`);\n      (0, backoff_1.delayExecution)(() => this._sendBatch(batch, flush), delayMs);\n    }\n  }\n  /**\r\n   * Adds a 30% jitter to the provided backoff.\r\n   *\r\n   * @private\r\n   * @internal\r\n   */\n  static _applyJitter(backoffMs) {\n    if (backoffMs === 0) return 0;\n    // Random value in [-0.3, 0.3].\n    const jitter = exports.DEFAULT_JITTER_FACTOR * (Math.random() * 2 - 1);\n    return Math.min(backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS, backoffMs + jitter * backoffMs);\n  }\n  /**\r\n   * Schedules and runs the provided operation on the next available batch.\r\n   * @private\r\n   * @internal\r\n   */\n  _enqueue(ref, type, enqueueOnBatchCallback) {\n    const bulkWriterOp = new BulkWriterOperation(ref, type, this._sendFn.bind(this, enqueueOnBatchCallback), this._errorFn.bind(this), this._successFn.bind(this));\n    // Swallow the error if the developer has set an error listener. This\n    // prevents UnhandledPromiseRejections from being thrown if a floating\n    // BulkWriter operation promise fails when an error handler is specified.\n    //\n    // This is done here in order to chain the caught promise onto `lastOp`,\n    // which ensures that flush() resolves after the operation promise.\n    const userPromise = bulkWriterOp.promise.catch(err => {\n      if (!this._errorHandlerSet) {\n        throw err;\n      } else {\n        return bulkWriterOp.promise;\n      }\n    });\n    // Advance the `_lastOp` pointer. This ensures that `_lastOp` only resolves\n    // when both the previous and the current write resolve.\n    this._lastOp = this._lastOp.then(() => (0, util_1.silencePromise)(userPromise));\n    // Schedule the operation if the BulkWriter has fewer than the maximum\n    // number of allowed pending operations, or add the operation to the\n    // buffer.\n    if (this._pendingOpsCount < this._maxPendingOpCount) {\n      this._pendingOpsCount++;\n      this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\n    } else {\n      this._bufferedOperations.push(new BufferedOperation(bulkWriterOp, () => {\n        this._pendingOpsCount++;\n        this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\n      }));\n    }\n    // Chain the BulkWriter operation promise with the buffer processing logic\n    // in order to ensure that it runs and that subsequent operations are\n    // enqueued before the next batch is scheduled in `_sendBatch()`.\n    return userPromise.then(res => {\n      this._pendingOpsCount--;\n      this._processBufferedOps();\n      return res;\n    }).catch(err => {\n      this._pendingOpsCount--;\n      this._processBufferedOps();\n      throw err;\n    });\n  }\n  /**\r\n   * Manages the pending operation counter and schedules the next BulkWriter\r\n   * operation if we're under the maximum limit.\r\n   * @private\r\n   * @internal\r\n   */\n  _processBufferedOps() {\n    if (this._pendingOpsCount < this._maxPendingOpCount && this._bufferedOperations.length > 0) {\n      const nextOp = this._bufferedOperations.shift();\n      nextOp.sendFn();\n    }\n  }\n  /**\r\n   * Schedules the provided operations on current BulkCommitBatch.\r\n   * Sends the BulkCommitBatch if it reaches maximum capacity.\r\n   *\r\n   * @private\r\n   * @internal\r\n   */\n  _sendFn(enqueueOnBatchCallback, op) {\n    // A backoff duration greater than 0 implies that this batch is a retry.\n    // Retried writes are sent with a batch size of 10 in order to guarantee\n    // that the batch is under the 10MiB limit.\n    if (op.backoffDuration > 0) {\n      if (this._bulkCommitBatch.pendingOps.length >= exports.RETRY_MAX_BATCH_SIZE) {\n        this._scheduleCurrentBatch(/* flush= */false);\n      }\n      this._bulkCommitBatch.setMaxBatchSize(exports.RETRY_MAX_BATCH_SIZE);\n    }\n    if (this._bulkCommitBatch.has(op.ref)) {\n      // Create a new batch since the backend doesn't support batches with two\n      // writes to the same document.\n      this._scheduleCurrentBatch();\n    }\n    enqueueOnBatchCallback(this._bulkCommitBatch);\n    this._bulkCommitBatch.processLastOperation(op);\n    if (this._bulkCommitBatch._opCount === this._bulkCommitBatch.maxBatchSize) {\n      this._scheduleCurrentBatch();\n    } else if (op.flushed) {\n      // If flush() was called before this operation was enqueued into a batch,\n      // we still need to schedule it.\n      this._scheduleCurrentBatch(/* flush= */true);\n    }\n  }\n}\nexports.BulkWriter = BulkWriter;\n/**\r\n * Validates the use of 'value' as BulkWriterOptions.\r\n *\r\n * @private\r\n * @internal\r\n * @param value The BulkWriterOptions object to validate.\r\n * @throws if the input is not a valid BulkWriterOptions object.\r\n */\nfunction validateBulkWriterOptions(value) {\n  if ((0, validate_1.validateOptional)(value, {\n    optional: true\n  })) {\n    return;\n  }\n  const argName = 'options';\n  if (!(0, util_1.isObject)(value)) {\n    throw new Error(`${(0, validate_1.invalidArgumentMessage)(argName, 'bulkWriter() options argument')} Input is not an object.`);\n  }\n  const options = value;\n  if (options.throttling === undefined || typeof options.throttling === 'boolean') {\n    return;\n  }\n  if (options.throttling.initialOpsPerSecond !== undefined) {\n    (0, validate_1.validateInteger)('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {\n      minValue: 1\n    });\n  }\n  if (options.throttling.maxOpsPerSecond !== undefined) {\n    (0, validate_1.validateInteger)('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {\n      minValue: 1\n    });\n    if (options.throttling.initialOpsPerSecond !== undefined && options.throttling.initialOpsPerSecond > options.throttling.maxOpsPerSecond) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(argName, 'bulkWriter() options argument')} \"maxOpsPerSecond\" cannot be less than \"initialOpsPerSecond\".`);\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","BulkWriter","BulkWriterError","DEFAULT_JITTER_FACTOR","DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT","DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT","RETRY_MAX_BATCH_SIZE","assert","require","backoff_1","rate_limiter_1","timestamp_1","util_1","write_batch_1","validate_1","logger_1","trace_util_1","MAX_BATCH_SIZE","RATE_LIMITER_MULTIPLIER","RATE_LIMITER_MULTIPLIER_MILLIS","DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT","BulkWriterOperation","constructor","ref","type","sendFn","errorFn","successFn","deferred","Deferred","failedAttempts","_backoffDuration","_flushed","promise","backoffDuration","markFlushed","flushed","onError","error","bulkWriterError","code","message","shouldRetry","logger","path","lastStatus","updateBackoffDuration","reject","userCallbackError","DEFAULT_BACKOFF_MAX_DELAY_MS","DEFAULT_BACKOFF_INITIAL_DELAY_MS","DEFAULT_BACKOFF_FACTOR","onSuccess","result","resolve","BulkCommitBatch","WriteBatch","firestore","maxBatchSize","docPaths","Set","pendingOps","_maxBatchSize","setMaxBatchSize","size","length","has","documentRef","bulkCommit","options","_firestore","_traceUtil","startActiveSpan","SPAN_NAME_BULK_WRITER_COMMIT","_a","tag","requestTag","stack","Error","response","_opCount","retryCodes","getRetryCodes","_commit","methodName","err","ops","Array","from","writeResults","map","status","i","DELETE_TIMESTAMP_SENTINEL","Timestamp","fromMillis","updateTime","fromProto","WriteResult","GoogleError","undefined","wrapError","ATTRIBUTE_KEY_DOC_COUNT","processLastOperation","op","add","push","BufferedOperation","operation","operationType","_getBufferedOperationsCount","_bufferedOperations","_setMaxBatchSize","_bulkCommitBatch","_setMaxPendingOpCount","newMax","_maxPendingOpCount","_b","_lastOp","Promise","_closing","_pendingOpsCount","_errorHandlerSet","_successFn","_errorFn","isRetryableDeleteError","includes","MAX_RETRY_ATTEMPTS","_incrementBulkWritersCount","validateBulkWriterOptions","throttling","_rateLimiter","RateLimiter","Number","POSITIVE_INFINITY","startingRate","maxRate","maxOpsPerSecond","initialOpsPerSecond","create","data","_verifyNotClosed","_enqueue","bulkCommitBatch","delete","precondition","set","update","dataOrField","preconditionOrValues","onWriteResult","successCallback","onWriteError","shouldRetryCallback","flush","_scheduleCurrentBatch","close","_decrementBulkWritersCount","flushPromise","pendingBatch","highestBackoffDuration","reduce","prev","cur","backoffMsWithJitter","_applyJitter","delayedExecution","delayExecution","then","_sendBatch","batch","underRateLimit","tryMakeRequest","delayMs","getNextRequestDelayMs","backoffMs","jitter","Math","random","min","enqueueOnBatchCallback","bulkWriterOp","_sendFn","bind","userPromise","catch","silencePromise","res","_processBufferedOps","nextOp","shift","validateOptional","optional","argName","isObject","invalidArgumentMessage","validateInteger","minValue"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@google-cloud/firestore/build/src/bulk-writer.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BulkWriter = exports.BulkWriterError = exports.DEFAULT_JITTER_FACTOR = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = exports.RETRY_MAX_BATCH_SIZE = void 0;\r\nconst assert = require(\"assert\");\r\nconst backoff_1 = require(\"./backoff\");\r\nconst rate_limiter_1 = require(\"./rate-limiter\");\r\nconst timestamp_1 = require(\"./timestamp\");\r\nconst util_1 = require(\"./util\");\r\nconst write_batch_1 = require(\"./write-batch\");\r\nconst validate_1 = require(\"./validate\");\r\nconst logger_1 = require(\"./logger\");\r\nconst trace_util_1 = require(\"./telemetry/trace-util\");\r\n/*!\r\n * The maximum number of writes that can be in a single batch.\r\n */\r\nconst MAX_BATCH_SIZE = 20;\r\n/*!\r\n * The maximum number of writes can be can in a single batch that is being retried.\r\n */\r\nexports.RETRY_MAX_BATCH_SIZE = 10;\r\n/*!\r\n * The starting maximum number of operations per second as allowed by the\r\n * 500/50/5 rule.\r\n *\r\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\r\n */\r\nexports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = 500;\r\n/*!\r\n * The maximum number of operations per second as allowed by the 500/50/5 rule.\r\n * By default the rate limiter will not exceed this value.\r\n *\r\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\r\n */\r\nexports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = 10000;\r\n/*!\r\n * The default jitter to apply to the exponential backoff used in retries. For\r\n * example, a factor of 0.3 means a 30% jitter is applied.\r\n */\r\nexports.DEFAULT_JITTER_FACTOR = 0.3;\r\n/*!\r\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\r\n */\r\nconst RATE_LIMITER_MULTIPLIER = 1.5;\r\n/*!\r\n * How often the operations per second capacity should increase in milliseconds\r\n * as specified by the 500/50/5 rule.\r\n */\r\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\r\n/*!\r\n * The default maximum number of pending operations that can be enqueued onto a\r\n * BulkWriter instance. An operation is considered pending if BulkWriter has\r\n * sent it via RPC and is awaiting the result. BulkWriter buffers additional\r\n * writes after this many pending operations in order to avoiding going OOM.\r\n */\r\nconst DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT = 500;\r\n/**\r\n * Represents a single write for BulkWriter, encapsulating operation dispatch\r\n * and error handling.\r\n * @private\r\n * @internal\r\n */\r\nclass BulkWriterOperation {\r\n    /**\r\n     * @param ref The document reference being written to.\r\n     * @param type The type of operation that created this write.\r\n     * @param sendFn A callback to invoke when the operation should be sent.\r\n     * @param errorFn The user provided global error callback.\r\n     * @param successFn The user provided global success callback.\r\n     */\r\n    constructor(ref, type, sendFn, errorFn, successFn) {\r\n        this.ref = ref;\r\n        this.type = type;\r\n        this.sendFn = sendFn;\r\n        this.errorFn = errorFn;\r\n        this.successFn = successFn;\r\n        this.deferred = new util_1.Deferred();\r\n        this.failedAttempts = 0;\r\n        this._backoffDuration = 0;\r\n        /** Whether flush() was called when this was the last enqueued operation. */\r\n        this._flushed = false;\r\n    }\r\n    get promise() {\r\n        return this.deferred.promise;\r\n    }\r\n    get backoffDuration() {\r\n        return this._backoffDuration;\r\n    }\r\n    markFlushed() {\r\n        this._flushed = true;\r\n    }\r\n    get flushed() {\r\n        return this._flushed;\r\n    }\r\n    onError(error) {\r\n        ++this.failedAttempts;\r\n        try {\r\n            const bulkWriterError = new BulkWriterError(error.code, error.message, this.ref, this.type, this.failedAttempts);\r\n            const shouldRetry = this.errorFn(bulkWriterError);\r\n            (0, logger_1.logger)('BulkWriter.errorFn', null, 'Ran error callback on error code:', error.code, ', shouldRetry:', shouldRetry, ' for document:', this.ref.path);\r\n            if (shouldRetry) {\r\n                this.lastStatus = error.code;\r\n                this.updateBackoffDuration();\r\n                this.sendFn(this);\r\n            }\r\n            else {\r\n                this.deferred.reject(bulkWriterError);\r\n            }\r\n        }\r\n        catch (userCallbackError) {\r\n            this.deferred.reject(userCallbackError);\r\n        }\r\n    }\r\n    updateBackoffDuration() {\r\n        if (this.lastStatus === 8 /* StatusCode.RESOURCE_EXHAUSTED */) {\r\n            this._backoffDuration = backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS;\r\n        }\r\n        else if (this._backoffDuration === 0) {\r\n            this._backoffDuration = backoff_1.DEFAULT_BACKOFF_INITIAL_DELAY_MS;\r\n        }\r\n        else {\r\n            this._backoffDuration *= backoff_1.DEFAULT_BACKOFF_FACTOR;\r\n        }\r\n    }\r\n    onSuccess(result) {\r\n        try {\r\n            this.successFn(this.ref, result);\r\n            this.deferred.resolve(result);\r\n        }\r\n        catch (userCallbackError) {\r\n            this.deferred.reject(userCallbackError);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Used to represent a batch on the BatchQueue.\r\n *\r\n * @private\r\n * @internal\r\n */\r\nclass BulkCommitBatch extends write_batch_1.WriteBatch {\r\n    constructor(firestore, maxBatchSize) {\r\n        super(firestore);\r\n        // The set of document reference paths present in the WriteBatch.\r\n        this.docPaths = new Set();\r\n        // An array of pending write operations. Only contains writes that have not\r\n        // been resolved.\r\n        this.pendingOps = [];\r\n        this._maxBatchSize = maxBatchSize;\r\n    }\r\n    get maxBatchSize() {\r\n        return this._maxBatchSize;\r\n    }\r\n    setMaxBatchSize(size) {\r\n        assert(this.pendingOps.length <= size, 'New batch size cannot be less than the number of enqueued writes');\r\n        this._maxBatchSize = size;\r\n    }\r\n    has(documentRef) {\r\n        return this.docPaths.has(documentRef.path);\r\n    }\r\n    async bulkCommit(options = {}) {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_BULK_WRITER_COMMIT, async () => {\r\n            var _a;\r\n            const tag = (_a = options === null || options === void 0 ? void 0 : options.requestTag) !== null && _a !== void 0 ? _a : (0, util_1.requestTag)();\r\n            // Capture the error stack to preserve stack tracing across async calls.\r\n            const stack = Error().stack;\r\n            let response;\r\n            try {\r\n                (0, logger_1.logger)('BulkCommitBatch.bulkCommit', tag, `Sending next batch with ${this._opCount} writes`);\r\n                const retryCodes = (0, util_1.getRetryCodes)('batchWrite');\r\n                response = await this._commit({ retryCodes, methodName: 'batchWrite', requestTag: tag });\r\n            }\r\n            catch (err) {\r\n                // Map the failure to each individual write's result.\r\n                const ops = Array.from({ length: this.pendingOps.length });\r\n                response = {\r\n                    writeResults: ops.map(() => {\r\n                        return {};\r\n                    }),\r\n                    status: ops.map(() => err),\r\n                };\r\n            }\r\n            for (let i = 0; i < (response.writeResults || []).length; ++i) {\r\n                // Since delete operations currently do not have write times, use a\r\n                // sentinel Timestamp value.\r\n                // TODO(b/158502664): Use actual delete timestamp.\r\n                const DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);\r\n                const status = (response.status || [])[i];\r\n                if (status.code === 0 /* StatusCode.OK */) {\r\n                    const updateTime = timestamp_1.Timestamp.fromProto(response.writeResults[i].updateTime || DELETE_TIMESTAMP_SENTINEL);\r\n                    this.pendingOps[i].onSuccess(new write_batch_1.WriteResult(updateTime));\r\n                }\r\n                else {\r\n                    const error = new (require('google-gax/build/src/fallback').GoogleError)(status.message || undefined);\r\n                    error.code = status.code;\r\n                    this.pendingOps[i].onError((0, util_1.wrapError)(error, stack));\r\n                }\r\n            }\r\n        }, {\r\n            [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: this._opCount,\r\n        });\r\n    }\r\n    /**\r\n     * Helper to update data structures associated with the operation and returns\r\n     * the result.\r\n     */\r\n    processLastOperation(op) {\r\n        assert(!this.docPaths.has(op.ref.path), 'Batch should not contain writes to the same document');\r\n        this.docPaths.add(op.ref.path);\r\n        this.pendingOps.push(op);\r\n    }\r\n}\r\n/**\r\n * Used to represent a buffered BulkWriterOperation.\r\n *\r\n * @private\r\n * @internal\r\n */\r\nclass BufferedOperation {\r\n    constructor(operation, sendFn) {\r\n        this.operation = operation;\r\n        this.sendFn = sendFn;\r\n    }\r\n}\r\n/**\r\n * The error thrown when a BulkWriter operation fails.\r\n *\r\n * @class BulkWriterError\r\n */\r\nclass BulkWriterError extends Error {\r\n    /**\r\n     * @private\r\n     * @internal\r\n     */\r\n    constructor(\r\n    /** The status code of the error. */\r\n    code, \r\n    /** The error message of the error. */\r\n    message, \r\n    /** The document reference the operation was performed on. */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    documentRef, \r\n    /** The type of operation performed. */\r\n    operationType, \r\n    /** How many times this operation has been attempted unsuccessfully. */\r\n    failedAttempts) {\r\n        super(message);\r\n        this.code = code;\r\n        this.message = message;\r\n        this.documentRef = documentRef;\r\n        this.operationType = operationType;\r\n        this.failedAttempts = failedAttempts;\r\n    }\r\n}\r\nexports.BulkWriterError = BulkWriterError;\r\n/**\r\n * A Firestore BulkWriter that can be used to perform a large number of writes\r\n * in parallel.\r\n *\r\n * @class BulkWriter\r\n */\r\nclass BulkWriter {\r\n    // Visible for testing.\r\n    /**\r\n     * @private\r\n     * @internal\r\n     */\r\n    _getBufferedOperationsCount() {\r\n        return this._bufferedOperations.length;\r\n    }\r\n    // Visible for testing.\r\n    /**\r\n     * @private\r\n     * @internal\r\n     */\r\n    _setMaxBatchSize(size) {\r\n        assert(this._bulkCommitBatch.pendingOps.length === 0, 'BulkCommitBatch should be empty');\r\n        this._maxBatchSize = size;\r\n        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, size);\r\n    }\r\n    // Visible for testing.\r\n    /**\r\n     * @private\r\n     * @internal\r\n     */\r\n    _setMaxPendingOpCount(newMax) {\r\n        this._maxPendingOpCount = newMax;\r\n    }\r\n    /** @private */\r\n    constructor(firestore, options) {\r\n        var _a, _b;\r\n        this.firestore = firestore;\r\n        /**\r\n         * The maximum number of writes that can be in a single batch.\r\n         * Visible for testing.\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._maxBatchSize = MAX_BATCH_SIZE;\r\n        /**\r\n         * The batch that is currently used to schedule operations. Once this batch\r\n         * reaches maximum capacity, a new batch is created.\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);\r\n        /**\r\n         * A pointer to the tail of all active BulkWriter operations. This pointer\r\n         * is advanced every time a new write is enqueued.\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._lastOp = Promise.resolve();\r\n        /**\r\n         * Whether this BulkWriter instance has started to close. Afterwards, no\r\n         * new operations can be enqueued, except for retry operations scheduled by\r\n         * the error handler.\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._closing = false;\r\n        /**\r\n         * The number of pending operations enqueued on this BulkWriter instance.\r\n         * An operation is considered pending if BulkWriter has sent it via RPC and\r\n         * is awaiting the result.\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._pendingOpsCount = 0;\r\n        /**\r\n         * An array containing buffered BulkWriter operations after the maximum number\r\n         * of pending operations has been enqueued.\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._bufferedOperations = [];\r\n        /**\r\n         * Whether a custom error handler has been set. BulkWriter only swallows\r\n         * errors if an error handler is set. Otherwise, an UnhandledPromiseRejection\r\n         * is thrown by Node if an operation promise is rejected without being\r\n         * handled.\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._errorHandlerSet = false;\r\n        /**\r\n         * The maximum number of pending operations that can be enqueued onto this\r\n         * BulkWriter instance. Once the this number of writes have been enqueued,\r\n         * subsequent writes are buffered.\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._maxPendingOpCount = DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT;\r\n        /**\r\n         * The user-provided callback to be run every time a BulkWriter operation\r\n         * successfully completes.\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._successFn = () => { };\r\n        /**\r\n         * The user-provided callback to be run every time a BulkWriter operation\r\n         * fails.\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._errorFn = error => {\r\n            const isRetryableDeleteError = error.operationType === 'delete' &&\r\n                error.code === 13 /* StatusCode.INTERNAL */;\r\n            const retryCodes = (0, util_1.getRetryCodes)('batchWrite');\r\n            return ((retryCodes.includes(error.code) || isRetryableDeleteError) &&\r\n                error.failedAttempts < backoff_1.MAX_RETRY_ATTEMPTS);\r\n        };\r\n        this.firestore._incrementBulkWritersCount();\r\n        validateBulkWriterOptions(options);\r\n        if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {\r\n            this._rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\r\n        }\r\n        else {\r\n            let startingRate = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT;\r\n            let maxRate = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT;\r\n            if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {\r\n                if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {\r\n                    maxRate = options.throttling.maxOpsPerSecond;\r\n                }\r\n                if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {\r\n                    startingRate = options.throttling.initialOpsPerSecond;\r\n                }\r\n                // The initial validation step ensures that the maxOpsPerSecond is\r\n                // greater than initialOpsPerSecond. If this inequality is true, that\r\n                // means initialOpsPerSecond was not set and maxOpsPerSecond is less\r\n                // than the default starting rate.\r\n                if (maxRate < startingRate) {\r\n                    startingRate = maxRate;\r\n                }\r\n                // Ensure that the batch size is not larger than the number of allowed\r\n                // operations per second.\r\n                if (startingRate < this._maxBatchSize) {\r\n                    this._maxBatchSize = startingRate;\r\n                }\r\n            }\r\n            this._rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);\r\n        }\r\n    }\r\n    /**\r\n     * Create a document with the provided data. This single operation will fail\r\n     * if a document exists at its location.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * created.\r\n     * @param {T} data The object to serialize as the document.\r\n     * @throws {Error} If the provided input is not a valid Firestore document.\r\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n     * the write. If the write fails, the promise is rejected with a\r\n     * [BulkWriterError]{@link BulkWriterError}.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     * let documentRef = firestore.collection('col').doc();\r\n     *\r\n     * bulkWriter\r\n     *  .create(documentRef, {foo: 'bar'})\r\n     *  .then(result => {\r\n     *    console.log('Successfully executed write at: ', result);\r\n     *  })\r\n     *  .catch(err => {\r\n     *    console.log('Write failed with: ', err);\r\n     *  });\r\n     * });\r\n     * ```\r\n     */\r\n    create(documentRef, data) {\r\n        this._verifyNotClosed();\r\n        return this._enqueue(documentRef, 'create', bulkCommitBatch => bulkCommitBatch.create(documentRef, data));\r\n    }\r\n    /**\r\n     * Delete a document from the database.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * deleted.\r\n     * @param {Precondition=} precondition A precondition to enforce for this\r\n     * delete.\r\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n     * document was last updated at lastUpdateTime. Fails the batch if the\r\n     * document doesn't exist or was last updated at a different time.\r\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n     * the delete. If the delete fails, the promise is rejected with a\r\n     * [BulkWriterError]{@link BulkWriterError}.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * bulkWriter\r\n     *  .delete(documentRef)\r\n     *  .then(result => {\r\n     *    console.log('Successfully deleted document');\r\n     *  })\r\n     *  .catch(err => {\r\n     *    console.log('Delete failed with: ', err);\r\n     *  });\r\n     * });\r\n     * ```\r\n     */\r\n    delete(documentRef, precondition) {\r\n        this._verifyNotClosed();\r\n        return this._enqueue(documentRef, 'delete', bulkCommitBatch => bulkCommitBatch.delete(documentRef, precondition));\r\n    }\r\n    /**\r\n     * Write to the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. If the document does not\r\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\r\n     * the provided data can be merged into the existing document.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * set.\r\n     * @param {T} data The object to serialize as the document.\r\n     * @param {SetOptions=} options An object to configure the set behavior.\r\n     * @throws {Error} If the provided input is not a valid Firestore document.\r\n     * @param {boolean=} options.merge - If true, set() merges the values\r\n     * specified in its data argument. Fields omitted from this set() call remain\r\n     * untouched. If your input sets any field to an empty map, all nested fields\r\n     * are overwritten.\r\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\r\n     * only replaces the specified field paths. Any field path that is not\r\n     * specified is ignored and remains untouched. If your input sets any field to\r\n     * an empty map, all nested fields are overwritten.\r\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n     * the write. If the write fails, the promise is rejected with a\r\n     * [BulkWriterError]{@link BulkWriterError}.\r\n     *\r\n     *\r\n     * @example\r\n     * ```\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     * let documentRef = firestore.collection('col').doc();\r\n     *\r\n     * bulkWriter\r\n     *  .set(documentRef, {foo: 'bar'})\r\n     *  .then(result => {\r\n     *    console.log('Successfully executed write at: ', result);\r\n     *  })\r\n     *  .catch(err => {\r\n     *    console.log('Write failed with: ', err);\r\n     *  });\r\n     * });\r\n     * ```\r\n     */\r\n    set(documentRef, data, options) {\r\n        this._verifyNotClosed();\r\n        return this._enqueue(documentRef, 'set', bulkCommitBatch => {\r\n            if (options) {\r\n                return bulkCommitBatch.set(documentRef, data, options);\r\n            }\r\n            else {\r\n                return bulkCommitBatch.set(documentRef, data);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Update fields of the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\r\n     * exist, the update fails and the entire batch will be rejected.\r\n     *\r\n     * The update() method accepts either an object with field paths encoded as\r\n     * keys and field values encoded as values, or a variable number of arguments\r\n     * that alternate between field paths and field values. Nested fields can be\r\n     * updated by providing dot-separated field path strings or by providing\r\n     * FieldPath objects.\r\n     *\r\n     *\r\n     * A Precondition restricting this update can be specified as the last\r\n     * argument.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * updated.\r\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\r\n     * fields and values with which to update the document or the path of the\r\n     * first field to update.\r\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\r\n     * alternating list of field paths and values to update or a Precondition to\r\n     * restrict this update\r\n     * @throws {Error} If the provided input is not valid Firestore data.\r\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n     * the write. If the write fails, the promise is rejected with a\r\n     * [BulkWriterError]{@link BulkWriterError}.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * bulkWriter\r\n     *  .update(documentRef, {foo: 'bar'})\r\n     *  .then(result => {\r\n     *    console.log('Successfully executed write at: ', result);\r\n     *  })\r\n     *  .catch(err => {\r\n     *    console.log('Write failed with: ', err);\r\n     *  });\r\n     * });\r\n     * ```\r\n     */\r\n    update(documentRef, dataOrField, ...preconditionOrValues) {\r\n        this._verifyNotClosed();\r\n        return this._enqueue(documentRef, 'update', bulkCommitBatch => bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues));\r\n    }\r\n    /**\r\n     * Callback function set by {@link BulkWriter#onWriteResult} that is run\r\n     * every time a {@link BulkWriter} operation successfully completes.\r\n     *\r\n     * @callback BulkWriter~successCallback\r\n     * @param {DocumentReference} documentRef The document reference the\r\n     * operation was performed on\r\n     * @param {WriteResult} result The server write time of the operation.\r\n     */\r\n    /**\r\n     * Attaches a listener that is run every time a BulkWriter operation\r\n     * successfully completes.\r\n     *\r\n     * @param {BulkWriter~successCallback} successCallback A callback to be\r\n     * called every time a BulkWriter operation successfully completes.\r\n     * @example\r\n     * ```\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     *\r\n     * bulkWriter\r\n     *   .onWriteResult((documentRef, result) => {\r\n     *     console.log(\r\n     *       'Successfully executed write on document: ',\r\n     *       documentRef,\r\n     *       ' at: ',\r\n     *       result\r\n     *     );\r\n     *   });\r\n     * ```\r\n     */\r\n    onWriteResult(successCallback) {\r\n        this._successFn = successCallback;\r\n    }\r\n    /**\r\n     * Callback function set by {@link BulkWriter#onWriteError} that is run when\r\n     * a write fails in order to determine whether {@link BulkWriter} should\r\n     * retry the operation.\r\n     *\r\n     * @callback BulkWriter~shouldRetryCallback\r\n     * @param {BulkWriterError} error The error object with information about the\r\n     * operation and error.\r\n     * @returns {boolean} Whether or not to retry the failed operation. Returning\r\n     * `true` retries the operation. Returning `false` will stop the retry loop.\r\n     */\r\n    /**\r\n     * Attaches an error handler listener that is run every time a BulkWriter\r\n     * operation fails.\r\n     *\r\n     * BulkWriter has a default error handler that retries UNAVAILABLE and\r\n     * ABORTED errors up to a maximum of 10 failed attempts. When an error\r\n     * handler is specified, the default error handler will be overwritten.\r\n     *\r\n     * @param shouldRetryCallback {BulkWriter~shouldRetryCallback} A callback to\r\n     * be called every time a BulkWriter operation fails. Returning `true` will\r\n     * retry the operation. Returning `false` will stop the retry loop.\r\n     * @example\r\n     * ```\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     *\r\n     * bulkWriter\r\n     *   .onWriteError((error) => {\r\n     *     if (\r\n     *       error.code === GrpcStatus.UNAVAILABLE &&\r\n     *       error.failedAttempts < MAX_RETRY_ATTEMPTS\r\n     *     ) {\r\n     *       return true;\r\n     *     } else {\r\n     *       console.log('Failed write at document: ', error.documentRef);\r\n     *       return false;\r\n     *     }\r\n     *   });\r\n     * ```\r\n     */\r\n    onWriteError(shouldRetryCallback) {\r\n        this._errorHandlerSet = true;\r\n        this._errorFn = shouldRetryCallback;\r\n    }\r\n    /**\r\n     * Commits all writes that have been enqueued up to this point in parallel.\r\n     *\r\n     * Returns a Promise that resolves when all currently queued operations have\r\n     * been committed. The Promise will never be rejected since the results for\r\n     * each individual operation are conveyed via their individual Promises.\r\n     *\r\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\r\n     * the Promise waits for all previously issued writes, but it does not wait\r\n     * for writes that were added after the method is called. If you want to wait\r\n     * for additional writes, call `flush()` again.\r\n     *\r\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\r\n     * up to this point have been committed.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     *\r\n     * bulkWriter.create(documentRef, {foo: 'bar'});\r\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\r\n     * bulkWriter.delete(documentRef3);\r\n     * await flush().then(() => {\r\n     *   console.log('Executed all writes');\r\n     * });\r\n     * ```\r\n     */\r\n    flush() {\r\n        this._verifyNotClosed();\r\n        this._scheduleCurrentBatch(/* flush= */ true);\r\n        // Mark the most recent operation as flushed to ensure that the batch\r\n        // containing it will be sent once it's popped from the buffer.\r\n        if (this._bufferedOperations.length > 0) {\r\n            this._bufferedOperations[this._bufferedOperations.length - 1].operation.markFlushed();\r\n        }\r\n        return this._lastOp;\r\n    }\r\n    /**\r\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\r\n     *\r\n     * After calling `close()`, calling any method will throw an error. Any\r\n     * retries scheduled as part of an `onWriteError()` handler will be run\r\n     * before the `close()` promise resolves.\r\n     *\r\n     * Returns a Promise that resolves when there are no more pending writes. The\r\n     * Promise will never be rejected. Calling this method will send all requests.\r\n     * The promise resolves immediately if there are no pending writes.\r\n     *\r\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\r\n     * up to this point have been committed.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     *\r\n     * bulkWriter.create(documentRef, {foo: 'bar'});\r\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\r\n     * bulkWriter.delete(documentRef3);\r\n     * await close().then(() => {\r\n     *   console.log('Executed all writes');\r\n     * });\r\n     * ```\r\n     */\r\n    close() {\r\n        this._verifyNotClosed();\r\n        this.firestore._decrementBulkWritersCount();\r\n        const flushPromise = this.flush();\r\n        this._closing = true;\r\n        return flushPromise;\r\n    }\r\n    /**\r\n     * Throws an error if the BulkWriter instance has been closed.\r\n     * @private\r\n     * @internal\r\n     */\r\n    _verifyNotClosed() {\r\n        if (this._closing) {\r\n            throw new Error('BulkWriter has already been closed.');\r\n        }\r\n    }\r\n    /**\r\n     * Sends the current batch and resets `this._bulkCommitBatch`.\r\n     *\r\n     * @param flush If provided, keeps re-sending operations until no more\r\n     * operations are enqueued. This allows retries to resolve as part of a\r\n     * `flush()` or `close()` call.\r\n     * @private\r\n     * @internal\r\n     */\r\n    _scheduleCurrentBatch(flush = false) {\r\n        if (this._bulkCommitBatch._opCount === 0)\r\n            return;\r\n        const pendingBatch = this._bulkCommitBatch;\r\n        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);\r\n        // Use the write with the longest backoff duration when determining backoff.\r\n        const highestBackoffDuration = pendingBatch.pendingOps.reduce((prev, cur) => (prev.backoffDuration > cur.backoffDuration ? prev : cur)).backoffDuration;\r\n        const backoffMsWithJitter = BulkWriter._applyJitter(highestBackoffDuration);\r\n        const delayedExecution = new util_1.Deferred();\r\n        if (backoffMsWithJitter > 0) {\r\n            (0, backoff_1.delayExecution)(() => delayedExecution.resolve(), backoffMsWithJitter);\r\n        }\r\n        else {\r\n            delayedExecution.resolve();\r\n        }\r\n        delayedExecution.promise.then(() => this._sendBatch(pendingBatch, flush));\r\n    }\r\n    /**\r\n     * Sends the provided batch once the rate limiter does not require any delay.\r\n     * @private\r\n     * @internal\r\n     */\r\n    async _sendBatch(batch, flush = false) {\r\n        const tag = (0, util_1.requestTag)();\r\n        // Send the batch if it is does not require any delay, or schedule another\r\n        // attempt after the appropriate timeout.\r\n        const underRateLimit = this._rateLimiter.tryMakeRequest(batch._opCount);\r\n        if (underRateLimit) {\r\n            await batch.bulkCommit({ requestTag: tag });\r\n            if (flush)\r\n                this._scheduleCurrentBatch(flush);\r\n        }\r\n        else {\r\n            const delayMs = this._rateLimiter.getNextRequestDelayMs(batch._opCount);\r\n            (0, logger_1.logger)('BulkWriter._sendBatch', tag, `Backing off for ${delayMs} seconds`);\r\n            (0, backoff_1.delayExecution)(() => this._sendBatch(batch, flush), delayMs);\r\n        }\r\n    }\r\n    /**\r\n     * Adds a 30% jitter to the provided backoff.\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\r\n    static _applyJitter(backoffMs) {\r\n        if (backoffMs === 0)\r\n            return 0;\r\n        // Random value in [-0.3, 0.3].\r\n        const jitter = exports.DEFAULT_JITTER_FACTOR * (Math.random() * 2 - 1);\r\n        return Math.min(backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS, backoffMs + jitter * backoffMs);\r\n    }\r\n    /**\r\n     * Schedules and runs the provided operation on the next available batch.\r\n     * @private\r\n     * @internal\r\n     */\r\n    _enqueue(ref, type, enqueueOnBatchCallback) {\r\n        const bulkWriterOp = new BulkWriterOperation(ref, type, this._sendFn.bind(this, enqueueOnBatchCallback), this._errorFn.bind(this), this._successFn.bind(this));\r\n        // Swallow the error if the developer has set an error listener. This\r\n        // prevents UnhandledPromiseRejections from being thrown if a floating\r\n        // BulkWriter operation promise fails when an error handler is specified.\r\n        //\r\n        // This is done here in order to chain the caught promise onto `lastOp`,\r\n        // which ensures that flush() resolves after the operation promise.\r\n        const userPromise = bulkWriterOp.promise.catch(err => {\r\n            if (!this._errorHandlerSet) {\r\n                throw err;\r\n            }\r\n            else {\r\n                return bulkWriterOp.promise;\r\n            }\r\n        });\r\n        // Advance the `_lastOp` pointer. This ensures that `_lastOp` only resolves\r\n        // when both the previous and the current write resolve.\r\n        this._lastOp = this._lastOp.then(() => (0, util_1.silencePromise)(userPromise));\r\n        // Schedule the operation if the BulkWriter has fewer than the maximum\r\n        // number of allowed pending operations, or add the operation to the\r\n        // buffer.\r\n        if (this._pendingOpsCount < this._maxPendingOpCount) {\r\n            this._pendingOpsCount++;\r\n            this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\r\n        }\r\n        else {\r\n            this._bufferedOperations.push(new BufferedOperation(bulkWriterOp, () => {\r\n                this._pendingOpsCount++;\r\n                this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\r\n            }));\r\n        }\r\n        // Chain the BulkWriter operation promise with the buffer processing logic\r\n        // in order to ensure that it runs and that subsequent operations are\r\n        // enqueued before the next batch is scheduled in `_sendBatch()`.\r\n        return userPromise\r\n            .then(res => {\r\n            this._pendingOpsCount--;\r\n            this._processBufferedOps();\r\n            return res;\r\n        })\r\n            .catch(err => {\r\n            this._pendingOpsCount--;\r\n            this._processBufferedOps();\r\n            throw err;\r\n        });\r\n    }\r\n    /**\r\n     * Manages the pending operation counter and schedules the next BulkWriter\r\n     * operation if we're under the maximum limit.\r\n     * @private\r\n     * @internal\r\n     */\r\n    _processBufferedOps() {\r\n        if (this._pendingOpsCount < this._maxPendingOpCount &&\r\n            this._bufferedOperations.length > 0) {\r\n            const nextOp = this._bufferedOperations.shift();\r\n            nextOp.sendFn();\r\n        }\r\n    }\r\n    /**\r\n     * Schedules the provided operations on current BulkCommitBatch.\r\n     * Sends the BulkCommitBatch if it reaches maximum capacity.\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\r\n    _sendFn(enqueueOnBatchCallback, op) {\r\n        // A backoff duration greater than 0 implies that this batch is a retry.\r\n        // Retried writes are sent with a batch size of 10 in order to guarantee\r\n        // that the batch is under the 10MiB limit.\r\n        if (op.backoffDuration > 0) {\r\n            if (this._bulkCommitBatch.pendingOps.length >= exports.RETRY_MAX_BATCH_SIZE) {\r\n                this._scheduleCurrentBatch(/* flush= */ false);\r\n            }\r\n            this._bulkCommitBatch.setMaxBatchSize(exports.RETRY_MAX_BATCH_SIZE);\r\n        }\r\n        if (this._bulkCommitBatch.has(op.ref)) {\r\n            // Create a new batch since the backend doesn't support batches with two\r\n            // writes to the same document.\r\n            this._scheduleCurrentBatch();\r\n        }\r\n        enqueueOnBatchCallback(this._bulkCommitBatch);\r\n        this._bulkCommitBatch.processLastOperation(op);\r\n        if (this._bulkCommitBatch._opCount === this._bulkCommitBatch.maxBatchSize) {\r\n            this._scheduleCurrentBatch();\r\n        }\r\n        else if (op.flushed) {\r\n            // If flush() was called before this operation was enqueued into a batch,\r\n            // we still need to schedule it.\r\n            this._scheduleCurrentBatch(/* flush= */ true);\r\n        }\r\n    }\r\n}\r\nexports.BulkWriter = BulkWriter;\r\n/**\r\n * Validates the use of 'value' as BulkWriterOptions.\r\n *\r\n * @private\r\n * @internal\r\n * @param value The BulkWriterOptions object to validate.\r\n * @throws if the input is not a valid BulkWriterOptions object.\r\n */\r\nfunction validateBulkWriterOptions(value) {\r\n    if ((0, validate_1.validateOptional)(value, { optional: true })) {\r\n        return;\r\n    }\r\n    const argName = 'options';\r\n    if (!(0, util_1.isObject)(value)) {\r\n        throw new Error(`${(0, validate_1.invalidArgumentMessage)(argName, 'bulkWriter() options argument')} Input is not an object.`);\r\n    }\r\n    const options = value;\r\n    if (options.throttling === undefined ||\r\n        typeof options.throttling === 'boolean') {\r\n        return;\r\n    }\r\n    if (options.throttling.initialOpsPerSecond !== undefined) {\r\n        (0, validate_1.validateInteger)('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {\r\n            minValue: 1,\r\n        });\r\n    }\r\n    if (options.throttling.maxOpsPerSecond !== undefined) {\r\n        (0, validate_1.validateInteger)('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {\r\n            minValue: 1,\r\n        });\r\n        if (options.throttling.initialOpsPerSecond !== undefined &&\r\n            options.throttling.initialOpsPerSecond >\r\n                options.throttling.maxOpsPerSecond) {\r\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(argName, 'bulkWriter() options argument')} \"maxOpsPerSecond\" cannot be less than \"initialOpsPerSecond\".`);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=bulk-writer.js.map"],"mappings":"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;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,MAAMA,CAACxE,WAAW,EAAEyE,IAAI,EAAE;IACtB,IAAI,CAACC,gBAAgB,CAAC,CAAC;IACvB,OAAO,IAAI,CAACC,QAAQ,CAAC3E,WAAW,EAAE,QAAQ,EAAE4E,eAAe,IAAIA,eAAe,CAACJ,MAAM,CAACxE,WAAW,EAAEyE,IAAI,CAAC,CAAC;EAC7G;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,MAAMA,CAAC7E,WAAW,EAAE8E,YAAY,EAAE;IAC9B,IAAI,CAACJ,gBAAgB,CAAC,CAAC;IACvB,OAAO,IAAI,CAACC,QAAQ,CAAC3E,WAAW,EAAE,QAAQ,EAAE4E,eAAe,IAAIA,eAAe,CAACC,MAAM,CAAC7E,WAAW,EAAE8E,YAAY,CAAC,CAAC;EACrH;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,GAAGA,CAAC/E,WAAW,EAAEyE,IAAI,EAAEvE,OAAO,EAAE;IAC5B,IAAI,CAACwE,gBAAgB,CAAC,CAAC;IACvB,OAAO,IAAI,CAACC,QAAQ,CAAC3E,WAAW,EAAE,KAAK,EAAE4E,eAAe,IAAI;MACxD,IAAI1E,OAAO,EAAE;QACT,OAAO0E,eAAe,CAACG,GAAG,CAAC/E,WAAW,EAAEyE,IAAI,EAAEvE,OAAO,CAAC;MAC1D,CAAC,MACI;QACD,OAAO0E,eAAe,CAACG,GAAG,CAAC/E,WAAW,EAAEyE,IAAI,CAAC;MACjD;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,MAAMA,CAAChF,WAAW,EAAEiF,WAAW,EAAE,GAAGC,oBAAoB,EAAE;IACtD,IAAI,CAACR,gBAAgB,CAAC,CAAC;IACvB,OAAO,IAAI,CAACC,QAAQ,CAAC3E,WAAW,EAAE,QAAQ,EAAE4E,eAAe,IAAIA,eAAe,CAACI,MAAM,CAAChF,WAAW,EAAEiF,WAAW,EAAE,GAAGC,oBAAoB,CAAC,CAAC;EAC7I;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAaA,CAACC,eAAe,EAAE;IAC3B,IAAI,CAAC5B,UAAU,GAAG4B,eAAe;EACrC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAYA,CAACC,mBAAmB,EAAE;IAC9B,IAAI,CAAC/B,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACE,QAAQ,GAAG6B,mBAAmB;EACvC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACb,gBAAgB,CAAC,CAA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}