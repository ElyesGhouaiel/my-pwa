{"ast":null,"code":"/**\r\n * Cipher base API.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r\n */\nvar forge = require('./forge');\nrequire('./util');\nmodule.exports = forge.cipher = forge.cipher || {};\n\n// registered algorithms\nforge.cipher.algorithms = forge.cipher.algorithms || {};\n\n/**\r\n * Creates a cipher object that can be used to encrypt data using the given\r\n * algorithm and key. The algorithm may be provided as a string value for a\r\n * previously registered algorithm or it may be given as a cipher algorithm\r\n * API object.\r\n *\r\n * @param algorithm the algorithm to use, either a string or an algorithm API\r\n *          object.\r\n * @param key the key to use, as a binary-encoded string of bytes or a\r\n *          byte buffer.\r\n *\r\n * @return the cipher.\r\n */\nforge.cipher.createCipher = function (algorithm, key) {\n  var api = algorithm;\n  if (typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n    if (api) {\n      api = api();\n    }\n  }\n  if (!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  }\n\n  // assume block cipher\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: false\n  });\n};\n\n/**\r\n * Creates a decipher object that can be used to decrypt data using the given\r\n * algorithm and key. The algorithm may be provided as a string value for a\r\n * previously registered algorithm or it may be given as a cipher algorithm\r\n * API object.\r\n *\r\n * @param algorithm the algorithm to use, either a string or an algorithm API\r\n *          object.\r\n * @param key the key to use, as a binary-encoded string of bytes or a\r\n *          byte buffer.\r\n *\r\n * @return the cipher.\r\n */\nforge.cipher.createDecipher = function (algorithm, key) {\n  var api = algorithm;\n  if (typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n    if (api) {\n      api = api();\n    }\n  }\n  if (!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  }\n\n  // assume block cipher\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: true\n  });\n};\n\n/**\r\n * Registers an algorithm by name. If the name was already registered, the\r\n * algorithm API object will be overwritten.\r\n *\r\n * @param name the name of the algorithm.\r\n * @param algorithm the algorithm API object.\r\n */\nforge.cipher.registerAlgorithm = function (name, algorithm) {\n  name = name.toUpperCase();\n  forge.cipher.algorithms[name] = algorithm;\n};\n\n/**\r\n * Gets a registered algorithm by name.\r\n *\r\n * @param name the name of the algorithm.\r\n *\r\n * @return the algorithm, if found, null if not.\r\n */\nforge.cipher.getAlgorithm = function (name) {\n  name = name.toUpperCase();\n  if (name in forge.cipher.algorithms) {\n    return forge.cipher.algorithms[name];\n  }\n  return null;\n};\nvar BlockCipher = forge.cipher.BlockCipher = function (options) {\n  this.algorithm = options.algorithm;\n  this.mode = this.algorithm.mode;\n  this.blockSize = this.mode.blockSize;\n  this._finish = false;\n  this._input = null;\n  this.output = null;\n  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\n  this._decrypt = options.decrypt;\n  this.algorithm.initialize(options);\n};\n\n/**\r\n * Starts or restarts the encryption or decryption process, whichever\r\n * was previously configured.\r\n *\r\n * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\r\n * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\r\n * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\r\n * 32-bit integers, then it must be 4 integers long.\r\n *\r\n * Note: an IV is not required or used in ECB mode.\r\n *\r\n * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\r\n * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\r\n * by NIST SP-800-38D but another length may be given.\r\n *\r\n * @param options the options to use:\r\n *          iv the initialization vector to use as a binary-encoded string of\r\n *            bytes, null to reuse the last ciphered block from a previous\r\n *            update() (this \"residue\" method is for legacy support only).\r\n *          additionalData additional authentication data as a binary-encoded\r\n *            string of bytes, for 'GCM' mode, (default: none).\r\n *          tagLength desired length of authentication tag, in bits, for\r\n *            'GCM' mode (0-128, default: 128).\r\n *          tag the authentication tag to check if decrypting, as a\r\n *             binary-encoded string of bytes.\r\n *          output the output the buffer to write to, null to create one.\r\n */\nBlockCipher.prototype.start = function (options) {\n  options = options || {};\n  var opts = {};\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n  opts.decrypt = this._decrypt;\n  this._finish = false;\n  this._input = forge.util.createBuffer();\n  this.output = options.output || forge.util.createBuffer();\n  this.mode.start(opts);\n};\n\n/**\r\n * Updates the next block according to the cipher mode.\r\n *\r\n * @param input the buffer to read from.\r\n */\nBlockCipher.prototype.update = function (input) {\n  if (input) {\n    // input given, so empty it into the input buffer\n    this._input.putBuffer(input);\n  }\n\n  // do cipher operation until it needs more input and not finished\n  while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {}\n\n  // free consumed memory from input buffer\n  this._input.compact();\n};\n\n/**\r\n * Finishes encrypting or decrypting.\r\n *\r\n * @param pad a padding function to use in CBC mode, null for default,\r\n *          signature(blockSize, buffer, decrypt).\r\n *\r\n * @return true if successful, false on error.\r\n */\nBlockCipher.prototype.finish = function (pad) {\n  // backwards-compatibility w/deprecated padding API\n  // Note: will overwrite padding functions even after another start() call\n  if (pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {\n    this.mode.pad = function (input) {\n      return pad(this.blockSize, input, false);\n    };\n    this.mode.unpad = function (output) {\n      return pad(this.blockSize, output, true);\n    };\n  }\n\n  // build options for padding and afterFinish functions\n  var options = {};\n  options.decrypt = this._decrypt;\n\n  // get # of bytes that won't fill a block\n  options.overflow = this._input.length() % this.blockSize;\n  if (!this._decrypt && this.mode.pad) {\n    if (!this.mode.pad(this._input, options)) {\n      return false;\n    }\n  }\n\n  // do final update\n  this._finish = true;\n  this.update();\n  if (this._decrypt && this.mode.unpad) {\n    if (!this.mode.unpad(this.output, options)) {\n      return false;\n    }\n  }\n  if (this.mode.afterFinish) {\n    if (!this.mode.afterFinish(this.output, options)) {\n      return false;\n    }\n  }\n  return true;\n};","map":{"version":3,"names":["forge","require","module","exports","cipher","algorithms","createCipher","algorithm","key","api","getAlgorithm","Error","BlockCipher","decrypt","createDecipher","registerAlgorithm","name","toUpperCase","options","mode","blockSize","_finish","_input","output","_op","encrypt","_decrypt","initialize","prototype","start","opts","util","createBuffer","update","input","putBuffer","call","compact","finish","pad","unpad","overflow","length","afterFinish"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/node-forge/lib/cipher.js"],"sourcesContent":["/**\r\n * Cipher base API.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r\n */\r\nvar forge = require('./forge');\r\nrequire('./util');\r\n\r\nmodule.exports = forge.cipher = forge.cipher || {};\r\n\r\n// registered algorithms\r\nforge.cipher.algorithms = forge.cipher.algorithms || {};\r\n\r\n/**\r\n * Creates a cipher object that can be used to encrypt data using the given\r\n * algorithm and key. The algorithm may be provided as a string value for a\r\n * previously registered algorithm or it may be given as a cipher algorithm\r\n * API object.\r\n *\r\n * @param algorithm the algorithm to use, either a string or an algorithm API\r\n *          object.\r\n * @param key the key to use, as a binary-encoded string of bytes or a\r\n *          byte buffer.\r\n *\r\n * @return the cipher.\r\n */\r\nforge.cipher.createCipher = function(algorithm, key) {\r\n  var api = algorithm;\r\n  if(typeof api === 'string') {\r\n    api = forge.cipher.getAlgorithm(api);\r\n    if(api) {\r\n      api = api();\r\n    }\r\n  }\r\n  if(!api) {\r\n    throw new Error('Unsupported algorithm: ' + algorithm);\r\n  }\r\n\r\n  // assume block cipher\r\n  return new forge.cipher.BlockCipher({\r\n    algorithm: api,\r\n    key: key,\r\n    decrypt: false\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a decipher object that can be used to decrypt data using the given\r\n * algorithm and key. The algorithm may be provided as a string value for a\r\n * previously registered algorithm or it may be given as a cipher algorithm\r\n * API object.\r\n *\r\n * @param algorithm the algorithm to use, either a string or an algorithm API\r\n *          object.\r\n * @param key the key to use, as a binary-encoded string of bytes or a\r\n *          byte buffer.\r\n *\r\n * @return the cipher.\r\n */\r\nforge.cipher.createDecipher = function(algorithm, key) {\r\n  var api = algorithm;\r\n  if(typeof api === 'string') {\r\n    api = forge.cipher.getAlgorithm(api);\r\n    if(api) {\r\n      api = api();\r\n    }\r\n  }\r\n  if(!api) {\r\n    throw new Error('Unsupported algorithm: ' + algorithm);\r\n  }\r\n\r\n  // assume block cipher\r\n  return new forge.cipher.BlockCipher({\r\n    algorithm: api,\r\n    key: key,\r\n    decrypt: true\r\n  });\r\n};\r\n\r\n/**\r\n * Registers an algorithm by name. If the name was already registered, the\r\n * algorithm API object will be overwritten.\r\n *\r\n * @param name the name of the algorithm.\r\n * @param algorithm the algorithm API object.\r\n */\r\nforge.cipher.registerAlgorithm = function(name, algorithm) {\r\n  name = name.toUpperCase();\r\n  forge.cipher.algorithms[name] = algorithm;\r\n};\r\n\r\n/**\r\n * Gets a registered algorithm by name.\r\n *\r\n * @param name the name of the algorithm.\r\n *\r\n * @return the algorithm, if found, null if not.\r\n */\r\nforge.cipher.getAlgorithm = function(name) {\r\n  name = name.toUpperCase();\r\n  if(name in forge.cipher.algorithms) {\r\n    return forge.cipher.algorithms[name];\r\n  }\r\n  return null;\r\n};\r\n\r\nvar BlockCipher = forge.cipher.BlockCipher = function(options) {\r\n  this.algorithm = options.algorithm;\r\n  this.mode = this.algorithm.mode;\r\n  this.blockSize = this.mode.blockSize;\r\n  this._finish = false;\r\n  this._input = null;\r\n  this.output = null;\r\n  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\r\n  this._decrypt = options.decrypt;\r\n  this.algorithm.initialize(options);\r\n};\r\n\r\n/**\r\n * Starts or restarts the encryption or decryption process, whichever\r\n * was previously configured.\r\n *\r\n * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\r\n * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\r\n * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\r\n * 32-bit integers, then it must be 4 integers long.\r\n *\r\n * Note: an IV is not required or used in ECB mode.\r\n *\r\n * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\r\n * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\r\n * by NIST SP-800-38D but another length may be given.\r\n *\r\n * @param options the options to use:\r\n *          iv the initialization vector to use as a binary-encoded string of\r\n *            bytes, null to reuse the last ciphered block from a previous\r\n *            update() (this \"residue\" method is for legacy support only).\r\n *          additionalData additional authentication data as a binary-encoded\r\n *            string of bytes, for 'GCM' mode, (default: none).\r\n *          tagLength desired length of authentication tag, in bits, for\r\n *            'GCM' mode (0-128, default: 128).\r\n *          tag the authentication tag to check if decrypting, as a\r\n *             binary-encoded string of bytes.\r\n *          output the output the buffer to write to, null to create one.\r\n */\r\nBlockCipher.prototype.start = function(options) {\r\n  options = options || {};\r\n  var opts = {};\r\n  for(var key in options) {\r\n    opts[key] = options[key];\r\n  }\r\n  opts.decrypt = this._decrypt;\r\n  this._finish = false;\r\n  this._input = forge.util.createBuffer();\r\n  this.output = options.output || forge.util.createBuffer();\r\n  this.mode.start(opts);\r\n};\r\n\r\n/**\r\n * Updates the next block according to the cipher mode.\r\n *\r\n * @param input the buffer to read from.\r\n */\r\nBlockCipher.prototype.update = function(input) {\r\n  if(input) {\r\n    // input given, so empty it into the input buffer\r\n    this._input.putBuffer(input);\r\n  }\r\n\r\n  // do cipher operation until it needs more input and not finished\r\n  while(!this._op.call(this.mode, this._input, this.output, this._finish) &&\r\n    !this._finish) {}\r\n\r\n  // free consumed memory from input buffer\r\n  this._input.compact();\r\n};\r\n\r\n/**\r\n * Finishes encrypting or decrypting.\r\n *\r\n * @param pad a padding function to use in CBC mode, null for default,\r\n *          signature(blockSize, buffer, decrypt).\r\n *\r\n * @return true if successful, false on error.\r\n */\r\nBlockCipher.prototype.finish = function(pad) {\r\n  // backwards-compatibility w/deprecated padding API\r\n  // Note: will overwrite padding functions even after another start() call\r\n  if(pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {\r\n    this.mode.pad = function(input) {\r\n      return pad(this.blockSize, input, false);\r\n    };\r\n    this.mode.unpad = function(output) {\r\n      return pad(this.blockSize, output, true);\r\n    };\r\n  }\r\n\r\n  // build options for padding and afterFinish functions\r\n  var options = {};\r\n  options.decrypt = this._decrypt;\r\n\r\n  // get # of bytes that won't fill a block\r\n  options.overflow = this._input.length() % this.blockSize;\r\n\r\n  if(!this._decrypt && this.mode.pad) {\r\n    if(!this.mode.pad(this._input, options)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // do final update\r\n  this._finish = true;\r\n  this.update();\r\n\r\n  if(this._decrypt && this.mode.unpad) {\r\n    if(!this.mode.unpad(this.output, options)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if(this.mode.afterFinish) {\r\n    if(!this.mode.afterFinish(this.output, options)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC9BA,OAAO,CAAC,QAAQ,CAAC;AAEjBC,MAAM,CAACC,OAAO,GAAGH,KAAK,CAACI,MAAM,GAAGJ,KAAK,CAACI,MAAM,IAAI,CAAC,CAAC;;AAElD;AACAJ,KAAK,CAACI,MAAM,CAACC,UAAU,GAAGL,KAAK,CAACI,MAAM,CAACC,UAAU,IAAI,CAAC,CAAC;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,KAAK,CAACI,MAAM,CAACE,YAAY,GAAG,UAASC,SAAS,EAAEC,GAAG,EAAE;EACnD,IAAIC,GAAG,GAAGF,SAAS;EACnB,IAAG,OAAOE,GAAG,KAAK,QAAQ,EAAE;IAC1BA,GAAG,GAAGT,KAAK,CAACI,MAAM,CAACM,YAAY,CAACD,GAAG,CAAC;IACpC,IAAGA,GAAG,EAAE;MACNA,GAAG,GAAGA,GAAG,CAAC,CAAC;IACb;EACF;EACA,IAAG,CAACA,GAAG,EAAE;IACP,MAAM,IAAIE,KAAK,CAAC,yBAAyB,GAAGJ,SAAS,CAAC;EACxD;;EAEA;EACA,OAAO,IAAIP,KAAK,CAACI,MAAM,CAACQ,WAAW,CAAC;IAClCL,SAAS,EAAEE,GAAG;IACdD,GAAG,EAAEA,GAAG;IACRK,OAAO,EAAE;EACX,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAb,KAAK,CAACI,MAAM,CAACU,cAAc,GAAG,UAASP,SAAS,EAAEC,GAAG,EAAE;EACrD,IAAIC,GAAG,GAAGF,SAAS;EACnB,IAAG,OAAOE,GAAG,KAAK,QAAQ,EAAE;IAC1BA,GAAG,GAAGT,KAAK,CAACI,MAAM,CAACM,YAAY,CAACD,GAAG,CAAC;IACpC,IAAGA,GAAG,EAAE;MACNA,GAAG,GAAGA,GAAG,CAAC,CAAC;IACb;EACF;EACA,IAAG,CAACA,GAAG,EAAE;IACP,MAAM,IAAIE,KAAK,CAAC,yBAAyB,GAAGJ,SAAS,CAAC;EACxD;;EAEA;EACA,OAAO,IAAIP,KAAK,CAACI,MAAM,CAACQ,WAAW,CAAC;IAClCL,SAAS,EAAEE,GAAG;IACdD,GAAG,EAAEA,GAAG;IACRK,OAAO,EAAE;EACX,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAb,KAAK,CAACI,MAAM,CAACW,iBAAiB,GAAG,UAASC,IAAI,EAAET,SAAS,EAAE;EACzDS,IAAI,GAAGA,IAAI,CAACC,WAAW,CAAC,CAAC;EACzBjB,KAAK,CAACI,MAAM,CAACC,UAAU,CAACW,IAAI,CAAC,GAAGT,SAAS;AAC3C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAP,KAAK,CAACI,MAAM,CAACM,YAAY,GAAG,UAASM,IAAI,EAAE;EACzCA,IAAI,GAAGA,IAAI,CAACC,WAAW,CAAC,CAAC;EACzB,IAAGD,IAAI,IAAIhB,KAAK,CAACI,MAAM,CAACC,UAAU,EAAE;IAClC,OAAOL,KAAK,CAACI,MAAM,CAACC,UAAU,CAACW,IAAI,CAAC;EACtC;EACA,OAAO,IAAI;AACb,CAAC;AAED,IAAIJ,WAAW,GAAGZ,KAAK,CAACI,MAAM,CAACQ,WAAW,GAAG,UAASM,OAAO,EAAE;EAC7D,IAAI,CAACX,SAAS,GAAGW,OAAO,CAACX,SAAS;EAClC,IAAI,CAACY,IAAI,GAAG,IAAI,CAACZ,SAAS,CAACY,IAAI;EAC/B,IAAI,CAACC,SAAS,GAAG,IAAI,CAACD,IAAI,CAACC,SAAS;EACpC,IAAI,CAACC,OAAO,GAAG,KAAK;EACpB,IAAI,CAACC,MAAM,GAAG,IAAI;EAClB,IAAI,CAACC,MAAM,GAAG,IAAI;EAClB,IAAI,CAACC,GAAG,GAAGN,OAAO,CAACL,OAAO,GAAG,IAAI,CAACM,IAAI,CAACN,OAAO,GAAG,IAAI,CAACM,IAAI,CAACM,OAAO;EAClE,IAAI,CAACC,QAAQ,GAAGR,OAAO,CAACL,OAAO;EAC/B,IAAI,CAACN,SAAS,CAACoB,UAAU,CAACT,OAAO,CAAC;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAN,WAAW,CAACgB,SAAS,CAACC,KAAK,GAAG,UAASX,OAAO,EAAE;EAC9CA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAIY,IAAI,GAAG,CAAC,CAAC;EACb,KAAI,IAAItB,GAAG,IAAIU,OAAO,EAAE;IACtBY,IAAI,CAACtB,GAAG,CAAC,GAAGU,OAAO,CAACV,GAAG,CAAC;EAC1B;EACAsB,IAAI,CAACjB,OAAO,GAAG,IAAI,CAACa,QAAQ;EAC5B,IAAI,CAACL,OAAO,GAAG,KAAK;EACpB,IAAI,CAACC,MAAM,GAAGtB,KAAK,CAAC+B,IAAI,CAACC,YAAY,CAAC,CAAC;EACvC,IAAI,CAACT,MAAM,GAAGL,OAAO,CAACK,MAAM,IAAIvB,KAAK,CAAC+B,IAAI,CAACC,YAAY,CAAC,CAAC;EACzD,IAAI,CAACb,IAAI,CAACU,KAAK,CAACC,IAAI,CAAC;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAlB,WAAW,CAACgB,SAAS,CAACK,MAAM,GAAG,UAASC,KAAK,EAAE;EAC7C,IAAGA,KAAK,EAAE;IACR;IACA,IAAI,CAACZ,MAAM,CAACa,SAAS,CAACD,KAAK,CAAC;EAC9B;;EAEA;EACA,OAAM,CAAC,IAAI,CAACV,GAAG,CAACY,IAAI,CAAC,IAAI,CAACjB,IAAI,EAAE,IAAI,CAACG,MAAM,EAAE,IAAI,CAACC,MAAM,EAAE,IAAI,CAACF,OAAO,CAAC,IACrE,CAAC,IAAI,CAACA,OAAO,EAAE,CAAC;;EAElB;EACA,IAAI,CAACC,MAAM,CAACe,OAAO,CAAC,CAAC;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzB,WAAW,CAACgB,SAAS,CAACU,MAAM,GAAG,UAASC,GAAG,EAAE;EAC3C;EACA;EACA,IAAGA,GAAG,KAAK,IAAI,CAACpB,IAAI,CAACH,IAAI,KAAK,KAAK,IAAI,IAAI,CAACG,IAAI,CAACH,IAAI,KAAK,KAAK,CAAC,EAAE;IAChE,IAAI,CAACG,IAAI,CAACoB,GAAG,GAAG,UAASL,KAAK,EAAE;MAC9B,OAAOK,GAAG,CAAC,IAAI,CAACnB,SAAS,EAAEc,KAAK,EAAE,KAAK,CAAC;IAC1C,CAAC;IACD,IAAI,CAACf,IAAI,CAACqB,KAAK,GAAG,UAASjB,MAAM,EAAE;MACjC,OAAOgB,GAAG,CAAC,IAAI,CAACnB,SAAS,EAAEG,MAAM,EAAE,IAAI,CAAC;IAC1C,CAAC;EACH;;EAEA;EACA,IAAIL,OAAO,GAAG,CAAC,CAAC;EAChBA,OAAO,CAACL,OAAO,GAAG,IAAI,CAACa,QAAQ;;EAE/B;EACAR,OAAO,CAACuB,QAAQ,GAAG,IAAI,CAACnB,MAAM,CAACoB,MAAM,CAAC,CAAC,GAAG,IAAI,CAACtB,SAAS;EAExD,IAAG,CAAC,IAAI,CAACM,QAAQ,IAAI,IAAI,CAACP,IAAI,CAACoB,GAAG,EAAE;IAClC,IAAG,CAAC,IAAI,CAACpB,IAAI,CAACoB,GAAG,CAAC,IAAI,CAACjB,MAAM,EAAEJ,OAAO,CAAC,EAAE;MACvC,OAAO,KAAK;IACd;EACF;;EAEA;EACA,IAAI,CAACG,OAAO,GAAG,IAAI;EACnB,IAAI,CAACY,MAAM,CAAC,CAAC;EAEb,IAAG,IAAI,CAACP,QAAQ,IAAI,IAAI,CAACP,IAAI,CAACqB,KAAK,EAAE;IACnC,IAAG,CAAC,IAAI,CAACrB,IAAI,CAACqB,KAAK,CAAC,IAAI,CAACjB,MAAM,EAAEL,OAAO,CAAC,EAAE;MACzC,OAAO,KAAK;IACd;EACF;EAEA,IAAG,IAAI,CAACC,IAAI,CAACwB,WAAW,EAAE;IACxB,IAAG,CAAC,IAAI,CAACxB,IAAI,CAACwB,WAAW,CAAC,IAAI,CAACpB,MAAM,EAAEL,OAAO,CAAC,EAAE;MAC/C,OAAO,KAAK;IACd;EACF;EAEA,OAAO,IAAI;AACb,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}