{"ast":null,"code":"\"use strict\";\n\n/*!\r\n * Copyright 2017 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transaction = void 0;\nexports.parseGetAllArguments = parseGetAllArguments;\nconst backoff_1 = require(\"./backoff\");\nconst index_1 = require(\"./index\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst aggregate_query_1 = require(\"./reference/aggregate-query\");\nconst document_reference_1 = require(\"./reference/document-reference\");\nconst query_1 = require(\"./reference/query\");\nconst helpers_1 = require(\"./reference/helpers\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst document_reader_1 = require(\"./document-reader\");\nconst trace_util_1 = require(\"./telemetry/trace-util\");\n/*!\r\n * Error message for transactional reads that were executed after performing\r\n * writes.\r\n */\nconst READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\nconst READ_ONLY_WRITE_ERROR_MSG = 'Firestore read-only transactions cannot execute writes.';\n/**\r\n * A reference to a transaction.\r\n *\r\n * The Transaction object passed to a transaction's updateFunction provides\r\n * the methods to read and write data within the transaction context. See\r\n * [runTransaction()]{@link Firestore#runTransaction}.\r\n *\r\n * @class Transaction\r\n */\nclass Transaction {\n  /**\r\n   * @private\r\n   *\r\n   * @param firestore The Firestore Database client.\r\n   * @param requestTag A unique client-assigned identifier for the scope of\r\n   * this transaction.\r\n   * @param transactionOptions The user-defined options for this transaction.\r\n   */\n  constructor(firestore, requestTag, transactionOptions) {\n    this._maxAttempts = index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;\n    this._firestore = firestore;\n    this._requestTag = requestTag;\n    if (transactionOptions === null || transactionOptions === void 0 ? void 0 : transactionOptions.readOnly) {\n      // Avoid initialising write batch and backoff unnecessarily for read-only transactions\n      this._maxAttempts = 1;\n      this._readOnlyReadTime = transactionOptions.readTime;\n    } else {\n      this._maxAttempts = (transactionOptions === null || transactionOptions === void 0 ? void 0 : transactionOptions.maxAttempts) || index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;\n      this._writeBatch = firestore.batch();\n      this._backoff = new backoff_1.ExponentialBackoff();\n    }\n  }\n  /**\r\n   * Retrieve a document or a query result from the database. Holds a\r\n   * pessimistic lock on all returned documents.\r\n   *\r\n   * @param {DocumentReference|Query} refOrQuery The document or query to\r\n   * return.\r\n   * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\r\n   * QuerySnapshot for the returned documents.\r\n   *\r\n   * @example\r\n   * ```\r\n   * firestore.runTransaction(transaction => {\r\n   *   let documentRef = firestore.doc('col/doc');\r\n   *   return transaction.get(documentRef).then(doc => {\r\n   *     if (doc.exists) {\r\n   *       transaction.update(documentRef, { count: doc.get('count') + 1 });\r\n   *     } else {\r\n   *       transaction.create(documentRef, { count: 1 });\r\n   *     }\r\n   *   });\r\n   * });\r\n   * ```\r\n   */\n  get(refOrQuery) {\n    if (this._writeBatch && !this._writeBatch.isEmpty) {\n      throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n    }\n    if (refOrQuery instanceof document_reference_1.DocumentReference) {\n      return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_GET_DOCUMENT, () => {\n        return this.withLazyStartedTransaction(refOrQuery, this.getSingleFn);\n      });\n    }\n    if (refOrQuery instanceof query_1.Query || refOrQuery instanceof aggregate_query_1.AggregateQuery) {\n      return this._firestore._traceUtil.startActiveSpan(refOrQuery instanceof query_1.Query ? trace_util_1.SPAN_NAME_TRANSACTION_GET_QUERY : trace_util_1.SPAN_NAME_TRANSACTION_GET_AGGREGATION_QUERY, () => {\n        return this.withLazyStartedTransaction(refOrQuery, this.getQueryFn);\n      });\n    }\n    throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference, Query, or AggregateQuery.');\n  }\n  /**\r\n   * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\r\n   * all returned documents.\r\n   *\r\n   * The first argument is required and must be of type `DocumentReference`\r\n   * followed by any additional `DocumentReference` documents. If used, the\r\n   * optional `ReadOptions` must be the last argument.\r\n   *\r\n   * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\r\n   * `DocumentReferences` to receive, followed by an optional field mask.\r\n   * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\r\n   * contains an array with the resulting document snapshots.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let firstDoc = firestore.doc('col/doc1');\r\n   * let secondDoc = firestore.doc('col/doc2');\r\n   * let resultDoc = firestore.doc('col/doc3');\r\n   *\r\n   * firestore.runTransaction(transaction => {\r\n   *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\r\n   *     transaction.set(resultDoc, {\r\n   *       sum: docs[0].get('count') + docs[1].get('count')\r\n   *     });\r\n   *   });\r\n   * });\r\n   * ```\r\n   */\n  getAll(...documentRefsOrReadOptions) {\n    if (this._writeBatch && !this._writeBatch.isEmpty) {\n      throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n    }\n    (0, validate_1.validateMinNumberOfArguments)('Transaction.getAll', documentRefsOrReadOptions, 1);\n    return this.withLazyStartedTransaction(parseGetAllArguments(documentRefsOrReadOptions), this.getBatchFn);\n  }\n  /**\r\n   * Create the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. The operation will\r\n   * fail the transaction if a document exists at the specified location.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * created.\r\n   * @param {DocumentData} data The object data to serialize as the document.\r\n   * @returns {Transaction} This Transaction instance. Used for\r\n   * chaining method calls.\r\n   *\r\n   * @example\r\n   * ```\r\n   * firestore.runTransaction(transaction => {\r\n   *   let documentRef = firestore.doc('col/doc');\r\n   *   return transaction.get(documentRef).then(doc => {\r\n   *     if (!doc.exists) {\r\n   *       transaction.create(documentRef, { foo: 'bar' });\r\n   *     }\r\n   *   });\r\n   * });\r\n   * ```\r\n   */\n  create(documentRef, data) {\n    if (!this._writeBatch) {\n      throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n    }\n    this._writeBatch.create(documentRef, data);\n    return this;\n  }\n  /**\r\n   * Writes to the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. If the document\r\n   * does not exist yet, it will be created. If you pass\r\n   * [SetOptions]{@link SetOptions}, the provided data can be merged into the\r\n   * existing document.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * set.\r\n   * @param {T|Partial<T>} data The object to serialize as the document.\r\n   * @param {SetOptions=} options An object to configure the set behavior.\r\n   * @param {boolean=} options.merge - If true, set() merges the values\r\n   * specified in its data argument. Fields omitted from this set() call remain\r\n   * untouched. If your input sets any field to an empty map, all nested fields\r\n   * are overwritten.\r\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\r\n   * set() only replaces the specified field paths. Any field path that is not\r\n   * specified is ignored and remains untouched. If your input sets any field to\r\n   * an empty map, all nested fields are overwritten.\r\n   * @throws {Error} If the provided input is not a valid Firestore document.\r\n   * @returns {Transaction} This Transaction instance. Used for\r\n   * chaining method calls.\r\n   *\r\n   * @example\r\n   * ```\r\n   * firestore.runTransaction(transaction => {\r\n   *   let documentRef = firestore.doc('col/doc');\r\n   *   transaction.set(documentRef, { foo: 'bar' });\r\n   *   return Promise.resolve();\r\n   * });\r\n   * ```\r\n   */\n  set(documentRef, data, options) {\n    if (!this._writeBatch) {\n      throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n    }\n    if (options) {\n      this._writeBatch.set(documentRef, data, options);\n    } else {\n      this._writeBatch.set(documentRef, data);\n    }\n    return this;\n  }\n  /**\r\n   * Updates fields in the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. The update will\r\n   * fail if applied to a document that does not exist.\r\n   *\r\n   * The update() method accepts either an object with field paths encoded as\r\n   * keys and field values encoded as values, or a variable number of arguments\r\n   * that alternate between field paths and field values. Nested fields can be\r\n   * updated by providing dot-separated field path strings or by providing\r\n   * FieldPath objects.\r\n   *\r\n   * A Precondition restricting this update can be specified as the last\r\n   * argument.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * updated.\r\n   * @param {UpdateData|string|FieldPath} dataOrField An object\r\n   * containing the fields and values with which to update the document\r\n   * or the path of the first field to update.\r\n   * @param {\r\n   * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\r\n   * An alternating list of field paths and values to update or a Precondition\r\n   * to to enforce on this update.\r\n   * @throws {Error} If the provided input is not valid Firestore data.\r\n   * @returns {Transaction} This Transaction instance. Used for\r\n   * chaining method calls.\r\n   *\r\n   * @example\r\n   * ```\r\n   * firestore.runTransaction(transaction => {\r\n   *   let documentRef = firestore.doc('col/doc');\r\n   *   return transaction.get(documentRef).then(doc => {\r\n   *     if (doc.exists) {\r\n   *       transaction.update(documentRef, { count: doc.get('count') + 1 });\r\n   *     } else {\r\n   *       transaction.create(documentRef, { count: 1 });\r\n   *     }\r\n   *   });\r\n   * });\r\n   * ```\r\n   */\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    if (!this._writeBatch) {\n      throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n    }\n    // eslint-disable-next-line prefer-rest-params\n    (0, validate_1.validateMinNumberOfArguments)('Transaction.update', arguments, 2);\n    this._writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n    return this;\n  }\n  /**\r\n   * Deletes the document referred to by the provided [DocumentReference]\r\n   * {@link DocumentReference}.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * deleted.\r\n   * @param {Precondition=} precondition A precondition to enforce for this\r\n   * delete.\r\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n   * document was last updated at lastUpdateTime. Fails the transaction if the\r\n   * document doesn't exist or was last updated at a different time.\r\n   * @param {boolean=} precondition.exists If set, enforces that the target\r\n   * document must or must not exist.\r\n   * @returns {Transaction} This Transaction instance. Used for\r\n   * chaining method calls.\r\n   *\r\n   * @example\r\n   * ```\r\n   * firestore.runTransaction(transaction => {\r\n   *   let documentRef = firestore.doc('col/doc');\r\n   *   transaction.delete(documentRef);\r\n   *   return Promise.resolve();\r\n   * });\r\n   * ```\r\n   */\n  delete(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  documentRef, precondition) {\n    if (!this._writeBatch) {\n      throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n    }\n    this._writeBatch.delete(documentRef, precondition);\n    return this;\n  }\n  /**\r\n   * Commits all queued-up changes in this transaction and releases all locks.\r\n   *\r\n   * @private\r\n   * @internal\r\n   */\n  async commit() {\n    var _a;\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_COMMIT, async () => {\n      if (!this._writeBatch) {\n        throw new Error(READ_ONLY_WRITE_ERROR_MSG);\n      }\n      // If we have not performed any reads in this particular attempt\n      // then the writes will be atomically committed without a transaction ID\n      let transactionId;\n      if (this._transactionIdPromise) {\n        transactionId = await this._transactionIdPromise;\n      } else if (this._writeBatch.isEmpty) {\n        // If we have not started a transaction (no reads) and we have no writes\n        // then the commit is a no-op (success)\n        return;\n      }\n      await this._writeBatch._commit({\n        transactionId,\n        requestTag: this._requestTag\n      });\n      this._transactionIdPromise = undefined;\n      this._prevTransactionId = transactionId;\n    }, {\n      [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: true,\n      [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: (_a = this._writeBatch) === null || _a === void 0 ? void 0 : _a._opCount\n    });\n  }\n  /**\r\n   * Releases all locks and rolls back this transaction. The rollback process\r\n   * is completed asynchronously and this function resolves before the operation\r\n   * is completed.\r\n   *\r\n   * @private\r\n   * @internal\r\n   */\n  async rollback() {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_ROLLBACK, async () => {\n      // No need to roll back if we have not lazily started the transaction\n      // or if we are read only\n      if (!this._transactionIdPromise || !this._writeBatch) {\n        return;\n      }\n      let transactionId;\n      try {\n        transactionId = await this._transactionIdPromise;\n      } catch (_a) {\n        // This means the initial read operation rejected\n        // and we do not have a transaction ID to roll back\n        this._transactionIdPromise = undefined;\n        return;\n      }\n      const request = {\n        database: this._firestore.formattedName,\n        transaction: transactionId\n      };\n      this._transactionIdPromise = undefined;\n      this._prevTransactionId = transactionId;\n      // We don't need to wait for rollback to completed before continuing.\n      // If there are any locks held, then rollback will eventually release them.\n      // Rollback can be done concurrently thereby reducing latency caused by\n      // otherwise blocking.\n      this._firestore.request('rollback', request, this._requestTag).catch(err => {\n        (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Best effort to rollback failed with error:', err);\n      });\n    });\n  }\n  /**\r\n   * Executes `updateFunction()` and commits the transaction with retry.\r\n   *\r\n   * @private\r\n   * @internal\r\n   * @param updateFunction The user function to execute within the transaction\r\n   * context.\r\n   */\n  async runTransaction(updateFunction) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_RUN, async span => {\n      // No backoff is set for readonly transactions (i.e. attempts == 1)\n      if (!this._writeBatch) {\n        return this.runTransactionOnce(updateFunction);\n      }\n      let lastError = undefined;\n      for (let attempt = 0; attempt < this._maxAttempts; ++attempt) {\n        span.setAttributes({\n          [trace_util_1.ATTRIBUTE_KEY_TRANSACTION_TYPE]: this._writeBatch ? 'READ_WRITE' : 'READ_ONLY',\n          [trace_util_1.ATTRIBUTE_KEY_ATTEMPTS_ALLOWED]: this._maxAttempts,\n          [trace_util_1.ATTRIBUTE_KEY_ATTEMPTS_REMAINING]: this._maxAttempts - attempt - 1\n        });\n        try {\n          if (lastError) {\n            (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Retrying transaction after error:', lastError);\n            span.addEvent('Initiate transaction retry');\n          }\n          this._writeBatch._reset();\n          await maybeBackoff(this._backoff, lastError);\n          return await this.runTransactionOnce(updateFunction);\n        } catch (err) {\n          lastError = err;\n          if (!isRetryableTransactionError(err)) {\n            break;\n          }\n        }\n      }\n      (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);\n      return Promise.reject(lastError);\n    });\n  }\n  /**\r\n   * Make single attempt to execute `updateFunction()` and commit the\r\n   * transaction. Will rollback upon error.\r\n   *\r\n   * @private\r\n   * @internal\r\n   * @param updateFunction The user function to execute within the transaction\r\n   * context.\r\n   */\n  async runTransactionOnce(updateFunction) {\n    try {\n      const promise = updateFunction(this);\n      if (!(promise instanceof Promise)) {\n        throw new Error('You must return a Promise in your transaction()-callback.');\n      }\n      const result = await promise;\n      if (this._writeBatch) {\n        await this.commit();\n      }\n      return result;\n    } catch (err) {\n      (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', err);\n      await this.rollback();\n      return Promise.reject(err);\n    }\n  }\n  /**\r\n   * Given a function that performs a read operation, ensures that the first one\r\n   * is provided with new transaction options and all subsequent ones are queued\r\n   * upon the resulting transaction ID.\r\n   */\n  withLazyStartedTransaction(param, resultFn) {\n    if (this._transactionIdPromise) {\n      // Simply queue this subsequent read operation after the first read\n      // operation has resolved and we don't expect a transaction ID in the\n      // response because we are not starting a new transaction\n      return this._transactionIdPromise.then(opts => resultFn.call(this, param, opts)).then(r => r.result);\n    } else {\n      if (this._readOnlyReadTime) {\n        // We do not start a transaction for read-only transactions\n        // do not set _prevTransactionId\n        return resultFn.call(this, param, this._readOnlyReadTime).then(r => r.result);\n      } else {\n        // This is the first read of the transaction so we create the appropriate\n        // options for lazily starting the transaction inside this first read op\n        const opts = {};\n        if (this._writeBatch) {\n          opts.readWrite = this._prevTransactionId ? {\n            retryTransaction: this._prevTransactionId\n          } : {};\n        } else {\n          opts.readOnly = {};\n        }\n        const resultPromise = resultFn.call(this, param, opts);\n        // Ensure the _transactionIdPromise is set synchronously so that\n        // subsequent operations will not race to start another transaction\n        this._transactionIdPromise = resultPromise.then(r => {\n          if (!r.transaction) {\n            // Illegal state\n            // The read operation was provided with new transaction options but did not return a transaction ID\n            // Rejecting here will cause all queued reads to reject\n            throw new Error('Transaction ID was missing from server response');\n          }\n          return r.transaction;\n        });\n        return resultPromise.then(r => r.result);\n      }\n    }\n  }\n  async getSingleFn(document, opts) {\n    const documentReader = new document_reader_1.DocumentReader(this._firestore, [document], undefined, opts);\n    const {\n      transaction,\n      result: [result]\n    } = await documentReader._get(this._requestTag);\n    return {\n      transaction,\n      result\n    };\n  }\n  async getBatchFn({\n    documents,\n    fieldMask\n  }, opts) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_GET_DOCUMENTS, async () => {\n      const documentReader = new document_reader_1.DocumentReader(this._firestore, documents, fieldMask, opts);\n      return documentReader._get(this._requestTag);\n    });\n  }\n  async getQueryFn(query, opts) {\n    return query._get(opts);\n  }\n}\nexports.Transaction = Transaction;\n/**\r\n * Parses the arguments for the `getAll()` call supported by both the Firestore\r\n * and Transaction class.\r\n *\r\n * @private\r\n * @internal\r\n * @param documentRefsOrReadOptions An array of document references followed by\r\n * an optional ReadOptions object.\r\n */\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\n  let documents;\n  let readOptions = undefined;\n  if (Array.isArray(documentRefsOrReadOptions[0])) {\n    throw new Error('getAll() no longer accepts an array as its first argument. ' + 'Please unpack your array and call getAll() with individual arguments.');\n  }\n  if (documentRefsOrReadOptions.length > 0 && (0, util_1.isPlainObject)(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\n    readOptions = documentRefsOrReadOptions.pop();\n    documents = documentRefsOrReadOptions;\n  } else {\n    documents = documentRefsOrReadOptions;\n  }\n  for (let i = 0; i < documents.length; ++i) {\n    (0, helpers_1.validateDocumentReference)(i, documents[i]);\n  }\n  validateReadOptions('options', readOptions, {\n    optional: true\n  });\n  const fieldMask = readOptions && readOptions.fieldMask ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath)) : undefined;\n  return {\n    fieldMask,\n    documents\n  };\n}\n/**\r\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\r\n * is an array of strings or field paths.\r\n *\r\n * @private\r\n * @internal\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the ReadOptions can be omitted.\r\n */\nfunction validateReadOptions(arg, value, options) {\n  if (!(0, validate_1.validateOptional)(value, options)) {\n    if (!(0, util_1.isObject)(value)) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} Input is not an object.'`);\n    }\n    const options = value;\n    if (options.fieldMask !== undefined) {\n      if (!Array.isArray(options.fieldMask)) {\n        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} \"fieldMask\" is not an array.`);\n      }\n      for (let i = 0; i < options.fieldMask.length; ++i) {\n        try {\n          (0, path_1.validateFieldPath)(i, options.fieldMask[i]);\n        } catch (err) {\n          throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} \"fieldMask\" is not valid: ${err.message}`);\n        }\n      }\n    }\n  }\n}\nfunction isRetryableTransactionError(error) {\n  if (error.code !== undefined) {\n    // This list is based on https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/transaction_runner.ts#L112\n    switch (error.code) {\n      case 10 /* StatusCode.ABORTED */:\n      case 1 /* StatusCode.CANCELLED */:\n      case 2 /* StatusCode.UNKNOWN */:\n      case 4 /* StatusCode.DEADLINE_EXCEEDED */:\n      case 13 /* StatusCode.INTERNAL */:\n      case 14 /* StatusCode.UNAVAILABLE */:\n      case 16 /* StatusCode.UNAUTHENTICATED */:\n      case 8 /* StatusCode.RESOURCE_EXHAUSTED */:\n        return true;\n      case 3 /* StatusCode.INVALID_ARGUMENT */:\n        // The Firestore backend uses \"INVALID_ARGUMENT\" for transactions\n        // IDs that have expired. While INVALID_ARGUMENT is generally not\n        // retryable, we retry this specific case.\n        return !!error.message.match(/transaction has expired/);\n      default:\n        return false;\n    }\n  }\n  return false;\n}\n/**\r\n * Delays further operations based on the provided error.\r\n *\r\n * @private\r\n * @internal\r\n * @return A Promise that resolves after the delay expired.\r\n */\nasync function maybeBackoff(backoff, error) {\n  if ((error === null || error === void 0 ? void 0 : error.code) === 8 /* StatusCode.RESOURCE_EXHAUSTED */) {\n    backoff.resetToMax();\n  }\n  await backoff.backoffAndWait();\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Transaction","parseGetAllArguments","backoff_1","require","index_1","logger_1","path_1","aggregate_query_1","document_reference_1","query_1","helpers_1","util_1","validate_1","document_reader_1","trace_util_1","READ_AFTER_WRITE_ERROR_MSG","READ_ONLY_WRITE_ERROR_MSG","constructor","firestore","requestTag","transactionOptions","_maxAttempts","DEFAULT_MAX_TRANSACTION_ATTEMPTS","_firestore","_requestTag","readOnly","_readOnlyReadTime","readTime","maxAttempts","_writeBatch","batch","_backoff","ExponentialBackoff","get","refOrQuery","isEmpty","Error","DocumentReference","_traceUtil","startActiveSpan","SPAN_NAME_TRANSACTION_GET_DOCUMENT","withLazyStartedTransaction","getSingleFn","Query","AggregateQuery","SPAN_NAME_TRANSACTION_GET_QUERY","SPAN_NAME_TRANSACTION_GET_AGGREGATION_QUERY","getQueryFn","getAll","documentRefsOrReadOptions","validateMinNumberOfArguments","getBatchFn","create","documentRef","data","set","options","update","dataOrField","preconditionOrValues","arguments","delete","precondition","commit","_a","SPAN_NAME_TRANSACTION_COMMIT","transactionId","_transactionIdPromise","_commit","undefined","_prevTransactionId","ATTRIBUTE_KEY_IS_TRANSACTIONAL","ATTRIBUTE_KEY_DOC_COUNT","_opCount","rollback","SPAN_NAME_TRANSACTION_ROLLBACK","request","database","formattedName","transaction","catch","err","logger","runTransaction","updateFunction","SPAN_NAME_TRANSACTION_RUN","span","runTransactionOnce","lastError","attempt","setAttributes","ATTRIBUTE_KEY_TRANSACTION_TYPE","ATTRIBUTE_KEY_ATTEMPTS_ALLOWED","ATTRIBUTE_KEY_ATTEMPTS_REMAINING","addEvent","_reset","maybeBackoff","isRetryableTransactionError","Promise","reject","promise","result","param","resultFn","then","opts","call","r","readWrite","retryTransaction","resultPromise","document","documentReader","DocumentReader","_get","documents","fieldMask","SPAN_NAME_TRANSACTION_GET_DOCUMENTS","query","readOptions","Array","isArray","length","isPlainObject","pop","i","validateDocumentReference","validateReadOptions","optional","map","fieldPath","FieldPath","fromArgument","arg","validateOptional","isObject","invalidArgumentMessage","validateFieldPath","message","error","code","match","backoff","resetToMax","backoffAndWait"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@google-cloud/firestore/build/src/transaction.js"],"sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2017 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Transaction = void 0;\r\nexports.parseGetAllArguments = parseGetAllArguments;\r\nconst backoff_1 = require(\"./backoff\");\r\nconst index_1 = require(\"./index\");\r\nconst logger_1 = require(\"./logger\");\r\nconst path_1 = require(\"./path\");\r\nconst aggregate_query_1 = require(\"./reference/aggregate-query\");\r\nconst document_reference_1 = require(\"./reference/document-reference\");\r\nconst query_1 = require(\"./reference/query\");\r\nconst helpers_1 = require(\"./reference/helpers\");\r\nconst util_1 = require(\"./util\");\r\nconst validate_1 = require(\"./validate\");\r\nconst document_reader_1 = require(\"./document-reader\");\r\nconst trace_util_1 = require(\"./telemetry/trace-util\");\r\n/*!\r\n * Error message for transactional reads that were executed after performing\r\n * writes.\r\n */\r\nconst READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\r\nconst READ_ONLY_WRITE_ERROR_MSG = 'Firestore read-only transactions cannot execute writes.';\r\n/**\r\n * A reference to a transaction.\r\n *\r\n * The Transaction object passed to a transaction's updateFunction provides\r\n * the methods to read and write data within the transaction context. See\r\n * [runTransaction()]{@link Firestore#runTransaction}.\r\n *\r\n * @class Transaction\r\n */\r\nclass Transaction {\r\n    /**\r\n     * @private\r\n     *\r\n     * @param firestore The Firestore Database client.\r\n     * @param requestTag A unique client-assigned identifier for the scope of\r\n     * this transaction.\r\n     * @param transactionOptions The user-defined options for this transaction.\r\n     */\r\n    constructor(firestore, requestTag, transactionOptions) {\r\n        this._maxAttempts = index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;\r\n        this._firestore = firestore;\r\n        this._requestTag = requestTag;\r\n        if (transactionOptions === null || transactionOptions === void 0 ? void 0 : transactionOptions.readOnly) {\r\n            // Avoid initialising write batch and backoff unnecessarily for read-only transactions\r\n            this._maxAttempts = 1;\r\n            this._readOnlyReadTime = transactionOptions.readTime;\r\n        }\r\n        else {\r\n            this._maxAttempts =\r\n                (transactionOptions === null || transactionOptions === void 0 ? void 0 : transactionOptions.maxAttempts) || index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;\r\n            this._writeBatch = firestore.batch();\r\n            this._backoff = new backoff_1.ExponentialBackoff();\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve a document or a query result from the database. Holds a\r\n     * pessimistic lock on all returned documents.\r\n     *\r\n     * @param {DocumentReference|Query} refOrQuery The document or query to\r\n     * return.\r\n     * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\r\n     * QuerySnapshot for the returned documents.\r\n     *\r\n     * @example\r\n     * ```\r\n     * firestore.runTransaction(transaction => {\r\n     *   let documentRef = firestore.doc('col/doc');\r\n     *   return transaction.get(documentRef).then(doc => {\r\n     *     if (doc.exists) {\r\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\r\n     *     } else {\r\n     *       transaction.create(documentRef, { count: 1 });\r\n     *     }\r\n     *   });\r\n     * });\r\n     * ```\r\n     */\r\n    get(refOrQuery) {\r\n        if (this._writeBatch && !this._writeBatch.isEmpty) {\r\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\r\n        }\r\n        if (refOrQuery instanceof document_reference_1.DocumentReference) {\r\n            return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_GET_DOCUMENT, () => {\r\n                return this.withLazyStartedTransaction(refOrQuery, this.getSingleFn);\r\n            });\r\n        }\r\n        if (refOrQuery instanceof query_1.Query || refOrQuery instanceof aggregate_query_1.AggregateQuery) {\r\n            return this._firestore._traceUtil.startActiveSpan(refOrQuery instanceof query_1.Query\r\n                ? trace_util_1.SPAN_NAME_TRANSACTION_GET_QUERY\r\n                : trace_util_1.SPAN_NAME_TRANSACTION_GET_AGGREGATION_QUERY, () => {\r\n                return this.withLazyStartedTransaction(refOrQuery, this.getQueryFn);\r\n            });\r\n        }\r\n        throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference, Query, or AggregateQuery.');\r\n    }\r\n    /**\r\n     * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\r\n     * all returned documents.\r\n     *\r\n     * The first argument is required and must be of type `DocumentReference`\r\n     * followed by any additional `DocumentReference` documents. If used, the\r\n     * optional `ReadOptions` must be the last argument.\r\n     *\r\n     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\r\n     * `DocumentReferences` to receive, followed by an optional field mask.\r\n     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\r\n     * contains an array with the resulting document snapshots.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let firstDoc = firestore.doc('col/doc1');\r\n     * let secondDoc = firestore.doc('col/doc2');\r\n     * let resultDoc = firestore.doc('col/doc3');\r\n     *\r\n     * firestore.runTransaction(transaction => {\r\n     *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\r\n     *     transaction.set(resultDoc, {\r\n     *       sum: docs[0].get('count') + docs[1].get('count')\r\n     *     });\r\n     *   });\r\n     * });\r\n     * ```\r\n     */\r\n    getAll(...documentRefsOrReadOptions) {\r\n        if (this._writeBatch && !this._writeBatch.isEmpty) {\r\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\r\n        }\r\n        (0, validate_1.validateMinNumberOfArguments)('Transaction.getAll', documentRefsOrReadOptions, 1);\r\n        return this.withLazyStartedTransaction(parseGetAllArguments(documentRefsOrReadOptions), this.getBatchFn);\r\n    }\r\n    /**\r\n     * Create the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. The operation will\r\n     * fail the transaction if a document exists at the specified location.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * created.\r\n     * @param {DocumentData} data The object data to serialize as the document.\r\n     * @returns {Transaction} This Transaction instance. Used for\r\n     * chaining method calls.\r\n     *\r\n     * @example\r\n     * ```\r\n     * firestore.runTransaction(transaction => {\r\n     *   let documentRef = firestore.doc('col/doc');\r\n     *   return transaction.get(documentRef).then(doc => {\r\n     *     if (!doc.exists) {\r\n     *       transaction.create(documentRef, { foo: 'bar' });\r\n     *     }\r\n     *   });\r\n     * });\r\n     * ```\r\n     */\r\n    create(documentRef, data) {\r\n        if (!this._writeBatch) {\r\n            throw new Error(READ_ONLY_WRITE_ERROR_MSG);\r\n        }\r\n        this._writeBatch.create(documentRef, data);\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes to the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. If the document\r\n     * does not exist yet, it will be created. If you pass\r\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into the\r\n     * existing document.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * set.\r\n     * @param {T|Partial<T>} data The object to serialize as the document.\r\n     * @param {SetOptions=} options An object to configure the set behavior.\r\n     * @param {boolean=} options.merge - If true, set() merges the values\r\n     * specified in its data argument. Fields omitted from this set() call remain\r\n     * untouched. If your input sets any field to an empty map, all nested fields\r\n     * are overwritten.\r\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\r\n     * set() only replaces the specified field paths. Any field path that is not\r\n     * specified is ignored and remains untouched. If your input sets any field to\r\n     * an empty map, all nested fields are overwritten.\r\n     * @throws {Error} If the provided input is not a valid Firestore document.\r\n     * @returns {Transaction} This Transaction instance. Used for\r\n     * chaining method calls.\r\n     *\r\n     * @example\r\n     * ```\r\n     * firestore.runTransaction(transaction => {\r\n     *   let documentRef = firestore.doc('col/doc');\r\n     *   transaction.set(documentRef, { foo: 'bar' });\r\n     *   return Promise.resolve();\r\n     * });\r\n     * ```\r\n     */\r\n    set(documentRef, data, options) {\r\n        if (!this._writeBatch) {\r\n            throw new Error(READ_ONLY_WRITE_ERROR_MSG);\r\n        }\r\n        if (options) {\r\n            this._writeBatch.set(documentRef, data, options);\r\n        }\r\n        else {\r\n            this._writeBatch.set(documentRef, data);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates fields in the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. The update will\r\n     * fail if applied to a document that does not exist.\r\n     *\r\n     * The update() method accepts either an object with field paths encoded as\r\n     * keys and field values encoded as values, or a variable number of arguments\r\n     * that alternate between field paths and field values. Nested fields can be\r\n     * updated by providing dot-separated field path strings or by providing\r\n     * FieldPath objects.\r\n     *\r\n     * A Precondition restricting this update can be specified as the last\r\n     * argument.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * updated.\r\n     * @param {UpdateData|string|FieldPath} dataOrField An object\r\n     * containing the fields and values with which to update the document\r\n     * or the path of the first field to update.\r\n     * @param {\r\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\r\n     * An alternating list of field paths and values to update or a Precondition\r\n     * to to enforce on this update.\r\n     * @throws {Error} If the provided input is not valid Firestore data.\r\n     * @returns {Transaction} This Transaction instance. Used for\r\n     * chaining method calls.\r\n     *\r\n     * @example\r\n     * ```\r\n     * firestore.runTransaction(transaction => {\r\n     *   let documentRef = firestore.doc('col/doc');\r\n     *   return transaction.get(documentRef).then(doc => {\r\n     *     if (doc.exists) {\r\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\r\n     *     } else {\r\n     *       transaction.create(documentRef, { count: 1 });\r\n     *     }\r\n     *   });\r\n     * });\r\n     * ```\r\n     */\r\n    update(documentRef, dataOrField, ...preconditionOrValues) {\r\n        if (!this._writeBatch) {\r\n            throw new Error(READ_ONLY_WRITE_ERROR_MSG);\r\n        }\r\n        // eslint-disable-next-line prefer-rest-params\r\n        (0, validate_1.validateMinNumberOfArguments)('Transaction.update', arguments, 2);\r\n        this._writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\r\n        return this;\r\n    }\r\n    /**\r\n     * Deletes the document referred to by the provided [DocumentReference]\r\n     * {@link DocumentReference}.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * deleted.\r\n     * @param {Precondition=} precondition A precondition to enforce for this\r\n     * delete.\r\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n     * document was last updated at lastUpdateTime. Fails the transaction if the\r\n     * document doesn't exist or was last updated at a different time.\r\n     * @param {boolean=} precondition.exists If set, enforces that the target\r\n     * document must or must not exist.\r\n     * @returns {Transaction} This Transaction instance. Used for\r\n     * chaining method calls.\r\n     *\r\n     * @example\r\n     * ```\r\n     * firestore.runTransaction(transaction => {\r\n     *   let documentRef = firestore.doc('col/doc');\r\n     *   transaction.delete(documentRef);\r\n     *   return Promise.resolve();\r\n     * });\r\n     * ```\r\n     */\r\n    delete(\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    documentRef, precondition) {\r\n        if (!this._writeBatch) {\r\n            throw new Error(READ_ONLY_WRITE_ERROR_MSG);\r\n        }\r\n        this._writeBatch.delete(documentRef, precondition);\r\n        return this;\r\n    }\r\n    /**\r\n     * Commits all queued-up changes in this transaction and releases all locks.\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\r\n    async commit() {\r\n        var _a;\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_COMMIT, async () => {\r\n            if (!this._writeBatch) {\r\n                throw new Error(READ_ONLY_WRITE_ERROR_MSG);\r\n            }\r\n            // If we have not performed any reads in this particular attempt\r\n            // then the writes will be atomically committed without a transaction ID\r\n            let transactionId;\r\n            if (this._transactionIdPromise) {\r\n                transactionId = await this._transactionIdPromise;\r\n            }\r\n            else if (this._writeBatch.isEmpty) {\r\n                // If we have not started a transaction (no reads) and we have no writes\r\n                // then the commit is a no-op (success)\r\n                return;\r\n            }\r\n            await this._writeBatch._commit({\r\n                transactionId,\r\n                requestTag: this._requestTag,\r\n            });\r\n            this._transactionIdPromise = undefined;\r\n            this._prevTransactionId = transactionId;\r\n        }, {\r\n            [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: true,\r\n            [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: (_a = this._writeBatch) === null || _a === void 0 ? void 0 : _a._opCount,\r\n        });\r\n    }\r\n    /**\r\n     * Releases all locks and rolls back this transaction. The rollback process\r\n     * is completed asynchronously and this function resolves before the operation\r\n     * is completed.\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\r\n    async rollback() {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_ROLLBACK, async () => {\r\n            // No need to roll back if we have not lazily started the transaction\r\n            // or if we are read only\r\n            if (!this._transactionIdPromise || !this._writeBatch) {\r\n                return;\r\n            }\r\n            let transactionId;\r\n            try {\r\n                transactionId = await this._transactionIdPromise;\r\n            }\r\n            catch (_a) {\r\n                // This means the initial read operation rejected\r\n                // and we do not have a transaction ID to roll back\r\n                this._transactionIdPromise = undefined;\r\n                return;\r\n            }\r\n            const request = {\r\n                database: this._firestore.formattedName,\r\n                transaction: transactionId,\r\n            };\r\n            this._transactionIdPromise = undefined;\r\n            this._prevTransactionId = transactionId;\r\n            // We don't need to wait for rollback to completed before continuing.\r\n            // If there are any locks held, then rollback will eventually release them.\r\n            // Rollback can be done concurrently thereby reducing latency caused by\r\n            // otherwise blocking.\r\n            this._firestore\r\n                .request('rollback', request, this._requestTag)\r\n                .catch(err => {\r\n                (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Best effort to rollback failed with error:', err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Executes `updateFunction()` and commits the transaction with retry.\r\n     *\r\n     * @private\r\n     * @internal\r\n     * @param updateFunction The user function to execute within the transaction\r\n     * context.\r\n     */\r\n    async runTransaction(updateFunction) {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_RUN, async (span) => {\r\n            // No backoff is set for readonly transactions (i.e. attempts == 1)\r\n            if (!this._writeBatch) {\r\n                return this.runTransactionOnce(updateFunction);\r\n            }\r\n            let lastError = undefined;\r\n            for (let attempt = 0; attempt < this._maxAttempts; ++attempt) {\r\n                span.setAttributes({\r\n                    [trace_util_1.ATTRIBUTE_KEY_TRANSACTION_TYPE]: this._writeBatch\r\n                        ? 'READ_WRITE'\r\n                        : 'READ_ONLY',\r\n                    [trace_util_1.ATTRIBUTE_KEY_ATTEMPTS_ALLOWED]: this._maxAttempts,\r\n                    [trace_util_1.ATTRIBUTE_KEY_ATTEMPTS_REMAINING]: this._maxAttempts - attempt - 1,\r\n                });\r\n                try {\r\n                    if (lastError) {\r\n                        (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Retrying transaction after error:', lastError);\r\n                        span.addEvent('Initiate transaction retry');\r\n                    }\r\n                    this._writeBatch._reset();\r\n                    await maybeBackoff(this._backoff, lastError);\r\n                    return await this.runTransactionOnce(updateFunction);\r\n                }\r\n                catch (err) {\r\n                    lastError = err;\r\n                    if (!isRetryableTransactionError(err)) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);\r\n            return Promise.reject(lastError);\r\n        });\r\n    }\r\n    /**\r\n     * Make single attempt to execute `updateFunction()` and commit the\r\n     * transaction. Will rollback upon error.\r\n     *\r\n     * @private\r\n     * @internal\r\n     * @param updateFunction The user function to execute within the transaction\r\n     * context.\r\n     */\r\n    async runTransactionOnce(updateFunction) {\r\n        try {\r\n            const promise = updateFunction(this);\r\n            if (!(promise instanceof Promise)) {\r\n                throw new Error('You must return a Promise in your transaction()-callback.');\r\n            }\r\n            const result = await promise;\r\n            if (this._writeBatch) {\r\n                await this.commit();\r\n            }\r\n            return result;\r\n        }\r\n        catch (err) {\r\n            (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', err);\r\n            await this.rollback();\r\n            return Promise.reject(err);\r\n        }\r\n    }\r\n    /**\r\n     * Given a function that performs a read operation, ensures that the first one\r\n     * is provided with new transaction options and all subsequent ones are queued\r\n     * upon the resulting transaction ID.\r\n     */\r\n    withLazyStartedTransaction(param, resultFn) {\r\n        if (this._transactionIdPromise) {\r\n            // Simply queue this subsequent read operation after the first read\r\n            // operation has resolved and we don't expect a transaction ID in the\r\n            // response because we are not starting a new transaction\r\n            return this._transactionIdPromise\r\n                .then(opts => resultFn.call(this, param, opts))\r\n                .then(r => r.result);\r\n        }\r\n        else {\r\n            if (this._readOnlyReadTime) {\r\n                // We do not start a transaction for read-only transactions\r\n                // do not set _prevTransactionId\r\n                return resultFn\r\n                    .call(this, param, this._readOnlyReadTime)\r\n                    .then(r => r.result);\r\n            }\r\n            else {\r\n                // This is the first read of the transaction so we create the appropriate\r\n                // options for lazily starting the transaction inside this first read op\r\n                const opts = {};\r\n                if (this._writeBatch) {\r\n                    opts.readWrite = this._prevTransactionId\r\n                        ? { retryTransaction: this._prevTransactionId }\r\n                        : {};\r\n                }\r\n                else {\r\n                    opts.readOnly = {};\r\n                }\r\n                const resultPromise = resultFn.call(this, param, opts);\r\n                // Ensure the _transactionIdPromise is set synchronously so that\r\n                // subsequent operations will not race to start another transaction\r\n                this._transactionIdPromise = resultPromise.then(r => {\r\n                    if (!r.transaction) {\r\n                        // Illegal state\r\n                        // The read operation was provided with new transaction options but did not return a transaction ID\r\n                        // Rejecting here will cause all queued reads to reject\r\n                        throw new Error('Transaction ID was missing from server response');\r\n                    }\r\n                    return r.transaction;\r\n                });\r\n                return resultPromise.then(r => r.result);\r\n            }\r\n        }\r\n    }\r\n    async getSingleFn(document, opts) {\r\n        const documentReader = new document_reader_1.DocumentReader(this._firestore, [document], undefined, opts);\r\n        const { transaction, result: [result], } = await documentReader._get(this._requestTag);\r\n        return { transaction, result };\r\n    }\r\n    async getBatchFn({ documents, fieldMask, }, opts) {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_GET_DOCUMENTS, async () => {\r\n            const documentReader = new document_reader_1.DocumentReader(this._firestore, documents, fieldMask, opts);\r\n            return documentReader._get(this._requestTag);\r\n        });\r\n    }\r\n    async getQueryFn(query, opts) {\r\n        return query._get(opts);\r\n    }\r\n}\r\nexports.Transaction = Transaction;\r\n/**\r\n * Parses the arguments for the `getAll()` call supported by both the Firestore\r\n * and Transaction class.\r\n *\r\n * @private\r\n * @internal\r\n * @param documentRefsOrReadOptions An array of document references followed by\r\n * an optional ReadOptions object.\r\n */\r\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\r\n    let documents;\r\n    let readOptions = undefined;\r\n    if (Array.isArray(documentRefsOrReadOptions[0])) {\r\n        throw new Error('getAll() no longer accepts an array as its first argument. ' +\r\n            'Please unpack your array and call getAll() with individual arguments.');\r\n    }\r\n    if (documentRefsOrReadOptions.length > 0 &&\r\n        (0, util_1.isPlainObject)(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\r\n        readOptions = documentRefsOrReadOptions.pop();\r\n        documents = documentRefsOrReadOptions;\r\n    }\r\n    else {\r\n        documents = documentRefsOrReadOptions;\r\n    }\r\n    for (let i = 0; i < documents.length; ++i) {\r\n        (0, helpers_1.validateDocumentReference)(i, documents[i]);\r\n    }\r\n    validateReadOptions('options', readOptions, { optional: true });\r\n    const fieldMask = readOptions && readOptions.fieldMask\r\n        ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath))\r\n        : undefined;\r\n    return { fieldMask, documents };\r\n}\r\n/**\r\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\r\n * is an array of strings or field paths.\r\n *\r\n * @private\r\n * @internal\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the ReadOptions can be omitted.\r\n */\r\nfunction validateReadOptions(arg, value, options) {\r\n    if (!(0, validate_1.validateOptional)(value, options)) {\r\n        if (!(0, util_1.isObject)(value)) {\r\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} Input is not an object.'`);\r\n        }\r\n        const options = value;\r\n        if (options.fieldMask !== undefined) {\r\n            if (!Array.isArray(options.fieldMask)) {\r\n                throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} \"fieldMask\" is not an array.`);\r\n            }\r\n            for (let i = 0; i < options.fieldMask.length; ++i) {\r\n                try {\r\n                    (0, path_1.validateFieldPath)(i, options.fieldMask[i]);\r\n                }\r\n                catch (err) {\r\n                    throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} \"fieldMask\" is not valid: ${err.message}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction isRetryableTransactionError(error) {\r\n    if (error.code !== undefined) {\r\n        // This list is based on https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/transaction_runner.ts#L112\r\n        switch (error.code) {\r\n            case 10 /* StatusCode.ABORTED */:\r\n            case 1 /* StatusCode.CANCELLED */:\r\n            case 2 /* StatusCode.UNKNOWN */:\r\n            case 4 /* StatusCode.DEADLINE_EXCEEDED */:\r\n            case 13 /* StatusCode.INTERNAL */:\r\n            case 14 /* StatusCode.UNAVAILABLE */:\r\n            case 16 /* StatusCode.UNAUTHENTICATED */:\r\n            case 8 /* StatusCode.RESOURCE_EXHAUSTED */:\r\n                return true;\r\n            case 3 /* StatusCode.INVALID_ARGUMENT */:\r\n                // The Firestore backend uses \"INVALID_ARGUMENT\" for transactions\r\n                // IDs that have expired. While INVALID_ARGUMENT is generally not\r\n                // retryable, we retry this specific case.\r\n                return !!error.message.match(/transaction has expired/);\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Delays further operations based on the provided error.\r\n *\r\n * @private\r\n * @internal\r\n * @return A Promise that resolves after the delay expired.\r\n */\r\nasync function maybeBackoff(backoff, error) {\r\n    if ((error === null || error === void 0 ? void 0 : error.code) === 8 /* StatusCode.RESOURCE_EXHAUSTED */) {\r\n        backoff.resetToMax();\r\n    }\r\n    await backoff.backoffAndWait();\r\n}\r\n//# sourceMappingURL=transaction.js.map"],"mappings":"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N;IACA,MAAM,IAAIX,KAAK,CAAC,wFAAwF,CAAC;EAC7G;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIY,MAAMA,CAAC,GAAGC,yBAAyB,EAAE;IACjC,IAAI,IAAI,CAACpB,WAAW,IAAI,CAAC,IAAI,CAACA,WAAW,CAACM,OAAO,EAAE;MAC/C,MAAM,IAAIC,KAAK,CAACrB,0BAA0B,CAAC;IAC/C;IACA,CAAC,CAAC,EAAEH,UAAU,CAACsC,4BAA4B,EAAE,oBAAoB,EAAED,yBAAyB,EAAE,CAAC,CAAC;IAChG,OAAO,IAAI,CAACR,0BAA0B,CAACxC,oBAAoB,CAACgD,yBAAyB,CAAC,EAAE,IAAI,CAACE,UAAU,CAAC;EAC5G;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,MAAMA,CAACC,WAAW,EAAEC,IAAI,EAAE;IACtB,IAAI,CAAC,IAAI,CAACzB,WAAW,EAAE;MACnB,MAAM,IAAIO,KAAK,CAACpB,yBAAyB,CAAC;IAC9C;IACA,IAAI,CAACa,WAAW,CAACuB,MAAM,CAACC,WAAW,EAAEC,IAAI,CAAC;IAC1C,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,GAAGA,CAACF,WAAW,EAAEC,IAAI,EAAEE,OAAO,EAAE;IAC5B,IAAI,CAAC,IAAI,CAAC3B,WAAW,EAAE;MACnB,MAAM,IAAIO,KAAK,CAACpB,yBAAyB,CAAC;IAC9C;IACA,IAAIwC,OAAO,EAAE;MACT,IAAI,CAAC3B,WAAW,CAAC0B,GAAG,CAACF,WAAW,EAAEC,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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}