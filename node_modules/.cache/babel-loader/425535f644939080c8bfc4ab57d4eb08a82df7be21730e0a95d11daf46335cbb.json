{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RateLimiter = void 0;\n/*!\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nconst assert = require(\"assert\");\nconst logger_1 = require(\"./logger\");\n/**\r\n * A helper that uses the Token Bucket algorithm to rate limit the number of\r\n * operations that can be made in a second.\r\n *\r\n * Before a given request containing a number of operations can proceed,\r\n * RateLimiter determines doing so stays under the provided rate limits. It can\r\n * also determine how much time is required before a request can be made.\r\n *\r\n * RateLimiter can also implement a gradually increasing rate limit. This is\r\n * used to enforce the 500/50/5 rule\r\n * (https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic).\r\n *\r\n * @private\r\n * @internal\r\n */\nclass RateLimiter {\n  /**\r\n   * @param initialCapacity Initial maximum number of operations per second.\r\n   * @param multiplier Rate by which to increase the capacity.\r\n   * @param multiplierMillis How often the capacity should increase in\r\n   * milliseconds.\r\n   * @param maximumCapacity Maximum number of allowed operations per second.\r\n   * The number of tokens added per second will never exceed this number.\r\n   * @param startTimeMillis The starting time in epoch milliseconds that the\r\n   * rate limit is based on. Used for testing the limiter.\r\n   */\n  constructor(initialCapacity, multiplier, multiplierMillis, maximumCapacity, startTimeMillis = Date.now()) {\n    this.initialCapacity = initialCapacity;\n    this.multiplier = multiplier;\n    this.multiplierMillis = multiplierMillis;\n    this.maximumCapacity = maximumCapacity;\n    this.startTimeMillis = startTimeMillis;\n    this.availableTokens = initialCapacity;\n    this.lastRefillTimeMillis = startTimeMillis;\n    this.previousCapacity = initialCapacity;\n  }\n  /**\r\n   * Tries to make the number of operations. Returns true if the request\r\n   * succeeded and false otherwise.\r\n   *\r\n   * @param requestTimeMillis The time used to calculate the number of available\r\n   * tokens. Used for testing the limiter.\r\n   * @private\r\n   * @internal\r\n   */\n  tryMakeRequest(numOperations, requestTimeMillis = Date.now()) {\n    this.refillTokens(requestTimeMillis);\n    if (numOperations <= this.availableTokens) {\n      this.availableTokens -= numOperations;\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * Returns the number of ms needed to make a request with the provided number\r\n   * of operations. Returns 0 if the request can be made with the existing\r\n   * capacity. Returns -1 if the request is not possible with the current\r\n   * capacity.\r\n   *\r\n   * @param requestTimeMillis The time used to calculate the number of available\r\n   * tokens. Used for testing the limiter.\r\n   * @private\r\n   * @internal\r\n   */\n  getNextRequestDelayMs(numOperations, requestTimeMillis = Date.now()) {\n    this.refillTokens(requestTimeMillis);\n    if (numOperations < this.availableTokens) {\n      return 0;\n    }\n    const capacity = this.calculateCapacity(requestTimeMillis);\n    if (capacity < numOperations) {\n      return -1;\n    }\n    const requiredTokens = numOperations - this.availableTokens;\n    return Math.ceil(requiredTokens * 1000 / capacity);\n  }\n  /**\r\n   * Refills the number of available tokens based on how much time has elapsed\r\n   * since the last time the tokens were refilled.\r\n   *\r\n   * @param requestTimeMillis The time used to calculate the number of available\r\n   * tokens. Used for testing the limiter.\r\n   * @private\r\n   * @internal\r\n   */\n  refillTokens(requestTimeMillis) {\n    if (requestTimeMillis >= this.lastRefillTimeMillis) {\n      const elapsedTime = requestTimeMillis - this.lastRefillTimeMillis;\n      const capacity = this.calculateCapacity(requestTimeMillis);\n      const tokensToAdd = Math.floor(elapsedTime * capacity / 1000);\n      if (tokensToAdd > 0) {\n        this.availableTokens = Math.min(capacity, this.availableTokens + tokensToAdd);\n        this.lastRefillTimeMillis = requestTimeMillis;\n      }\n    } else {\n      throw new Error('Request time should not be before the last token refill time.');\n    }\n  }\n  /**\r\n   * Calculates the maximum capacity based on the provided date.\r\n   *\r\n   * @private\r\n   * @internal\r\n   */\n  // Visible for testing.\n  calculateCapacity(requestTimeMillis) {\n    assert(requestTimeMillis >= this.startTimeMillis, 'startTime cannot be after currentTime');\n    const millisElapsed = requestTimeMillis - this.startTimeMillis;\n    const operationsPerSecond = Math.min(Math.floor(Math.pow(this.multiplier, Math.floor(millisElapsed / this.multiplierMillis)) * this.initialCapacity), this.maximumCapacity);\n    if (operationsPerSecond !== this.previousCapacity) {\n      (0, logger_1.logger)('RateLimiter.calculateCapacity', null, `New request capacity: ${operationsPerSecond} operations per second.`);\n    }\n    this.previousCapacity = operationsPerSecond;\n    return operationsPerSecond;\n  }\n}\nexports.RateLimiter = RateLimiter;","map":{"version":3,"names":["Object","defineProperty","exports","value","RateLimiter","assert","require","logger_1","constructor","initialCapacity","multiplier","multiplierMillis","maximumCapacity","startTimeMillis","Date","now","availableTokens","lastRefillTimeMillis","previousCapacity","tryMakeRequest","numOperations","requestTimeMillis","refillTokens","getNextRequestDelayMs","capacity","calculateCapacity","requiredTokens","Math","ceil","elapsedTime","tokensToAdd","floor","min","Error","millisElapsed","operationsPerSecond","pow","logger"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@google-cloud/firestore/build/src/rate-limiter.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RateLimiter = void 0;\r\n/*!\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst assert = require(\"assert\");\r\nconst logger_1 = require(\"./logger\");\r\n/**\r\n * A helper that uses the Token Bucket algorithm to rate limit the number of\r\n * operations that can be made in a second.\r\n *\r\n * Before a given request containing a number of operations can proceed,\r\n * RateLimiter determines doing so stays under the provided rate limits. It can\r\n * also determine how much time is required before a request can be made.\r\n *\r\n * RateLimiter can also implement a gradually increasing rate limit. This is\r\n * used to enforce the 500/50/5 rule\r\n * (https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic).\r\n *\r\n * @private\r\n * @internal\r\n */\r\nclass RateLimiter {\r\n    /**\r\n     * @param initialCapacity Initial maximum number of operations per second.\r\n     * @param multiplier Rate by which to increase the capacity.\r\n     * @param multiplierMillis How often the capacity should increase in\r\n     * milliseconds.\r\n     * @param maximumCapacity Maximum number of allowed operations per second.\r\n     * The number of tokens added per second will never exceed this number.\r\n     * @param startTimeMillis The starting time in epoch milliseconds that the\r\n     * rate limit is based on. Used for testing the limiter.\r\n     */\r\n    constructor(initialCapacity, multiplier, multiplierMillis, maximumCapacity, startTimeMillis = Date.now()) {\r\n        this.initialCapacity = initialCapacity;\r\n        this.multiplier = multiplier;\r\n        this.multiplierMillis = multiplierMillis;\r\n        this.maximumCapacity = maximumCapacity;\r\n        this.startTimeMillis = startTimeMillis;\r\n        this.availableTokens = initialCapacity;\r\n        this.lastRefillTimeMillis = startTimeMillis;\r\n        this.previousCapacity = initialCapacity;\r\n    }\r\n    /**\r\n     * Tries to make the number of operations. Returns true if the request\r\n     * succeeded and false otherwise.\r\n     *\r\n     * @param requestTimeMillis The time used to calculate the number of available\r\n     * tokens. Used for testing the limiter.\r\n     * @private\r\n     * @internal\r\n     */\r\n    tryMakeRequest(numOperations, requestTimeMillis = Date.now()) {\r\n        this.refillTokens(requestTimeMillis);\r\n        if (numOperations <= this.availableTokens) {\r\n            this.availableTokens -= numOperations;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Returns the number of ms needed to make a request with the provided number\r\n     * of operations. Returns 0 if the request can be made with the existing\r\n     * capacity. Returns -1 if the request is not possible with the current\r\n     * capacity.\r\n     *\r\n     * @param requestTimeMillis The time used to calculate the number of available\r\n     * tokens. Used for testing the limiter.\r\n     * @private\r\n     * @internal\r\n     */\r\n    getNextRequestDelayMs(numOperations, requestTimeMillis = Date.now()) {\r\n        this.refillTokens(requestTimeMillis);\r\n        if (numOperations < this.availableTokens) {\r\n            return 0;\r\n        }\r\n        const capacity = this.calculateCapacity(requestTimeMillis);\r\n        if (capacity < numOperations) {\r\n            return -1;\r\n        }\r\n        const requiredTokens = numOperations - this.availableTokens;\r\n        return Math.ceil((requiredTokens * 1000) / capacity);\r\n    }\r\n    /**\r\n     * Refills the number of available tokens based on how much time has elapsed\r\n     * since the last time the tokens were refilled.\r\n     *\r\n     * @param requestTimeMillis The time used to calculate the number of available\r\n     * tokens. Used for testing the limiter.\r\n     * @private\r\n     * @internal\r\n     */\r\n    refillTokens(requestTimeMillis) {\r\n        if (requestTimeMillis >= this.lastRefillTimeMillis) {\r\n            const elapsedTime = requestTimeMillis - this.lastRefillTimeMillis;\r\n            const capacity = this.calculateCapacity(requestTimeMillis);\r\n            const tokensToAdd = Math.floor((elapsedTime * capacity) / 1000);\r\n            if (tokensToAdd > 0) {\r\n                this.availableTokens = Math.min(capacity, this.availableTokens + tokensToAdd);\r\n                this.lastRefillTimeMillis = requestTimeMillis;\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Request time should not be before the last token refill time.');\r\n        }\r\n    }\r\n    /**\r\n     * Calculates the maximum capacity based on the provided date.\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\r\n    // Visible for testing.\r\n    calculateCapacity(requestTimeMillis) {\r\n        assert(requestTimeMillis >= this.startTimeMillis, 'startTime cannot be after currentTime');\r\n        const millisElapsed = requestTimeMillis - this.startTimeMillis;\r\n        const operationsPerSecond = Math.min(Math.floor(Math.pow(this.multiplier, Math.floor(millisElapsed / this.multiplierMillis)) * this.initialCapacity), this.maximumCapacity);\r\n        if (operationsPerSecond !== this.previousCapacity) {\r\n            (0, logger_1.logger)('RateLimiter.calculateCapacity', null, `New request capacity: ${operationsPerSecond} operations per second.`);\r\n        }\r\n        this.previousCapacity = operationsPerSecond;\r\n        return operationsPerSecond;\r\n    }\r\n}\r\nexports.RateLimiter = RateLimiter;\r\n//# sourceMappingURL=rate-limiter.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}