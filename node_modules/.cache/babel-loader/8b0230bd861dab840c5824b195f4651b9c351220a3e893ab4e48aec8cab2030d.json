{"ast":null,"code":"\"use strict\";\n\n/**\r\n * Copyright 2024 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CollectionReference = void 0;\nconst path_1 = require(\"../path\");\nconst util_1 = require(\"../util\");\nconst write_batch_1 = require(\"../write-batch\");\nconst types_1 = require(\"../types\");\nconst query_1 = require(\"./query\");\nconst document_reference_1 = require(\"./document-reference\");\nconst query_options_1 = require(\"./query-options\");\nconst trace_util_1 = require(\"../telemetry/trace-util\");\n/**\r\n * A CollectionReference object can be used for adding documents, getting\r\n * document references, and querying for documents (using the methods\r\n * inherited from [Query]{@link Query}).\r\n *\r\n * @class CollectionReference\r\n * @extends Query\r\n */\nclass CollectionReference extends query_1.Query {\n  /**\r\n   * @private\r\n   *\r\n   * @param firestore The Firestore Database client.\r\n   * @param path The Path of this collection.\r\n   */\n  constructor(firestore, path, converter) {\n    super(firestore, query_options_1.QueryOptions.forCollectionQuery(path, converter));\n  }\n  /**\r\n   * Returns a resource path for this collection.\r\n   * @private\r\n   * @internal\r\n   */\n  get _resourcePath() {\n    return this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n  }\n  /**\r\n   * The last path element of the referenced collection.\r\n   *\r\n   * @type {string}\r\n   * @name CollectionReference#id\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * ```\r\n   * let collectionRef = firestore.collection('col/doc/subcollection');\r\n   * console.log(`ID of the subcollection: ${collectionRef.id}`);\r\n   * ```\r\n   */\n  get id() {\n    return this._queryOptions.collectionId;\n  }\n  /**\r\n   * A reference to the containing Document if this is a subcollection, else\r\n   * null.\r\n   *\r\n   * @type {DocumentReference|null}\r\n   * @name CollectionReference#parent\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * ```\r\n   * let collectionRef = firestore.collection('col/doc/subcollection');\r\n   * let documentRef = collectionRef.parent;\r\n   * console.log(`Parent name: ${documentRef.path}`);\r\n   * ```\r\n   */\n  get parent() {\n    if (this._queryOptions.parentPath.isDocument) {\n      return new document_reference_1.DocumentReference(this.firestore, this._queryOptions.parentPath);\n    }\n    return null;\n  }\n  /**\r\n   * A string representing the path of the referenced collection (relative\r\n   * to the root of the database).\r\n   *\r\n   * @type {string}\r\n   * @name CollectionReference#path\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * ```\r\n   * let collectionRef = firestore.collection('col/doc/subcollection');\r\n   * console.log(`Path of the subcollection: ${collectionRef.path}`);\r\n   * ```\r\n   */\n  get path() {\n    return this._resourcePath.relativeName;\n  }\n  /**\r\n   * Retrieves the list of documents in this collection.\r\n   *\r\n   * The document references returned may include references to \"missing\r\n   * documents\", i.e. document locations that have no document present but\r\n   * which contain subcollections with documents. Attempting to read such a\r\n   * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a\r\n   * `DocumentSnapshot` whose `.exists` property is false.\r\n   *\r\n   * @return {Promise<DocumentReference[]>} The list of documents in this\r\n   * collection.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let collectionRef = firestore.collection('col');\r\n   *\r\n   * return collectionRef.listDocuments().then(documentRefs => {\r\n   *    return firestore.getAll(...documentRefs);\r\n   * }).then(documentSnapshots => {\r\n   *    for (let documentSnapshot of documentSnapshots) {\r\n   *       if (documentSnapshot.exists) {\r\n   *         console.log(`Found document with data: ${documentSnapshot.id}`);\r\n   *       } else {\r\n   *         console.log(`Found missing document: ${documentSnapshot.id}`);\r\n   *       }\r\n   *    }\r\n   * });\r\n   * ```\r\n   */\n  listDocuments() {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_COL_REF_LIST_DOCUMENTS, () => {\n      const tag = (0, util_1.requestTag)();\n      return this.firestore.initializeIfNeeded(tag).then(() => {\n        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId, this.firestore.databaseId);\n        const request = {\n          parent: parentPath.formattedName,\n          collectionId: this.id,\n          showMissing: true,\n          // Setting `pageSize` to an arbitrarily large value lets the backend cap\n          // the page size (currently to 300). Note that the backend rejects\n          // MAX_INT32 (b/146883794).\n          pageSize: Math.pow(2, 16) - 1,\n          mask: {\n            fieldPaths: []\n          }\n        };\n        return this.firestore.request('listDocuments', request, tag).then(documents => {\n          // Note that the backend already orders these documents by name,\n          // so we do not need to manually sort them.\n          return documents.map(doc => {\n            const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);\n            return this.doc(path.id);\n          });\n        });\n      });\n    });\n  }\n  /**\r\n   * Gets a [DocumentReference]{@link DocumentReference} instance that\r\n   * refers to the document at the specified path. If no path is specified, an\r\n   * automatically-generated unique ID will be used for the returned\r\n   * DocumentReference.\r\n   *\r\n   * @param {string=} documentPath A slash-separated path to a document.\r\n   * @returns {DocumentReference} The `DocumentReference`\r\n   * instance.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let collectionRef = firestore.collection('col');\r\n   * let documentRefWithName = collectionRef.doc('doc');\r\n   * let documentRefWithAutoId = collectionRef.doc();\r\n   * console.log(`Reference with name: ${documentRefWithName.path}`);\r\n   * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);\r\n   * ```\r\n   */\n  doc(documentPath) {\n    if (arguments.length === 0) {\n      documentPath = (0, util_1.autoId)();\n    } else {\n      (0, path_1.validateResourcePath)('documentPath', documentPath);\n    }\n    const path = this._resourcePath.append(documentPath);\n    if (!path.isDocument) {\n      throw new Error(`Value for argument \"documentPath\" must point to a document, but was \"${documentPath}\". Your path does not contain an even number of components.`);\n    }\n    return new document_reference_1.DocumentReference(this.firestore, path, this._queryOptions.converter);\n  }\n  /**\r\n   * Add a new document to this collection with the specified data, assigning\r\n   * it a document ID automatically.\r\n   *\r\n   * @param {DocumentData} data An Object containing the data for the new\r\n   * document.\r\n   * @throws {Error} If the provided input is not a valid Firestore document.\r\n   * @returns {Promise.<DocumentReference>} A Promise resolved with a\r\n   * [DocumentReference]{@link DocumentReference} pointing to the\r\n   * newly created document.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let collectionRef = firestore.collection('col');\r\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\r\n   *   console.log(`Added document with name: ${documentReference.id}`);\r\n   * });\r\n   * ```\r\n   */\n  add(data) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_COL_REF_ADD, () => {\n      const firestoreData = this._queryOptions.converter.toFirestore(data);\n      (0, write_batch_1.validateDocumentData)('data', firestoreData, /*allowDeletes=*/false, this._allowUndefined);\n      const documentRef = this.doc();\n      return documentRef.create(data).then(() => documentRef);\n    });\n  }\n  /**\r\n   * Returns true if this `CollectionReference` is equal to the provided value.\r\n   *\r\n   * @param {*} other The value to compare against.\r\n   * @return {boolean} true if this `CollectionReference` is equal to the\r\n   * provided value.\r\n   */\n  isEqual(other) {\n    return this === other || other instanceof CollectionReference && super.isEqual(other);\n  }\n  /**\r\n   * Applies a custom data converter to this CollectionReference, allowing you\r\n   * to use your own custom model objects with Firestore. When you call add() on\r\n   * the returned CollectionReference instance, the provided converter will\r\n   * convert between Firestore data of type `NewDbModelType` and your custom\r\n   * type `NewAppModelType`.\r\n   *\r\n   * Using the converter allows you to specify generic type arguments when\r\n   * storing and retrieving objects from Firestore.\r\n   *\r\n   * Passing in `null` as the converter parameter removes the current\r\n   * converter.\r\n   *\r\n   * @example\r\n   * ```\r\n   * class Post {\r\n   *   constructor(readonly title: string, readonly author: string) {}\r\n   *\r\n   *   toString(): string {\r\n   *     return this.title + ', by ' + this.author;\r\n   *   }\r\n   * }\r\n   *\r\n   * const postConverter = {\r\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\r\n   *     return {title: post.title, author: post.author};\r\n   *   },\r\n   *   fromFirestore(\r\n   *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\r\n   *   ): Post {\r\n   *     const data = snapshot.data();\r\n   *     return new Post(data.title, data.author);\r\n   *   }\r\n   * };\r\n   *\r\n   * const postSnap = await Firestore()\r\n   *   .collection('posts')\r\n   *   .withConverter(postConverter)\r\n   *   .doc().get();\r\n   * const post = postSnap.data();\r\n   * if (post !== undefined) {\r\n   *   post.title; // string\r\n   *   post.toString(); // Should be defined\r\n   *   post.someNonExistentProperty; // TS error\r\n   * }\r\n   *\r\n   * ```\r\n   * @param {FirestoreDataConverter | null} converter Converts objects to and\r\n   * from Firestore. Passing in `null` removes the current converter.\r\n   * @return A CollectionReference that uses the provided converter.\r\n   */\n  withConverter(converter) {\n    return new CollectionReference(this.firestore, this._resourcePath, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\n  }\n}\nexports.CollectionReference = CollectionReference;","map":{"version":3,"names":["Object","defineProperty","exports","value","CollectionReference","path_1","require","util_1","write_batch_1","types_1","query_1","document_reference_1","query_options_1","trace_util_1","Query","constructor","firestore","path","converter","QueryOptions","forCollectionQuery","_resourcePath","_queryOptions","parentPath","append","collectionId","id","parent","isDocument","DocumentReference","relativeName","listDocuments","_firestore","_traceUtil","startActiveSpan","SPAN_NAME_COL_REF_LIST_DOCUMENTS","tag","requestTag","initializeIfNeeded","then","toQualifiedResourcePath","projectId","databaseId","request","formattedName","showMissing","pageSize","Math","pow","mask","fieldPaths","documents","map","doc","QualifiedResourcePath","fromSlashSeparatedString","name","documentPath","arguments","length","autoId","validateResourcePath","Error","add","data","SPAN_NAME_COL_REF_ADD","firestoreData","toFirestore","validateDocumentData","_allowUndefined","documentRef","create","isEqual","other","withConverter","defaultConverter"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@google-cloud/firestore/build/src/reference/collection-reference.js"],"sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2024 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CollectionReference = void 0;\r\nconst path_1 = require(\"../path\");\r\nconst util_1 = require(\"../util\");\r\nconst write_batch_1 = require(\"../write-batch\");\r\nconst types_1 = require(\"../types\");\r\nconst query_1 = require(\"./query\");\r\nconst document_reference_1 = require(\"./document-reference\");\r\nconst query_options_1 = require(\"./query-options\");\r\nconst trace_util_1 = require(\"../telemetry/trace-util\");\r\n/**\r\n * A CollectionReference object can be used for adding documents, getting\r\n * document references, and querying for documents (using the methods\r\n * inherited from [Query]{@link Query}).\r\n *\r\n * @class CollectionReference\r\n * @extends Query\r\n */\r\nclass CollectionReference extends query_1.Query {\r\n    /**\r\n     * @private\r\n     *\r\n     * @param firestore The Firestore Database client.\r\n     * @param path The Path of this collection.\r\n     */\r\n    constructor(firestore, path, converter) {\r\n        super(firestore, query_options_1.QueryOptions.forCollectionQuery(path, converter));\r\n    }\r\n    /**\r\n     * Returns a resource path for this collection.\r\n     * @private\r\n     * @internal\r\n     */\r\n    get _resourcePath() {\r\n        return this._queryOptions.parentPath.append(this._queryOptions.collectionId);\r\n    }\r\n    /**\r\n     * The last path element of the referenced collection.\r\n     *\r\n     * @type {string}\r\n     * @name CollectionReference#id\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * ```\r\n     * let collectionRef = firestore.collection('col/doc/subcollection');\r\n     * console.log(`ID of the subcollection: ${collectionRef.id}`);\r\n     * ```\r\n     */\r\n    get id() {\r\n        return this._queryOptions.collectionId;\r\n    }\r\n    /**\r\n     * A reference to the containing Document if this is a subcollection, else\r\n     * null.\r\n     *\r\n     * @type {DocumentReference|null}\r\n     * @name CollectionReference#parent\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * ```\r\n     * let collectionRef = firestore.collection('col/doc/subcollection');\r\n     * let documentRef = collectionRef.parent;\r\n     * console.log(`Parent name: ${documentRef.path}`);\r\n     * ```\r\n     */\r\n    get parent() {\r\n        if (this._queryOptions.parentPath.isDocument) {\r\n            return new document_reference_1.DocumentReference(this.firestore, this._queryOptions.parentPath);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * A string representing the path of the referenced collection (relative\r\n     * to the root of the database).\r\n     *\r\n     * @type {string}\r\n     * @name CollectionReference#path\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * ```\r\n     * let collectionRef = firestore.collection('col/doc/subcollection');\r\n     * console.log(`Path of the subcollection: ${collectionRef.path}`);\r\n     * ```\r\n     */\r\n    get path() {\r\n        return this._resourcePath.relativeName;\r\n    }\r\n    /**\r\n     * Retrieves the list of documents in this collection.\r\n     *\r\n     * The document references returned may include references to \"missing\r\n     * documents\", i.e. document locations that have no document present but\r\n     * which contain subcollections with documents. Attempting to read such a\r\n     * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a\r\n     * `DocumentSnapshot` whose `.exists` property is false.\r\n     *\r\n     * @return {Promise<DocumentReference[]>} The list of documents in this\r\n     * collection.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let collectionRef = firestore.collection('col');\r\n     *\r\n     * return collectionRef.listDocuments().then(documentRefs => {\r\n     *    return firestore.getAll(...documentRefs);\r\n     * }).then(documentSnapshots => {\r\n     *    for (let documentSnapshot of documentSnapshots) {\r\n     *       if (documentSnapshot.exists) {\r\n     *         console.log(`Found document with data: ${documentSnapshot.id}`);\r\n     *       } else {\r\n     *         console.log(`Found missing document: ${documentSnapshot.id}`);\r\n     *       }\r\n     *    }\r\n     * });\r\n     * ```\r\n     */\r\n    listDocuments() {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_COL_REF_LIST_DOCUMENTS, () => {\r\n            const tag = (0, util_1.requestTag)();\r\n            return this.firestore.initializeIfNeeded(tag).then(() => {\r\n                const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId, this.firestore.databaseId);\r\n                const request = {\r\n                    parent: parentPath.formattedName,\r\n                    collectionId: this.id,\r\n                    showMissing: true,\r\n                    // Setting `pageSize` to an arbitrarily large value lets the backend cap\r\n                    // the page size (currently to 300). Note that the backend rejects\r\n                    // MAX_INT32 (b/146883794).\r\n                    pageSize: Math.pow(2, 16) - 1,\r\n                    mask: { fieldPaths: [] },\r\n                };\r\n                return this.firestore\r\n                    .request('listDocuments', request, tag)\r\n                    .then(documents => {\r\n                    // Note that the backend already orders these documents by name,\r\n                    // so we do not need to manually sort them.\r\n                    return documents.map(doc => {\r\n                        const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);\r\n                        return this.doc(path.id);\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Gets a [DocumentReference]{@link DocumentReference} instance that\r\n     * refers to the document at the specified path. If no path is specified, an\r\n     * automatically-generated unique ID will be used for the returned\r\n     * DocumentReference.\r\n     *\r\n     * @param {string=} documentPath A slash-separated path to a document.\r\n     * @returns {DocumentReference} The `DocumentReference`\r\n     * instance.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let collectionRef = firestore.collection('col');\r\n     * let documentRefWithName = collectionRef.doc('doc');\r\n     * let documentRefWithAutoId = collectionRef.doc();\r\n     * console.log(`Reference with name: ${documentRefWithName.path}`);\r\n     * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);\r\n     * ```\r\n     */\r\n    doc(documentPath) {\r\n        if (arguments.length === 0) {\r\n            documentPath = (0, util_1.autoId)();\r\n        }\r\n        else {\r\n            (0, path_1.validateResourcePath)('documentPath', documentPath);\r\n        }\r\n        const path = this._resourcePath.append(documentPath);\r\n        if (!path.isDocument) {\r\n            throw new Error(`Value for argument \"documentPath\" must point to a document, but was \"${documentPath}\". Your path does not contain an even number of components.`);\r\n        }\r\n        return new document_reference_1.DocumentReference(this.firestore, path, this._queryOptions.converter);\r\n    }\r\n    /**\r\n     * Add a new document to this collection with the specified data, assigning\r\n     * it a document ID automatically.\r\n     *\r\n     * @param {DocumentData} data An Object containing the data for the new\r\n     * document.\r\n     * @throws {Error} If the provided input is not a valid Firestore document.\r\n     * @returns {Promise.<DocumentReference>} A Promise resolved with a\r\n     * [DocumentReference]{@link DocumentReference} pointing to the\r\n     * newly created document.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let collectionRef = firestore.collection('col');\r\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\r\n     *   console.log(`Added document with name: ${documentReference.id}`);\r\n     * });\r\n     * ```\r\n     */\r\n    add(data) {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_COL_REF_ADD, () => {\r\n            const firestoreData = this._queryOptions.converter.toFirestore(data);\r\n            (0, write_batch_1.validateDocumentData)('data', firestoreData, \r\n            /*allowDeletes=*/ false, this._allowUndefined);\r\n            const documentRef = this.doc();\r\n            return documentRef.create(data).then(() => documentRef);\r\n        });\r\n    }\r\n    /**\r\n     * Returns true if this `CollectionReference` is equal to the provided value.\r\n     *\r\n     * @param {*} other The value to compare against.\r\n     * @return {boolean} true if this `CollectionReference` is equal to the\r\n     * provided value.\r\n     */\r\n    isEqual(other) {\r\n        return (this === other ||\r\n            (other instanceof CollectionReference && super.isEqual(other)));\r\n    }\r\n    /**\r\n     * Applies a custom data converter to this CollectionReference, allowing you\r\n     * to use your own custom model objects with Firestore. When you call add() on\r\n     * the returned CollectionReference instance, the provided converter will\r\n     * convert between Firestore data of type `NewDbModelType` and your custom\r\n     * type `NewAppModelType`.\r\n     *\r\n     * Using the converter allows you to specify generic type arguments when\r\n     * storing and retrieving objects from Firestore.\r\n     *\r\n     * Passing in `null` as the converter parameter removes the current\r\n     * converter.\r\n     *\r\n     * @example\r\n     * ```\r\n     * class Post {\r\n     *   constructor(readonly title: string, readonly author: string) {}\r\n     *\r\n     *   toString(): string {\r\n     *     return this.title + ', by ' + this.author;\r\n     *   }\r\n     * }\r\n     *\r\n     * const postConverter = {\r\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\r\n     *     return {title: post.title, author: post.author};\r\n     *   },\r\n     *   fromFirestore(\r\n     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\r\n     *   ): Post {\r\n     *     const data = snapshot.data();\r\n     *     return new Post(data.title, data.author);\r\n     *   }\r\n     * };\r\n     *\r\n     * const postSnap = await Firestore()\r\n     *   .collection('posts')\r\n     *   .withConverter(postConverter)\r\n     *   .doc().get();\r\n     * const post = postSnap.data();\r\n     * if (post !== undefined) {\r\n     *   post.title; // string\r\n     *   post.toString(); // Should be defined\r\n     *   post.someNonExistentProperty; // TS error\r\n     * }\r\n     *\r\n     * ```\r\n     * @param {FirestoreDataConverter | null} converter Converts objects to and\r\n     * from Firestore. Passing in `null` removes the current converter.\r\n     * @return A CollectionReference that uses the provided converter.\r\n     */\r\n    withConverter(converter) {\r\n        return new CollectionReference(this.firestore, this._resourcePath, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\r\n    }\r\n}\r\nexports.CollectionReference = CollectionReference;\r\n//# sourceMappingURL=collection-reference.js.map"],"mappings":"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AAa,EAC7D,iBAAkB,KAAK,EAAE,IAAI,CAACG,eAAe,CAAC;MAC9C,MAAMC,WAAW,GAAG,IAAI,CAACjB,GAAG,CAAC,CAAC;MAC9B,OAAOiB,WAAW,CAACC,MAAM,CAACP,IAAI,CAAC,CAACzB,IAAI,CAAC,MAAM+B,WAAW,CAAC;IAC3D,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,OAAOA,CAACC,KAAK,EAAE;IACX,OAAQ,IAAI,KAAKA,KAAK,IACjBA,KAAK,YAAYrE,mBAAmB,IAAI,KAAK,CAACoE,OAAO,CAACC,KAAK,CAAE;EACtE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAaA,CAACxD,SAAS,EAAE;IACrB,OAAO,IAAId,mBAAmB,CAAC,IAAI,CAACY,SAAS,EAAE,IAAI,CAACK,aAAa,EAAEH,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG,CAAC,CAAC,EAAET,OAAO,CAACkE,gBAAgB,EAAE,CAAC,CAAC;EAChK;AACJ;AACAzE,OAAO,CAACE,mBAAmB,GAAGA,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}