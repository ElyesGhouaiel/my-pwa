{"ast":null,"code":"/*! firebase-admin v13.0.1 */\n\"use strict\";\n\n/*!\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Messaging = void 0;\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\nconst utils = require(\"../utils\");\nconst validator = require(\"../utils/validator\");\nconst messaging_internal_1 = require(\"./messaging-internal\");\nconst messaging_api_request_internal_1 = require(\"./messaging-api-request-internal\");\nconst api_request_1 = require(\"../utils/api-request\");\n// FCM endpoints\nconst FCM_SEND_HOST = 'fcm.googleapis.com';\nconst FCM_TOPIC_MANAGEMENT_HOST = 'iid.googleapis.com';\nconst FCM_TOPIC_MANAGEMENT_ADD_PATH = '/iid/v1:batchAdd';\nconst FCM_TOPIC_MANAGEMENT_REMOVE_PATH = '/iid/v1:batchRemove';\n// Maximum messages that can be included in a batch request.\nconst FCM_MAX_BATCH_SIZE = 500;\n/**\r\n * Maps a raw FCM server response to a `MessagingTopicManagementResponse` object.\r\n *\r\n * @param {object} response The raw FCM server response to map.\r\n *\r\n * @returns {MessagingTopicManagementResponse} The mapped `MessagingTopicManagementResponse` object.\r\n */\nfunction mapRawResponseToTopicManagementResponse(response) {\n  // Add the success and failure counts.\n  const result = {\n    successCount: 0,\n    failureCount: 0,\n    errors: []\n  };\n  if ('results' in response) {\n    response.results.forEach((tokenManagementResult, index) => {\n      // Map the FCM server's error strings to actual error objects.\n      if ('error' in tokenManagementResult) {\n        result.failureCount += 1;\n        const newError = error_1.FirebaseMessagingError.fromTopicManagementServerError(tokenManagementResult.error, /* message */undefined, tokenManagementResult.error);\n        result.errors.push({\n          index,\n          error: newError\n        });\n      } else {\n        result.successCount += 1;\n      }\n    });\n  }\n  return result;\n}\n/**\r\n * Messaging service bound to the provided app.\r\n */\nclass Messaging {\n  /**\r\n   * @internal\r\n   */\n  constructor(app) {\n    this.useLegacyTransport = false;\n    if (!validator.isNonNullObject(app) || !('options' in app)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.messaging() must be a valid Firebase app instance.');\n    }\n    this.appInternal = app;\n    this.messagingRequestHandler = new messaging_api_request_internal_1.FirebaseMessagingRequestHandler(app);\n  }\n  /**\r\n   * The {@link firebase-admin.app#App} associated with the current `Messaging` service\r\n   * instance.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * var app = messaging.app;\r\n   * ```\r\n   */\n  get app() {\n    return this.appInternal;\n  }\n  /**\r\n   * Enables the use of legacy HTTP/1.1 transport for `sendEach()` and `sendEachForMulticast()`.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * const messaging = getMessaging(app);\r\n   * messaging.enableLegacyTransport();\r\n   * messaging.sendEach(messages);\r\n   * ```\r\n   *\r\n   * @deprecated This will be removed when the HTTP/2 transport implementation reaches the same\r\n   * stability as the legacy HTTP/1.1 implementation.\r\n   */\n  enableLegacyHttpTransport() {\n    this.useLegacyTransport = true;\n  }\n  /**\r\n   * Sends the given message via FCM.\r\n   *\r\n   * @param message - The message payload.\r\n   * @param dryRun - Whether to send the message in the dry-run\r\n   *   (validation only) mode.\r\n   * @returns A promise fulfilled with a unique message ID\r\n   *   string after the message has been successfully handed off to the FCM\r\n   *   service for delivery.\r\n   */\n  send(message, dryRun) {\n    const copy = (0, deep_copy_1.deepCopy)(message);\n    (0, messaging_internal_1.validateMessage)(copy);\n    if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n    }\n    return this.getUrlPath().then(urlPath => {\n      const request = {\n        message: copy\n      };\n      if (dryRun) {\n        request.validate_only = true;\n      }\n      return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, urlPath, request);\n    }).then(response => {\n      return response.name;\n    });\n  }\n  /**\r\n  * Sends each message in the given array via Firebase Cloud Messaging.\r\n  *\r\n  * This method makes a single RPC call for each message\r\n  * in the given array.\r\n  *\r\n  * The responses list obtained from the return value corresponds to the order of `messages`.\r\n  * An error from this method or a `BatchResponse` with all failures indicates a total failure,\r\n  * meaning that none of the messages in the list could be sent. Partial failures or no\r\n  * failures are only indicated by a `BatchResponse` return value.\r\n  *\r\n  * @param messages - A non-empty array\r\n  *   containing up to 500 messages.\r\n  * @param dryRun - Whether to send the messages in the dry-run\r\n  *   (validation only) mode.\r\n  * @returns A Promise fulfilled with an object representing the result of the\r\n  *   send operation.\r\n  */\n  sendEach(messages, dryRun) {\n    if (validator.isArray(messages) && messages.constructor !== Array) {\n      // In more recent JS specs, an array-like object might have a constructor that is not of\n      // Array type. Our deepCopy() method doesn't handle them properly. Convert such objects to\n      // a regular array here before calling deepCopy(). See issue #566 for details.\n      messages = Array.from(messages);\n    }\n    const copy = (0, deep_copy_1.deepCopy)(messages);\n    if (!validator.isNonEmptyArray(copy)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'messages must be a non-empty array');\n    }\n    if (copy.length > FCM_MAX_BATCH_SIZE) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `messages list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\n    }\n    if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n    }\n    const http2SessionHandler = this.useLegacyTransport ? undefined : new api_request_1.Http2SessionHandler(`https://${FCM_SEND_HOST}`);\n    return this.getUrlPath().then(urlPath => {\n      const requests = copy.map(async message => {\n        (0, messaging_internal_1.validateMessage)(message);\n        const request = {\n          message\n        };\n        if (dryRun) {\n          request.validate_only = true;\n        }\n        if (http2SessionHandler) {\n          return this.messagingRequestHandler.invokeHttp2RequestHandlerForSendResponse(FCM_SEND_HOST, urlPath, request, http2SessionHandler);\n        }\n        return this.messagingRequestHandler.invokeHttpRequestHandlerForSendResponse(FCM_SEND_HOST, urlPath, request);\n      });\n      return Promise.allSettled(requests);\n    }).then(results => {\n      const responses = [];\n      results.forEach(result => {\n        if (result.status === 'fulfilled') {\n          responses.push(result.value);\n        } else {\n          // rejected\n          responses.push({\n            success: false,\n            error: result.reason\n          });\n        }\n      });\n      const successCount = responses.filter(resp => resp.success).length;\n      return {\n        responses,\n        successCount,\n        failureCount: responses.length - successCount\n      };\n    }).finally(() => {\n      if (http2SessionHandler) {\n        http2SessionHandler.close();\n      }\n    });\n  }\n  /**\r\n   * Sends the given multicast message to all the FCM registration tokens\r\n   * specified in it.\r\n   *\r\n   * This method uses the {@link Messaging.sendEach} API under the hood to send the given\r\n   * message to all the target recipients. The responses list obtained from the\r\n   * return value corresponds to the order of tokens in the `MulticastMessage`.\r\n   * An error from this method or a `BatchResponse` with all failures indicates a total\r\n   * failure, meaning that the messages in the list could be sent. Partial failures or\r\n   * failures are only indicated by a `BatchResponse` return value.\r\n   *\r\n   * @param message - A multicast message\r\n   *   containing up to 500 tokens.\r\n   * @param dryRun - Whether to send the message in the dry-run\r\n   *   (validation only) mode.\r\n   * @returns A Promise fulfilled with an object representing the result of the\r\n   *   send operation.\r\n   */\n  sendEachForMulticast(message, dryRun) {\n    const copy = (0, deep_copy_1.deepCopy)(message);\n    if (!validator.isNonNullObject(copy)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'MulticastMessage must be a non-null object');\n    }\n    if (!validator.isNonEmptyArray(copy.tokens)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'tokens must be a non-empty array');\n    }\n    if (copy.tokens.length > FCM_MAX_BATCH_SIZE) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `tokens list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\n    }\n    const messages = copy.tokens.map(token => {\n      return {\n        token,\n        android: copy.android,\n        apns: copy.apns,\n        data: copy.data,\n        notification: copy.notification,\n        webpush: copy.webpush,\n        fcmOptions: copy.fcmOptions\n      };\n    });\n    return this.sendEach(messages, dryRun);\n  }\n  /**\r\n   * Subscribes a device to an FCM topic.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/cloud-messaging/manage-topics#suscribe_and_unsubscribe_using_the |\r\n   * Subscribe to a topic}\r\n   * for code samples and detailed documentation. Optionally, you can provide an\r\n   * array of tokens to subscribe multiple devices.\r\n   *\r\n   * @param registrationTokens - A token or array of registration tokens\r\n   *   for the devices to subscribe to the topic.\r\n   * @param topic - The topic to which to subscribe.\r\n   *\r\n   * @returns A promise fulfilled with the server's response after the device has been\r\n   *   subscribed to the topic.\r\n   */\n  subscribeToTopic(registrationTokenOrTokens, topic) {\n    return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'subscribeToTopic', FCM_TOPIC_MANAGEMENT_ADD_PATH);\n  }\n  /**\r\n   * Unsubscribes a device from an FCM topic.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/cloud-messaging/admin/manage-topic-subscriptions#unsubscribe_from_a_topic |\r\n   * Unsubscribe from a topic}\r\n   * for code samples and detailed documentation.  Optionally, you can provide an\r\n   * array of tokens to unsubscribe multiple devices.\r\n   *\r\n   * @param registrationTokens - A device registration token or an array of\r\n   *   device registration tokens to unsubscribe from the topic.\r\n   * @param topic - The topic from which to unsubscribe.\r\n   *\r\n   * @returns A promise fulfilled with the server's response after the device has been\r\n   *   unsubscribed from the topic.\r\n   */\n  unsubscribeFromTopic(registrationTokenOrTokens, topic) {\n    return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'unsubscribeFromTopic', FCM_TOPIC_MANAGEMENT_REMOVE_PATH);\n  }\n  getUrlPath() {\n    if (this.urlPath) {\n      return Promise.resolve(this.urlPath);\n    }\n    return utils.findProjectId(this.app).then(projectId => {\n      if (!validator.isNonEmptyString(projectId)) {\n        // Assert for an explicit project ID (either via AppOptions or the cert itself).\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'Failed to determine project ID for Messaging. Initialize the ' + 'SDK with service account credentials or set project ID as an app option. ' + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\n      }\n      this.urlPath = `/v1/projects/${projectId}/messages:send`;\n      return this.urlPath;\n    });\n  }\n  /**\r\n   * Helper method which sends and handles topic subscription management requests.\r\n   *\r\n   * @param registrationTokenOrTokens - The registration token or an array of\r\n   *     registration tokens to unsubscribe from the topic.\r\n   * @param topic - The topic to which to subscribe.\r\n   * @param methodName - The name of the original method called.\r\n   * @param path - The endpoint path to use for the request.\r\n   *\r\n   * @returns A Promise fulfilled with the parsed server\r\n   *   response.\r\n   */\n  sendTopicManagementRequest(registrationTokenOrTokens, topic, methodName, path) {\n    this.validateRegistrationTokensType(registrationTokenOrTokens, methodName);\n    this.validateTopicType(topic, methodName);\n    // Prepend the topic with /topics/ if necessary.\n    topic = this.normalizeTopic(topic);\n    return Promise.resolve().then(() => {\n      // Validate the contents of the input arguments. Because we are now in a promise, any thrown\n      // error will cause this method to return a rejected promise.\n      this.validateRegistrationTokens(registrationTokenOrTokens, methodName);\n      this.validateTopic(topic, methodName);\n      // Ensure the registration token(s) input argument is an array.\n      let registrationTokensArray = registrationTokenOrTokens;\n      if (validator.isString(registrationTokenOrTokens)) {\n        registrationTokensArray = [registrationTokenOrTokens];\n      }\n      const request = {\n        to: topic,\n        registration_tokens: registrationTokensArray\n      };\n      return this.messagingRequestHandler.invokeRequestHandler(FCM_TOPIC_MANAGEMENT_HOST, path, request);\n    }).then(response => {\n      return mapRawResponseToTopicManagementResponse(response);\n    });\n  }\n  /**\r\n   * Validates the type of the provided registration token(s). If invalid, an error will be thrown.\r\n   *\r\n   * @param registrationTokenOrTokens - The registration token(s) to validate.\r\n   * @param method - The method name to use in error messages.\r\n   * @param errorInfo - The error info to use if the registration tokens are invalid.\r\n   */\n  validateRegistrationTokensType(registrationTokenOrTokens, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\n    if (!validator.isNonEmptyArray(registrationTokenOrTokens) && !validator.isNonEmptyString(registrationTokenOrTokens)) {\n      throw new error_1.FirebaseMessagingError(errorInfo, `Registration token(s) provided to ${methodName}() must be a non-empty string or a ` + 'non-empty array.');\n    }\n  }\n  /**\r\n   * Validates the provided registration tokens. If invalid, an error will be thrown.\r\n   *\r\n   * @param registrationTokenOrTokens - The registration token or an array of\r\n   *     registration tokens to validate.\r\n   * @param method - The method name to use in error messages.\r\n   * @param errorInfo - The error info to use if the registration tokens are invalid.\r\n   */\n  validateRegistrationTokens(registrationTokenOrTokens, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\n    if (validator.isArray(registrationTokenOrTokens)) {\n      // Validate the array contains no more than 1,000 registration tokens.\n      if (registrationTokenOrTokens.length > 1000) {\n        throw new error_1.FirebaseMessagingError(errorInfo, `Too many registration tokens provided in a single request to ${methodName}(). Batch ` + 'your requests to contain no more than 1,000 registration tokens per request.');\n      }\n      // Validate the array contains registration tokens which are non-empty strings.\n      registrationTokenOrTokens.forEach((registrationToken, index) => {\n        if (!validator.isNonEmptyString(registrationToken)) {\n          throw new error_1.FirebaseMessagingError(errorInfo, `Registration token provided to ${methodName}() at index ${index} must be a ` + 'non-empty string.');\n        }\n      });\n    }\n  }\n  /**\r\n   * Validates the type of the provided topic. If invalid, an error will be thrown.\r\n   *\r\n   * @param topic - The topic to validate.\r\n   * @param method - The method name to use in error messages.\r\n   * @param errorInfo - The error info to use if the topic is invalid.\r\n   */\n  validateTopicType(topic, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\n    if (!validator.isNonEmptyString(topic)) {\n      throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to ${methodName}() must be a string which matches the format ` + '\"/topics/[a-zA-Z0-9-_.~%]+\".');\n    }\n  }\n  /**\r\n   * Validates the provided topic. If invalid, an error will be thrown.\r\n   *\r\n   * @param topic - The topic to validate.\r\n   * @param method - The method name to use in error messages.\r\n   * @param errorInfo - The error info to use if the topic is invalid.\r\n   */\n  validateTopic(topic, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\n    if (!validator.isTopic(topic)) {\n      throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to ${methodName}() must be a string which matches the format ` + '\"/topics/[a-zA-Z0-9-_.~%]+\".');\n    }\n  }\n  /**\r\n   * Normalizes the provided topic name by prepending it with '/topics/', if necessary.\r\n   *\r\n   * @param topic - The topic name to normalize.\r\n   *\r\n   * @returns The normalized topic name.\r\n   */\n  normalizeTopic(topic) {\n    if (!/^\\/topics\\//.test(topic)) {\n      topic = `/topics/${topic}`;\n    }\n    return topic;\n  }\n}\nexports.Messaging = Messaging;","map":{"version":3,"names":["Object","defineProperty","exports","value","Messaging","deep_copy_1","require","error_1","utils","validator","messaging_internal_1","messaging_api_request_internal_1","api_request_1","FCM_SEND_HOST","FCM_TOPIC_MANAGEMENT_HOST","FCM_TOPIC_MANAGEMENT_ADD_PATH","FCM_TOPIC_MANAGEMENT_REMOVE_PATH","FCM_MAX_BATCH_SIZE","mapRawResponseToTopicManagementResponse","response","result","successCount","failureCount","errors","results","forEach","tokenManagementResult","index","newError","FirebaseMessagingError","fromTopicManagementServerError","error","undefined","push","constructor","app","useLegacyTransport","isNonNullObject","MessagingClientErrorCode","INVALID_ARGUMENT","appInternal","messagingRequestHandler","FirebaseMessagingRequestHandler","enableLegacyHttpTransport","send","message","dryRun","copy","deepCopy","validateMessage","isBoolean","getUrlPath","then","urlPath","request","validate_only","invokeRequestHandler","name","sendEach","messages","isArray","Array","from","isNonEmptyArray","length","http2SessionHandler","Http2SessionHandler","requests","map","invokeHttp2RequestHandlerForSendResponse","invokeHttpRequestHandlerForSendResponse","Promise","allSettled","responses","status","success","reason","filter","resp","finally","close","sendEachForMulticast","tokens","token","android","apns","data","notification","webpush","fcmOptions","subscribeToTopic","registrationTokenOrTokens","topic","sendTopicManagementRequest","unsubscribeFromTopic","resolve","findProjectId","projectId","isNonEmptyString","methodName","path","validateRegistrationTokensType","validateTopicType","normalizeTopic","validateRegistrationTokens","validateTopic","registrationTokensArray","isString","to","registration_tokens","errorInfo","registrationToken","isTopic","test"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/firebase-admin/lib/messaging/messaging.js"],"sourcesContent":["/*! firebase-admin v13.0.1 */\r\n\"use strict\";\r\n/*!\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Messaging = void 0;\r\nconst deep_copy_1 = require(\"../utils/deep-copy\");\r\nconst error_1 = require(\"../utils/error\");\r\nconst utils = require(\"../utils\");\r\nconst validator = require(\"../utils/validator\");\r\nconst messaging_internal_1 = require(\"./messaging-internal\");\r\nconst messaging_api_request_internal_1 = require(\"./messaging-api-request-internal\");\r\nconst api_request_1 = require(\"../utils/api-request\");\r\n// FCM endpoints\r\nconst FCM_SEND_HOST = 'fcm.googleapis.com';\r\nconst FCM_TOPIC_MANAGEMENT_HOST = 'iid.googleapis.com';\r\nconst FCM_TOPIC_MANAGEMENT_ADD_PATH = '/iid/v1:batchAdd';\r\nconst FCM_TOPIC_MANAGEMENT_REMOVE_PATH = '/iid/v1:batchRemove';\r\n// Maximum messages that can be included in a batch request.\r\nconst FCM_MAX_BATCH_SIZE = 500;\r\n/**\r\n * Maps a raw FCM server response to a `MessagingTopicManagementResponse` object.\r\n *\r\n * @param {object} response The raw FCM server response to map.\r\n *\r\n * @returns {MessagingTopicManagementResponse} The mapped `MessagingTopicManagementResponse` object.\r\n */\r\nfunction mapRawResponseToTopicManagementResponse(response) {\r\n    // Add the success and failure counts.\r\n    const result = {\r\n        successCount: 0,\r\n        failureCount: 0,\r\n        errors: [],\r\n    };\r\n    if ('results' in response) {\r\n        response.results.forEach((tokenManagementResult, index) => {\r\n            // Map the FCM server's error strings to actual error objects.\r\n            if ('error' in tokenManagementResult) {\r\n                result.failureCount += 1;\r\n                const newError = error_1.FirebaseMessagingError.fromTopicManagementServerError(tokenManagementResult.error, /* message */ undefined, tokenManagementResult.error);\r\n                result.errors.push({\r\n                    index,\r\n                    error: newError,\r\n                });\r\n            }\r\n            else {\r\n                result.successCount += 1;\r\n            }\r\n        });\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Messaging service bound to the provided app.\r\n */\r\nclass Messaging {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(app) {\r\n        this.useLegacyTransport = false;\r\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\r\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.messaging() must be a valid Firebase app instance.');\r\n        }\r\n        this.appInternal = app;\r\n        this.messagingRequestHandler = new messaging_api_request_internal_1.FirebaseMessagingRequestHandler(app);\r\n    }\r\n    /**\r\n     * The {@link firebase-admin.app#App} associated with the current `Messaging` service\r\n     * instance.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var app = messaging.app;\r\n     * ```\r\n     */\r\n    get app() {\r\n        return this.appInternal;\r\n    }\r\n    /**\r\n     * Enables the use of legacy HTTP/1.1 transport for `sendEach()` and `sendEachForMulticast()`.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const messaging = getMessaging(app);\r\n     * messaging.enableLegacyTransport();\r\n     * messaging.sendEach(messages);\r\n     * ```\r\n     *\r\n     * @deprecated This will be removed when the HTTP/2 transport implementation reaches the same\r\n     * stability as the legacy HTTP/1.1 implementation.\r\n     */\r\n    enableLegacyHttpTransport() {\r\n        this.useLegacyTransport = true;\r\n    }\r\n    /**\r\n     * Sends the given message via FCM.\r\n     *\r\n     * @param message - The message payload.\r\n     * @param dryRun - Whether to send the message in the dry-run\r\n     *   (validation only) mode.\r\n     * @returns A promise fulfilled with a unique message ID\r\n     *   string after the message has been successfully handed off to the FCM\r\n     *   service for delivery.\r\n     */\r\n    send(message, dryRun) {\r\n        const copy = (0, deep_copy_1.deepCopy)(message);\r\n        (0, messaging_internal_1.validateMessage)(copy);\r\n        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\r\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\r\n        }\r\n        return this.getUrlPath()\r\n            .then((urlPath) => {\r\n            const request = { message: copy };\r\n            if (dryRun) {\r\n                request.validate_only = true;\r\n            }\r\n            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, urlPath, request);\r\n        })\r\n            .then((response) => {\r\n            return response.name;\r\n        });\r\n    }\r\n    /**\r\n    * Sends each message in the given array via Firebase Cloud Messaging.\r\n    *\r\n    * This method makes a single RPC call for each message\r\n    * in the given array.\r\n    *\r\n    * The responses list obtained from the return value corresponds to the order of `messages`.\r\n    * An error from this method or a `BatchResponse` with all failures indicates a total failure,\r\n    * meaning that none of the messages in the list could be sent. Partial failures or no\r\n    * failures are only indicated by a `BatchResponse` return value.\r\n    *\r\n    * @param messages - A non-empty array\r\n    *   containing up to 500 messages.\r\n    * @param dryRun - Whether to send the messages in the dry-run\r\n    *   (validation only) mode.\r\n    * @returns A Promise fulfilled with an object representing the result of the\r\n    *   send operation.\r\n    */\r\n    sendEach(messages, dryRun) {\r\n        if (validator.isArray(messages) && messages.constructor !== Array) {\r\n            // In more recent JS specs, an array-like object might have a constructor that is not of\r\n            // Array type. Our deepCopy() method doesn't handle them properly. Convert such objects to\r\n            // a regular array here before calling deepCopy(). See issue #566 for details.\r\n            messages = Array.from(messages);\r\n        }\r\n        const copy = (0, deep_copy_1.deepCopy)(messages);\r\n        if (!validator.isNonEmptyArray(copy)) {\r\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'messages must be a non-empty array');\r\n        }\r\n        if (copy.length > FCM_MAX_BATCH_SIZE) {\r\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `messages list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\r\n        }\r\n        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\r\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\r\n        }\r\n        const http2SessionHandler = this.useLegacyTransport ? undefined : new api_request_1.Http2SessionHandler(`https://${FCM_SEND_HOST}`);\r\n        return this.getUrlPath()\r\n            .then((urlPath) => {\r\n            const requests = copy.map(async (message) => {\r\n                (0, messaging_internal_1.validateMessage)(message);\r\n                const request = { message };\r\n                if (dryRun) {\r\n                    request.validate_only = true;\r\n                }\r\n                if (http2SessionHandler) {\r\n                    return this.messagingRequestHandler.invokeHttp2RequestHandlerForSendResponse(FCM_SEND_HOST, urlPath, request, http2SessionHandler);\r\n                }\r\n                return this.messagingRequestHandler.invokeHttpRequestHandlerForSendResponse(FCM_SEND_HOST, urlPath, request);\r\n            });\r\n            return Promise.allSettled(requests);\r\n        })\r\n            .then((results) => {\r\n            const responses = [];\r\n            results.forEach(result => {\r\n                if (result.status === 'fulfilled') {\r\n                    responses.push(result.value);\r\n                }\r\n                else { // rejected\r\n                    responses.push({ success: false, error: result.reason });\r\n                }\r\n            });\r\n            const successCount = responses.filter((resp) => resp.success).length;\r\n            return {\r\n                responses,\r\n                successCount,\r\n                failureCount: responses.length - successCount,\r\n            };\r\n        })\r\n            .finally(() => {\r\n            if (http2SessionHandler) {\r\n                http2SessionHandler.close();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Sends the given multicast message to all the FCM registration tokens\r\n     * specified in it.\r\n     *\r\n     * This method uses the {@link Messaging.sendEach} API under the hood to send the given\r\n     * message to all the target recipients. The responses list obtained from the\r\n     * return value corresponds to the order of tokens in the `MulticastMessage`.\r\n     * An error from this method or a `BatchResponse` with all failures indicates a total\r\n     * failure, meaning that the messages in the list could be sent. Partial failures or\r\n     * failures are only indicated by a `BatchResponse` return value.\r\n     *\r\n     * @param message - A multicast message\r\n     *   containing up to 500 tokens.\r\n     * @param dryRun - Whether to send the message in the dry-run\r\n     *   (validation only) mode.\r\n     * @returns A Promise fulfilled with an object representing the result of the\r\n     *   send operation.\r\n     */\r\n    sendEachForMulticast(message, dryRun) {\r\n        const copy = (0, deep_copy_1.deepCopy)(message);\r\n        if (!validator.isNonNullObject(copy)) {\r\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'MulticastMessage must be a non-null object');\r\n        }\r\n        if (!validator.isNonEmptyArray(copy.tokens)) {\r\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'tokens must be a non-empty array');\r\n        }\r\n        if (copy.tokens.length > FCM_MAX_BATCH_SIZE) {\r\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `tokens list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\r\n        }\r\n        const messages = copy.tokens.map((token) => {\r\n            return {\r\n                token,\r\n                android: copy.android,\r\n                apns: copy.apns,\r\n                data: copy.data,\r\n                notification: copy.notification,\r\n                webpush: copy.webpush,\r\n                fcmOptions: copy.fcmOptions,\r\n            };\r\n        });\r\n        return this.sendEach(messages, dryRun);\r\n    }\r\n    /**\r\n     * Subscribes a device to an FCM topic.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/cloud-messaging/manage-topics#suscribe_and_unsubscribe_using_the |\r\n     * Subscribe to a topic}\r\n     * for code samples and detailed documentation. Optionally, you can provide an\r\n     * array of tokens to subscribe multiple devices.\r\n     *\r\n     * @param registrationTokens - A token or array of registration tokens\r\n     *   for the devices to subscribe to the topic.\r\n     * @param topic - The topic to which to subscribe.\r\n     *\r\n     * @returns A promise fulfilled with the server's response after the device has been\r\n     *   subscribed to the topic.\r\n     */\r\n    subscribeToTopic(registrationTokenOrTokens, topic) {\r\n        return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'subscribeToTopic', FCM_TOPIC_MANAGEMENT_ADD_PATH);\r\n    }\r\n    /**\r\n     * Unsubscribes a device from an FCM topic.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/manage-topic-subscriptions#unsubscribe_from_a_topic |\r\n     * Unsubscribe from a topic}\r\n     * for code samples and detailed documentation.  Optionally, you can provide an\r\n     * array of tokens to unsubscribe multiple devices.\r\n     *\r\n     * @param registrationTokens - A device registration token or an array of\r\n     *   device registration tokens to unsubscribe from the topic.\r\n     * @param topic - The topic from which to unsubscribe.\r\n     *\r\n     * @returns A promise fulfilled with the server's response after the device has been\r\n     *   unsubscribed from the topic.\r\n     */\r\n    unsubscribeFromTopic(registrationTokenOrTokens, topic) {\r\n        return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'unsubscribeFromTopic', FCM_TOPIC_MANAGEMENT_REMOVE_PATH);\r\n    }\r\n    getUrlPath() {\r\n        if (this.urlPath) {\r\n            return Promise.resolve(this.urlPath);\r\n        }\r\n        return utils.findProjectId(this.app)\r\n            .then((projectId) => {\r\n            if (!validator.isNonEmptyString(projectId)) {\r\n                // Assert for an explicit project ID (either via AppOptions or the cert itself).\r\n                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'Failed to determine project ID for Messaging. Initialize the '\r\n                    + 'SDK with service account credentials or set project ID as an app option. '\r\n                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\r\n            }\r\n            this.urlPath = `/v1/projects/${projectId}/messages:send`;\r\n            return this.urlPath;\r\n        });\r\n    }\r\n    /**\r\n     * Helper method which sends and handles topic subscription management requests.\r\n     *\r\n     * @param registrationTokenOrTokens - The registration token or an array of\r\n     *     registration tokens to unsubscribe from the topic.\r\n     * @param topic - The topic to which to subscribe.\r\n     * @param methodName - The name of the original method called.\r\n     * @param path - The endpoint path to use for the request.\r\n     *\r\n     * @returns A Promise fulfilled with the parsed server\r\n     *   response.\r\n     */\r\n    sendTopicManagementRequest(registrationTokenOrTokens, topic, methodName, path) {\r\n        this.validateRegistrationTokensType(registrationTokenOrTokens, methodName);\r\n        this.validateTopicType(topic, methodName);\r\n        // Prepend the topic with /topics/ if necessary.\r\n        topic = this.normalizeTopic(topic);\r\n        return Promise.resolve()\r\n            .then(() => {\r\n            // Validate the contents of the input arguments. Because we are now in a promise, any thrown\r\n            // error will cause this method to return a rejected promise.\r\n            this.validateRegistrationTokens(registrationTokenOrTokens, methodName);\r\n            this.validateTopic(topic, methodName);\r\n            // Ensure the registration token(s) input argument is an array.\r\n            let registrationTokensArray = registrationTokenOrTokens;\r\n            if (validator.isString(registrationTokenOrTokens)) {\r\n                registrationTokensArray = [registrationTokenOrTokens];\r\n            }\r\n            const request = {\r\n                to: topic,\r\n                registration_tokens: registrationTokensArray,\r\n            };\r\n            return this.messagingRequestHandler.invokeRequestHandler(FCM_TOPIC_MANAGEMENT_HOST, path, request);\r\n        })\r\n            .then((response) => {\r\n            return mapRawResponseToTopicManagementResponse(response);\r\n        });\r\n    }\r\n    /**\r\n     * Validates the type of the provided registration token(s). If invalid, an error will be thrown.\r\n     *\r\n     * @param registrationTokenOrTokens - The registration token(s) to validate.\r\n     * @param method - The method name to use in error messages.\r\n     * @param errorInfo - The error info to use if the registration tokens are invalid.\r\n     */\r\n    validateRegistrationTokensType(registrationTokenOrTokens, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\r\n        if (!validator.isNonEmptyArray(registrationTokenOrTokens) &&\r\n            !validator.isNonEmptyString(registrationTokenOrTokens)) {\r\n            throw new error_1.FirebaseMessagingError(errorInfo, `Registration token(s) provided to ${methodName}() must be a non-empty string or a ` +\r\n                'non-empty array.');\r\n        }\r\n    }\r\n    /**\r\n     * Validates the provided registration tokens. If invalid, an error will be thrown.\r\n     *\r\n     * @param registrationTokenOrTokens - The registration token or an array of\r\n     *     registration tokens to validate.\r\n     * @param method - The method name to use in error messages.\r\n     * @param errorInfo - The error info to use if the registration tokens are invalid.\r\n     */\r\n    validateRegistrationTokens(registrationTokenOrTokens, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\r\n        if (validator.isArray(registrationTokenOrTokens)) {\r\n            // Validate the array contains no more than 1,000 registration tokens.\r\n            if (registrationTokenOrTokens.length > 1000) {\r\n                throw new error_1.FirebaseMessagingError(errorInfo, `Too many registration tokens provided in a single request to ${methodName}(). Batch ` +\r\n                    'your requests to contain no more than 1,000 registration tokens per request.');\r\n            }\r\n            // Validate the array contains registration tokens which are non-empty strings.\r\n            registrationTokenOrTokens.forEach((registrationToken, index) => {\r\n                if (!validator.isNonEmptyString(registrationToken)) {\r\n                    throw new error_1.FirebaseMessagingError(errorInfo, `Registration token provided to ${methodName}() at index ${index} must be a ` +\r\n                        'non-empty string.');\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Validates the type of the provided topic. If invalid, an error will be thrown.\r\n     *\r\n     * @param topic - The topic to validate.\r\n     * @param method - The method name to use in error messages.\r\n     * @param errorInfo - The error info to use if the topic is invalid.\r\n     */\r\n    validateTopicType(topic, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\r\n        if (!validator.isNonEmptyString(topic)) {\r\n            throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to ${methodName}() must be a string which matches the format ` +\r\n                '\"/topics/[a-zA-Z0-9-_.~%]+\".');\r\n        }\r\n    }\r\n    /**\r\n     * Validates the provided topic. If invalid, an error will be thrown.\r\n     *\r\n     * @param topic - The topic to validate.\r\n     * @param method - The method name to use in error messages.\r\n     * @param errorInfo - The error info to use if the topic is invalid.\r\n     */\r\n    validateTopic(topic, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\r\n        if (!validator.isTopic(topic)) {\r\n            throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to ${methodName}() must be a string which matches the format ` +\r\n                '\"/topics/[a-zA-Z0-9-_.~%]+\".');\r\n        }\r\n    }\r\n    /**\r\n     * Normalizes the provided topic name by prepending it with '/topics/', if necessary.\r\n     *\r\n     * @param topic - The topic name to normalize.\r\n     *\r\n     * @returns The normalized topic name.\r\n     */\r\n    normalizeTopic(topic) {\r\n        if (!/^\\/topics\\//.test(topic)) {\r\n            topic = `/topics/${topic}`;\r\n        }\r\n        return topic;\r\n    }\r\n}\r\nexports.Messaging = Messaging;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}