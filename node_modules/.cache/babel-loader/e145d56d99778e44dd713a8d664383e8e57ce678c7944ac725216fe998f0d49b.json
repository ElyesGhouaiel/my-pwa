{"ast":null,"code":"/*! firebase-admin v13.0.1 */\n\"use strict\";\n\n/*!\r\n * @license\r\n * Copyright 2020 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ImpersonatedServiceAccountCredential = exports.RefreshTokenCredential = exports.ServiceAccountCredential = exports.ApplicationDefaultCredential = void 0;\nexports.isApplicationDefault = isApplicationDefault;\nexports.getApplicationDefault = getApplicationDefault;\nconst fs = require(\"fs\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst error_1 = require(\"../utils/error\");\nconst util = require(\"../utils/validator\");\nconst SCOPES = ['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/firebase.database', 'https://www.googleapis.com/auth/firebase.messaging', 'https://www.googleapis.com/auth/identitytoolkit', 'https://www.googleapis.com/auth/userinfo.email'];\n/**\r\n * Implementation of ADC that uses google-auth-library-nodejs.\r\n */\nclass ApplicationDefaultCredential {\n  constructor(httpAgent) {\n    this.googleAuth = new google_auth_library_1.GoogleAuth({\n      scopes: SCOPES,\n      clientOptions: {\n        transporterOptions: {\n          agent: httpAgent\n        }\n      }\n    });\n  }\n  async getAccessToken() {\n    if (!this.authClient) {\n      this.authClient = await this.googleAuth.getClient();\n    }\n    await this.authClient.getAccessToken();\n    const credentials = this.authClient.credentials;\n    this.quotaProjectId = this.authClient.quotaProjectId;\n    return populateCredential(credentials);\n  }\n  async getProjectId() {\n    if (!this.projectId) {\n      this.projectId = await this.googleAuth.getProjectId();\n    }\n    return Promise.resolve(this.projectId);\n  }\n  getQuotaProjectId() {\n    if (!this.quotaProjectId) {\n      this.quotaProjectId = this.authClient?.quotaProjectId;\n    }\n    return this.quotaProjectId;\n  }\n  async isComputeEngineCredential() {\n    if (!this.authClient) {\n      this.authClient = await this.googleAuth.getClient();\n    }\n    return Promise.resolve(this.authClient instanceof google_auth_library_1.Compute);\n  }\n  /**\r\n  * getIDToken returns a OIDC token from the compute metadata service\r\n  * that can be used to make authenticated calls to audience\r\n  * @param audience the URL the returned ID token will be used to call.\r\n  */\n  async getIDToken(audience) {\n    if (await this.isComputeEngineCredential()) {\n      return this.authClient.fetchIdToken(audience);\n    } else {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Credentials type should be Compute Engine Credentials.');\n    }\n  }\n  async getServiceAccountEmail() {\n    if (this.accountId) {\n      return Promise.resolve(this.accountId);\n    }\n    const {\n      client_email: clientEmail\n    } = await this.googleAuth.getCredentials();\n    this.accountId = clientEmail ?? '';\n    return Promise.resolve(this.accountId);\n  }\n}\nexports.ApplicationDefaultCredential = ApplicationDefaultCredential;\n/**\r\n * Implementation of Credential that uses a service account.\r\n */\nclass ServiceAccountCredential {\n  /**\r\n   * Creates a new ServiceAccountCredential from the given parameters.\r\n   *\r\n   * @param serviceAccountPathOrObject - Service account json object or path to a service account json file.\r\n   * @param httpAgent - Optional http.Agent to use when calling the remote token server.\r\n   * @param implicit - An optional boolean indicating whether this credential was implicitly discovered from the\r\n   *   environment, as opposed to being explicitly specified by the developer.\r\n   *\r\n   * @constructor\r\n   */\n  constructor(serviceAccountPathOrObject, httpAgent, implicit = false) {\n    this.serviceAccountPathOrObject = serviceAccountPathOrObject;\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    const serviceAccount = typeof serviceAccountPathOrObject === 'string' ? ServiceAccount.fromPath(serviceAccountPathOrObject) : new ServiceAccount(serviceAccountPathOrObject);\n    this.projectId = serviceAccount.projectId;\n    this.privateKey = serviceAccount.privateKey;\n    this.clientEmail = serviceAccount.clientEmail;\n  }\n  getGoogleAuth() {\n    if (this.googleAuth) {\n      return this.googleAuth;\n    }\n    const {\n      auth,\n      client\n    } = populateGoogleAuth(this.serviceAccountPathOrObject, this.httpAgent);\n    this.googleAuth = auth;\n    this.authClient = client;\n    return this.googleAuth;\n  }\n  async getAccessToken() {\n    const googleAuth = this.getGoogleAuth();\n    if (this.authClient === undefined) {\n      this.authClient = await googleAuth.getClient();\n    }\n    await this.authClient.getAccessToken();\n    const credentials = this.authClient.credentials;\n    return populateCredential(credentials);\n  }\n}\nexports.ServiceAccountCredential = ServiceAccountCredential;\n/**\r\n * A struct containing the properties necessary to use service account JSON credentials.\r\n */\nclass ServiceAccount {\n  static fromPath(filePath) {\n    try {\n      return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);\n    }\n  }\n  constructor(json) {\n    if (!util.isNonNullObject(json)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\n    }\n    copyAttr(this, json, 'projectId', 'project_id');\n    copyAttr(this, json, 'privateKey', 'private_key');\n    copyAttr(this, json, 'clientEmail', 'client_email');\n    let errorMessage;\n    if (!util.isNonEmptyString(this.projectId)) {\n      errorMessage = 'Service account object must contain a string \"project_id\" property.';\n    } else if (!util.isNonEmptyString(this.privateKey)) {\n      errorMessage = 'Service account object must contain a string \"private_key\" property.';\n    } else if (!util.isNonEmptyString(this.clientEmail)) {\n      errorMessage = 'Service account object must contain a string \"client_email\" property.';\n    }\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const forge = require('node-forge');\n    try {\n      forge.pki.privateKeyFromPem(this.privateKey);\n    } catch (error) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n    }\n  }\n}\n/**\r\n * Implementation of Credential that gets access tokens from refresh tokens.\r\n */\nclass RefreshTokenCredential {\n  /**\r\n   * Creates a new RefreshTokenCredential from the given parameters.\r\n   *\r\n   * @param refreshTokenPathOrObject - Refresh token json object or path to a refresh token\r\n   *   (user credentials) json file.\r\n   * @param httpAgent - Optional http.Agent to use when calling the remote token server.\r\n   * @param implicit - An optinal boolean indicating whether this credential was implicitly\r\n   *   discovered from the environment, as opposed to being explicitly specified by the developer.\r\n   *\r\n   * @constructor\r\n   */\n  constructor(refreshTokenPathOrObject, httpAgent, implicit = false) {\n    this.refreshTokenPathOrObject = refreshTokenPathOrObject;\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    typeof refreshTokenPathOrObject === 'string' ? RefreshToken.validateFromPath(refreshTokenPathOrObject) : RefreshToken.validateFromJSON(refreshTokenPathOrObject);\n  }\n  getGoogleAuth() {\n    if (this.googleAuth) {\n      return this.googleAuth;\n    }\n    const {\n      auth,\n      client\n    } = populateGoogleAuth(this.refreshTokenPathOrObject, this.httpAgent);\n    this.googleAuth = auth;\n    this.authClient = client;\n    return this.googleAuth;\n  }\n  async getAccessToken() {\n    const googleAuth = this.getGoogleAuth();\n    if (this.authClient === undefined) {\n      this.authClient = await googleAuth.getClient();\n    }\n    await this.authClient.getAccessToken();\n    const credentials = this.authClient.credentials;\n    return populateCredential(credentials);\n  }\n}\nexports.RefreshTokenCredential = RefreshTokenCredential;\nclass RefreshToken {\n  /*\r\n   * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the\r\n   * data at the path is invalid.\r\n   */\n  static validateFromPath(filePath) {\n    try {\n      RefreshToken.validateFromJSON(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n    }\n  }\n  static validateFromJSON(json) {\n    const creds = {\n      clientId: '',\n      clientSecret: '',\n      refreshToken: '',\n      type: ''\n    };\n    copyAttr(creds, json, 'clientId', 'client_id');\n    copyAttr(creds, json, 'clientSecret', 'client_secret');\n    copyAttr(creds, json, 'refreshToken', 'refresh_token');\n    copyAttr(creds, json, 'type', 'type');\n    let errorMessage;\n    if (!util.isNonEmptyString(creds.clientId)) {\n      errorMessage = 'Refresh token must contain a \"client_id\" property.';\n    } else if (!util.isNonEmptyString(creds.clientSecret)) {\n      errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n    } else if (!util.isNonEmptyString(creds.refreshToken)) {\n      errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n    } else if (!util.isNonEmptyString(creds.type)) {\n      errorMessage = 'Refresh token must contain a \"type\" property.';\n    }\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n  }\n}\n/**\r\n * Implementation of Credential that uses impersonated service account.\r\n */\nclass ImpersonatedServiceAccountCredential {\n  /**\r\n   * Creates a new ImpersonatedServiceAccountCredential from the given parameters.\r\n   *\r\n   * @param impersonatedServiceAccountPathOrObject - Impersonated Service account json object or\r\n   * path to a service account json file.\r\n   * @param httpAgent - Optional http.Agent to use when calling the remote token server.\r\n   * @param implicit - An optional boolean indicating whether this credential was implicitly\r\n   *   discovered from the environment, as opposed to being explicitly specified by the developer.\r\n   *\r\n   * @constructor\r\n   */\n  constructor(impersonatedServiceAccountPathOrObject, httpAgent, implicit = false) {\n    this.impersonatedServiceAccountPathOrObject = impersonatedServiceAccountPathOrObject;\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    typeof impersonatedServiceAccountPathOrObject === 'string' ? ImpersonatedServiceAccount.validateFromPath(impersonatedServiceAccountPathOrObject) : ImpersonatedServiceAccount.validateFromJSON(impersonatedServiceAccountPathOrObject);\n  }\n  getGoogleAuth() {\n    if (this.googleAuth) {\n      return this.googleAuth;\n    }\n    const {\n      auth,\n      client\n    } = populateGoogleAuth(this.impersonatedServiceAccountPathOrObject, this.httpAgent);\n    this.googleAuth = auth;\n    this.authClient = client;\n    return this.googleAuth;\n  }\n  async getAccessToken() {\n    const googleAuth = this.getGoogleAuth();\n    if (this.authClient === undefined) {\n      this.authClient = await googleAuth.getClient();\n    }\n    await this.authClient.getAccessToken();\n    const credentials = this.authClient.credentials;\n    return populateCredential(credentials);\n  }\n}\nexports.ImpersonatedServiceAccountCredential = ImpersonatedServiceAccountCredential;\n/**\r\n * A helper class to validate the properties necessary to use impersonated service account credentials.\r\n */\nclass ImpersonatedServiceAccount {\n  /*\r\n   * Tries to load a ImpersonatedServiceAccount from a path. Throws if the path doesn't exist or the\r\n   * data at the path is invalid.\r\n   */\n  static validateFromPath(filePath) {\n    try {\n      ImpersonatedServiceAccount.validateFromJSON(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse impersonated service account file: ' + error);\n    }\n  }\n  static validateFromJSON(json) {\n    const {\n      client_id: clientId,\n      client_secret: clientSecret,\n      refresh_token: refreshToken,\n      type\n    } = json['source_credentials'];\n    let errorMessage;\n    if (!util.isNonEmptyString(clientId)) {\n      errorMessage = 'Impersonated Service Account must contain a \"source_credentials.client_id\" property.';\n    } else if (!util.isNonEmptyString(clientSecret)) {\n      errorMessage = 'Impersonated Service Account must contain a \"source_credentials.client_secret\" property.';\n    } else if (!util.isNonEmptyString(refreshToken)) {\n      errorMessage = 'Impersonated Service Account must contain a \"source_credentials.refresh_token\" property.';\n    } else if (!util.isNonEmptyString(type)) {\n      errorMessage = 'Impersonated Service Account must contain a \"source_credentials.type\" property.';\n    }\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n  }\n}\n/**\r\n * Checks if the given credential was loaded via the application default credentials mechanism.\r\n *\r\n * @param credential - The credential instance to check.\r\n */\nfunction isApplicationDefault(credential) {\n  return credential instanceof ApplicationDefaultCredential || credential instanceof RefreshTokenCredential && credential.implicit;\n}\nfunction getApplicationDefault(httpAgent) {\n  return new ApplicationDefaultCredential(httpAgent);\n}\n/**\r\n * Copies the specified property from one object to another.\r\n *\r\n * If no property exists by the given \"key\", looks for a property identified by \"alt\", and copies it instead.\r\n * This can be used to implement behaviors such as \"copy property myKey or my_key\".\r\n *\r\n * @param to - Target object to copy the property into.\r\n * @param from - Source object to copy the property from.\r\n * @param key - Name of the property to copy.\r\n * @param alt - Alternative name of the property to copy.\r\n */\nfunction copyAttr(to, from, key, alt) {\n  const tmp = from[key] || from[alt];\n  if (typeof tmp !== 'undefined') {\n    to[key] = tmp;\n  }\n}\n/**\r\n * Populate google-auth-library GoogleAuth credentials type.\r\n */\nfunction populateGoogleAuth(keyFile, httpAgent) {\n  let client;\n  const auth = new google_auth_library_1.GoogleAuth({\n    scopes: SCOPES,\n    clientOptions: {\n      transporterOptions: {\n        agent: httpAgent\n      }\n    },\n    keyFile: typeof keyFile === 'string' ? keyFile : undefined\n  });\n  if (typeof keyFile === 'object') {\n    if (!util.isNonNullObject(keyFile)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\n    }\n    copyAttr(keyFile, keyFile, 'project_id', 'projectId');\n    copyAttr(keyFile, keyFile, 'private_key', 'privateKey');\n    copyAttr(keyFile, keyFile, 'client_email', 'clientEmail');\n    client = auth.fromJSON(keyFile);\n  }\n  return {\n    auth,\n    client\n  };\n}\n/**\r\n * Populate GoogleOAuthAccessToken credentials from google-auth-library Credentials type.\r\n */\nfunction populateCredential(credentials) {\n  const accessToken = credentials?.access_token;\n  const expiryDate = credentials?.expiry_date;\n  if (typeof accessToken !== 'string') throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse Google auth credential: access_token must be a non empty string.');\n  if (typeof expiryDate !== 'number') throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse Google auth credential: Invalid expiry_date.');\n  return {\n    ...credentials,\n    access_token: accessToken,\n    // inverse operation of following\n    // https://github.com/googleapis/google-auth-library-nodejs/blob/5ed910513451c82e2551777a3e2212964799ef8e/src/auth/baseexternalclient.ts#L446-L446\n    expires_in: Math.floor((expiryDate - new Date().getTime()) / 1000)\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ImpersonatedServiceAccountCredential","RefreshTokenCredential","ServiceAccountCredential","ApplicationDefaultCredential","isApplicationDefault","getApplicationDefault","fs","require","google_auth_library_1","error_1","util","SCOPES","constructor","httpAgent","googleAuth","GoogleAuth","scopes","clientOptions","transporterOptions","agent","getAccessToken","authClient","getClient","credentials","quotaProjectId","populateCredential","getProjectId","projectId","Promise","resolve","getQuotaProjectId","isComputeEngineCredential","Compute","getIDToken","audience","fetchIdToken","FirebaseAppError","AppErrorCodes","INVALID_CREDENTIAL","getServiceAccountEmail","accountId","client_email","clientEmail","getCredentials","serviceAccountPathOrObject","implicit","serviceAccount","ServiceAccount","fromPath","privateKey","getGoogleAuth","auth","client","populateGoogleAuth","undefined","filePath","JSON","parse","readFileSync","error","json","isNonNullObject","copyAttr","errorMessage","isNonEmptyString","forge","pki","privateKeyFromPem","refreshTokenPathOrObject","RefreshToken","validateFromPath","validateFromJSON","creds","clientId","clientSecret","refreshToken","type","impersonatedServiceAccountPathOrObject","ImpersonatedServiceAccount","client_id","client_secret","refresh_token","credential","to","from","key","alt","tmp","keyFile","fromJSON","accessToken","access_token","expiryDate","expiry_date","expires_in","Math","floor","Date","getTime"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/firebase-admin/lib/app/credential-internal.js"],"sourcesContent":["/*! firebase-admin v13.0.1 */\r\n\"use strict\";\r\n/*!\r\n * @license\r\n * Copyright 2020 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ImpersonatedServiceAccountCredential = exports.RefreshTokenCredential = exports.ServiceAccountCredential = exports.ApplicationDefaultCredential = void 0;\r\nexports.isApplicationDefault = isApplicationDefault;\r\nexports.getApplicationDefault = getApplicationDefault;\r\nconst fs = require(\"fs\");\r\nconst google_auth_library_1 = require(\"google-auth-library\");\r\nconst error_1 = require(\"../utils/error\");\r\nconst util = require(\"../utils/validator\");\r\nconst SCOPES = [\r\n    'https://www.googleapis.com/auth/cloud-platform',\r\n    'https://www.googleapis.com/auth/firebase.database',\r\n    'https://www.googleapis.com/auth/firebase.messaging',\r\n    'https://www.googleapis.com/auth/identitytoolkit',\r\n    'https://www.googleapis.com/auth/userinfo.email',\r\n];\r\n/**\r\n * Implementation of ADC that uses google-auth-library-nodejs.\r\n */\r\nclass ApplicationDefaultCredential {\r\n    constructor(httpAgent) {\r\n        this.googleAuth = new google_auth_library_1.GoogleAuth({\r\n            scopes: SCOPES,\r\n            clientOptions: {\r\n                transporterOptions: {\r\n                    agent: httpAgent,\r\n                },\r\n            },\r\n        });\r\n    }\r\n    async getAccessToken() {\r\n        if (!this.authClient) {\r\n            this.authClient = await this.googleAuth.getClient();\r\n        }\r\n        await this.authClient.getAccessToken();\r\n        const credentials = this.authClient.credentials;\r\n        this.quotaProjectId = this.authClient.quotaProjectId;\r\n        return populateCredential(credentials);\r\n    }\r\n    async getProjectId() {\r\n        if (!this.projectId) {\r\n            this.projectId = await this.googleAuth.getProjectId();\r\n        }\r\n        return Promise.resolve(this.projectId);\r\n    }\r\n    getQuotaProjectId() {\r\n        if (!this.quotaProjectId) {\r\n            this.quotaProjectId = this.authClient?.quotaProjectId;\r\n        }\r\n        return this.quotaProjectId;\r\n    }\r\n    async isComputeEngineCredential() {\r\n        if (!this.authClient) {\r\n            this.authClient = await this.googleAuth.getClient();\r\n        }\r\n        return Promise.resolve(this.authClient instanceof google_auth_library_1.Compute);\r\n    }\r\n    /**\r\n   * getIDToken returns a OIDC token from the compute metadata service\r\n   * that can be used to make authenticated calls to audience\r\n   * @param audience the URL the returned ID token will be used to call.\r\n  */\r\n    async getIDToken(audience) {\r\n        if (await this.isComputeEngineCredential()) {\r\n            return this.authClient.fetchIdToken(audience);\r\n        }\r\n        else {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Credentials type should be Compute Engine Credentials.');\r\n        }\r\n    }\r\n    async getServiceAccountEmail() {\r\n        if (this.accountId) {\r\n            return Promise.resolve(this.accountId);\r\n        }\r\n        const { client_email: clientEmail } = await this.googleAuth.getCredentials();\r\n        this.accountId = clientEmail ?? '';\r\n        return Promise.resolve(this.accountId);\r\n    }\r\n}\r\nexports.ApplicationDefaultCredential = ApplicationDefaultCredential;\r\n/**\r\n * Implementation of Credential that uses a service account.\r\n */\r\nclass ServiceAccountCredential {\r\n    /**\r\n     * Creates a new ServiceAccountCredential from the given parameters.\r\n     *\r\n     * @param serviceAccountPathOrObject - Service account json object or path to a service account json file.\r\n     * @param httpAgent - Optional http.Agent to use when calling the remote token server.\r\n     * @param implicit - An optional boolean indicating whether this credential was implicitly discovered from the\r\n     *   environment, as opposed to being explicitly specified by the developer.\r\n     *\r\n     * @constructor\r\n     */\r\n    constructor(serviceAccountPathOrObject, httpAgent, implicit = false) {\r\n        this.serviceAccountPathOrObject = serviceAccountPathOrObject;\r\n        this.httpAgent = httpAgent;\r\n        this.implicit = implicit;\r\n        const serviceAccount = (typeof serviceAccountPathOrObject === 'string') ?\r\n            ServiceAccount.fromPath(serviceAccountPathOrObject)\r\n            : new ServiceAccount(serviceAccountPathOrObject);\r\n        this.projectId = serviceAccount.projectId;\r\n        this.privateKey = serviceAccount.privateKey;\r\n        this.clientEmail = serviceAccount.clientEmail;\r\n    }\r\n    getGoogleAuth() {\r\n        if (this.googleAuth) {\r\n            return this.googleAuth;\r\n        }\r\n        const { auth, client } = populateGoogleAuth(this.serviceAccountPathOrObject, this.httpAgent);\r\n        this.googleAuth = auth;\r\n        this.authClient = client;\r\n        return this.googleAuth;\r\n    }\r\n    async getAccessToken() {\r\n        const googleAuth = this.getGoogleAuth();\r\n        if (this.authClient === undefined) {\r\n            this.authClient = await googleAuth.getClient();\r\n        }\r\n        await this.authClient.getAccessToken();\r\n        const credentials = this.authClient.credentials;\r\n        return populateCredential(credentials);\r\n    }\r\n}\r\nexports.ServiceAccountCredential = ServiceAccountCredential;\r\n/**\r\n * A struct containing the properties necessary to use service account JSON credentials.\r\n */\r\nclass ServiceAccount {\r\n    static fromPath(filePath) {\r\n        try {\r\n            return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\r\n        }\r\n        catch (error) {\r\n            // Throw a nicely formed error message if the file contents cannot be parsed\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);\r\n        }\r\n    }\r\n    constructor(json) {\r\n        if (!util.isNonNullObject(json)) {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\r\n        }\r\n        copyAttr(this, json, 'projectId', 'project_id');\r\n        copyAttr(this, json, 'privateKey', 'private_key');\r\n        copyAttr(this, json, 'clientEmail', 'client_email');\r\n        let errorMessage;\r\n        if (!util.isNonEmptyString(this.projectId)) {\r\n            errorMessage = 'Service account object must contain a string \"project_id\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(this.privateKey)) {\r\n            errorMessage = 'Service account object must contain a string \"private_key\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(this.clientEmail)) {\r\n            errorMessage = 'Service account object must contain a string \"client_email\" property.';\r\n        }\r\n        if (typeof errorMessage !== 'undefined') {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\r\n        }\r\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n        const forge = require('node-forge');\r\n        try {\r\n            forge.pki.privateKeyFromPem(this.privateKey);\r\n        }\r\n        catch (error) {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Implementation of Credential that gets access tokens from refresh tokens.\r\n */\r\nclass RefreshTokenCredential {\r\n    /**\r\n     * Creates a new RefreshTokenCredential from the given parameters.\r\n     *\r\n     * @param refreshTokenPathOrObject - Refresh token json object or path to a refresh token\r\n     *   (user credentials) json file.\r\n     * @param httpAgent - Optional http.Agent to use when calling the remote token server.\r\n     * @param implicit - An optinal boolean indicating whether this credential was implicitly\r\n     *   discovered from the environment, as opposed to being explicitly specified by the developer.\r\n     *\r\n     * @constructor\r\n     */\r\n    constructor(refreshTokenPathOrObject, httpAgent, implicit = false) {\r\n        this.refreshTokenPathOrObject = refreshTokenPathOrObject;\r\n        this.httpAgent = httpAgent;\r\n        this.implicit = implicit;\r\n        (typeof refreshTokenPathOrObject === 'string') ?\r\n            RefreshToken.validateFromPath(refreshTokenPathOrObject)\r\n            : RefreshToken.validateFromJSON(refreshTokenPathOrObject);\r\n    }\r\n    getGoogleAuth() {\r\n        if (this.googleAuth) {\r\n            return this.googleAuth;\r\n        }\r\n        const { auth, client } = populateGoogleAuth(this.refreshTokenPathOrObject, this.httpAgent);\r\n        this.googleAuth = auth;\r\n        this.authClient = client;\r\n        return this.googleAuth;\r\n    }\r\n    async getAccessToken() {\r\n        const googleAuth = this.getGoogleAuth();\r\n        if (this.authClient === undefined) {\r\n            this.authClient = await googleAuth.getClient();\r\n        }\r\n        await this.authClient.getAccessToken();\r\n        const credentials = this.authClient.credentials;\r\n        return populateCredential(credentials);\r\n    }\r\n}\r\nexports.RefreshTokenCredential = RefreshTokenCredential;\r\nclass RefreshToken {\r\n    /*\r\n     * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the\r\n     * data at the path is invalid.\r\n     */\r\n    static validateFromPath(filePath) {\r\n        try {\r\n            RefreshToken.validateFromJSON(JSON.parse(fs.readFileSync(filePath, 'utf8')));\r\n        }\r\n        catch (error) {\r\n            // Throw a nicely formed error message if the file contents cannot be parsed\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\r\n        }\r\n    }\r\n    static validateFromJSON(json) {\r\n        const creds = { clientId: '', clientSecret: '', refreshToken: '', type: '' };\r\n        copyAttr(creds, json, 'clientId', 'client_id');\r\n        copyAttr(creds, json, 'clientSecret', 'client_secret');\r\n        copyAttr(creds, json, 'refreshToken', 'refresh_token');\r\n        copyAttr(creds, json, 'type', 'type');\r\n        let errorMessage;\r\n        if (!util.isNonEmptyString(creds.clientId)) {\r\n            errorMessage = 'Refresh token must contain a \"client_id\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(creds.clientSecret)) {\r\n            errorMessage = 'Refresh token must contain a \"client_secret\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(creds.refreshToken)) {\r\n            errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(creds.type)) {\r\n            errorMessage = 'Refresh token must contain a \"type\" property.';\r\n        }\r\n        if (typeof errorMessage !== 'undefined') {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Implementation of Credential that uses impersonated service account.\r\n */\r\nclass ImpersonatedServiceAccountCredential {\r\n    /**\r\n     * Creates a new ImpersonatedServiceAccountCredential from the given parameters.\r\n     *\r\n     * @param impersonatedServiceAccountPathOrObject - Impersonated Service account json object or\r\n     * path to a service account json file.\r\n     * @param httpAgent - Optional http.Agent to use when calling the remote token server.\r\n     * @param implicit - An optional boolean indicating whether this credential was implicitly\r\n     *   discovered from the environment, as opposed to being explicitly specified by the developer.\r\n     *\r\n     * @constructor\r\n     */\r\n    constructor(impersonatedServiceAccountPathOrObject, httpAgent, implicit = false) {\r\n        this.impersonatedServiceAccountPathOrObject = impersonatedServiceAccountPathOrObject;\r\n        this.httpAgent = httpAgent;\r\n        this.implicit = implicit;\r\n        (typeof impersonatedServiceAccountPathOrObject === 'string') ?\r\n            ImpersonatedServiceAccount.validateFromPath(impersonatedServiceAccountPathOrObject)\r\n            : ImpersonatedServiceAccount.validateFromJSON(impersonatedServiceAccountPathOrObject);\r\n    }\r\n    getGoogleAuth() {\r\n        if (this.googleAuth) {\r\n            return this.googleAuth;\r\n        }\r\n        const { auth, client } = populateGoogleAuth(this.impersonatedServiceAccountPathOrObject, this.httpAgent);\r\n        this.googleAuth = auth;\r\n        this.authClient = client;\r\n        return this.googleAuth;\r\n    }\r\n    async getAccessToken() {\r\n        const googleAuth = this.getGoogleAuth();\r\n        if (this.authClient === undefined) {\r\n            this.authClient = await googleAuth.getClient();\r\n        }\r\n        await this.authClient.getAccessToken();\r\n        const credentials = this.authClient.credentials;\r\n        return populateCredential(credentials);\r\n    }\r\n}\r\nexports.ImpersonatedServiceAccountCredential = ImpersonatedServiceAccountCredential;\r\n/**\r\n * A helper class to validate the properties necessary to use impersonated service account credentials.\r\n */\r\nclass ImpersonatedServiceAccount {\r\n    /*\r\n     * Tries to load a ImpersonatedServiceAccount from a path. Throws if the path doesn't exist or the\r\n     * data at the path is invalid.\r\n     */\r\n    static validateFromPath(filePath) {\r\n        try {\r\n            ImpersonatedServiceAccount.validateFromJSON(JSON.parse(fs.readFileSync(filePath, 'utf8')));\r\n        }\r\n        catch (error) {\r\n            // Throw a nicely formed error message if the file contents cannot be parsed\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse impersonated service account file: ' + error);\r\n        }\r\n    }\r\n    static validateFromJSON(json) {\r\n        const { client_id: clientId, client_secret: clientSecret, refresh_token: refreshToken, type } = json['source_credentials'];\r\n        let errorMessage;\r\n        if (!util.isNonEmptyString(clientId)) {\r\n            errorMessage = 'Impersonated Service Account must contain a \"source_credentials.client_id\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(clientSecret)) {\r\n            errorMessage = 'Impersonated Service Account must contain a \"source_credentials.client_secret\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(refreshToken)) {\r\n            errorMessage = 'Impersonated Service Account must contain a \"source_credentials.refresh_token\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(type)) {\r\n            errorMessage = 'Impersonated Service Account must contain a \"source_credentials.type\" property.';\r\n        }\r\n        if (typeof errorMessage !== 'undefined') {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Checks if the given credential was loaded via the application default credentials mechanism.\r\n *\r\n * @param credential - The credential instance to check.\r\n */\r\nfunction isApplicationDefault(credential) {\r\n    return credential instanceof ApplicationDefaultCredential ||\r\n        (credential instanceof RefreshTokenCredential && credential.implicit);\r\n}\r\nfunction getApplicationDefault(httpAgent) {\r\n    return new ApplicationDefaultCredential(httpAgent);\r\n}\r\n/**\r\n * Copies the specified property from one object to another.\r\n *\r\n * If no property exists by the given \"key\", looks for a property identified by \"alt\", and copies it instead.\r\n * This can be used to implement behaviors such as \"copy property myKey or my_key\".\r\n *\r\n * @param to - Target object to copy the property into.\r\n * @param from - Source object to copy the property from.\r\n * @param key - Name of the property to copy.\r\n * @param alt - Alternative name of the property to copy.\r\n */\r\nfunction copyAttr(to, from, key, alt) {\r\n    const tmp = from[key] || from[alt];\r\n    if (typeof tmp !== 'undefined') {\r\n        to[key] = tmp;\r\n    }\r\n}\r\n/**\r\n * Populate google-auth-library GoogleAuth credentials type.\r\n */\r\nfunction populateGoogleAuth(keyFile, httpAgent) {\r\n    let client;\r\n    const auth = new google_auth_library_1.GoogleAuth({\r\n        scopes: SCOPES,\r\n        clientOptions: {\r\n            transporterOptions: {\r\n                agent: httpAgent,\r\n            },\r\n        },\r\n        keyFile: (typeof keyFile === 'string') ? keyFile : undefined,\r\n    });\r\n    if (typeof keyFile === 'object') {\r\n        if (!util.isNonNullObject(keyFile)) {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\r\n        }\r\n        copyAttr(keyFile, keyFile, 'project_id', 'projectId');\r\n        copyAttr(keyFile, keyFile, 'private_key', 'privateKey');\r\n        copyAttr(keyFile, keyFile, 'client_email', 'clientEmail');\r\n        client = auth.fromJSON(keyFile);\r\n    }\r\n    return { auth, client };\r\n}\r\n/**\r\n * Populate GoogleOAuthAccessToken credentials from google-auth-library Credentials type.\r\n */\r\nfunction populateCredential(credentials) {\r\n    const accessToken = credentials?.access_token;\r\n    const expiryDate = credentials?.expiry_date;\r\n    if (typeof accessToken !== 'string')\r\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse Google auth credential: access_token must be a non empty string.');\r\n    if (typeof expiryDate !== 'number')\r\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse Google auth credential: Invalid expiry_date.');\r\n    return {\r\n        ...credentials,\r\n        access_token: accessToken,\r\n        // inverse operation of following\r\n        // https://github.com/googleapis/google-auth-library-nodejs/blob/5ed910513451c82e2551777a3e2212964799ef8e/src/auth/baseexternalclient.ts#L446-L446\r\n        expires_in: Math.floor((expiryDate - new Date().getTime()) / 1000),\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}