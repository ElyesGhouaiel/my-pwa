{"ast":null,"code":"\"use strict\";\n\n// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;\nconst authclient_1 = require(\"./authclient\");\nconst oauth2common_1 = require(\"./oauth2common\");\nconst gaxios_1 = require(\"gaxios\");\nconst stream = require(\"stream\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n/**\r\n * The credentials JSON file type for external account authorized user clients.\r\n */\nexports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = 'external_account_authorized_user';\nconst DEFAULT_TOKEN_URL = 'https://sts.{universeDomain}/v1/oauthtoken';\n/**\r\n * Handler for token refresh requests sent to the token_url endpoint for external\r\n * authorized user credentials.\r\n */\nclass ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {\n  /**\r\n   * Initializes an ExternalAccountAuthorizedUserHandler instance.\r\n   * @param url The URL of the token refresh endpoint.\r\n   * @param transporter The transporter to use for the refresh request.\r\n   * @param clientAuthentication The client authentication credentials to use\r\n   *   for the refresh request.\r\n   */\n  constructor(url, transporter, clientAuthentication) {\n    super(clientAuthentication);\n    this.url = url;\n    this.transporter = transporter;\n  }\n  /**\r\n   * Requests a new access token from the token_url endpoint using the provided\r\n   *   refresh token.\r\n   * @param refreshToken The refresh token to use to generate a new access token.\r\n   * @param additionalHeaders Optional additional headers to pass along the\r\n   *   request.\r\n   * @return A promise that resolves with the token refresh response containing\r\n   *   the requested access token and its expiration time.\r\n   */\n  async refreshToken(refreshToken, additionalHeaders) {\n    const values = new URLSearchParams({\n      grant_type: 'refresh_token',\n      refresh_token: refreshToken\n    });\n    const headers = {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      ...additionalHeaders\n    };\n    const opts = {\n      ...ExternalAccountAuthorizedUserHandler.RETRY_CONFIG,\n      url: this.url,\n      method: 'POST',\n      headers,\n      data: values.toString(),\n      responseType: 'json'\n    };\n    // Apply OAuth client authentication.\n    this.applyClientAuthenticationOptions(opts);\n    try {\n      const response = await this.transporter.request(opts);\n      // Successful response.\n      const tokenRefreshResponse = response.data;\n      tokenRefreshResponse.res = response;\n      return tokenRefreshResponse;\n    } catch (error) {\n      // Translate error to OAuthError.\n      if (error instanceof gaxios_1.GaxiosError && error.response) {\n        throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data,\n        // Preserve other fields from the original error.\n        error);\n      }\n      // Request could fail before the server responds.\n      throw error;\n    }\n  }\n}\n/**\r\n * External Account Authorized User Client. This is used for OAuth2 credentials\r\n * sourced using external identities through Workforce Identity Federation.\r\n * Obtaining the initial access and refresh token can be done through the\r\n * Google Cloud CLI.\r\n */\nclass ExternalAccountAuthorizedUserClient extends authclient_1.AuthClient {\n  /**\r\n   * Instantiates an ExternalAccountAuthorizedUserClient instances using the\r\n   * provided JSON object loaded from a credentials files.\r\n   * An error is throws if the credential is not valid.\r\n   * @param options The external account authorized user option object typically\r\n   *   from the external accoutn authorized user JSON credential file.\r\n   * @param additionalOptions **DEPRECATED, all options are available in the\r\n   *   `options` parameter.** Optional additional behavior customization options.\r\n   *   These currently customize expiration threshold time and whether to retry\r\n   *   on 401/403 API request errors.\r\n   */\n  constructor(options, additionalOptions) {\n    var _a;\n    super({\n      ...options,\n      ...additionalOptions\n    });\n    if (options.universe_domain) {\n      this.universeDomain = options.universe_domain;\n    }\n    this.refreshToken = options.refresh_token;\n    const clientAuth = {\n      confidentialClientType: 'basic',\n      clientId: options.client_id,\n      clientSecret: options.client_secret\n    };\n    this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler((_a = options.token_url) !== null && _a !== void 0 ? _a : DEFAULT_TOKEN_URL.replace('{universeDomain}', this.universeDomain), this.transporter, clientAuth);\n    this.cachedAccessToken = null;\n    this.quotaProjectId = options.quota_project_id;\n    // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;\n    } else {\n      this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n    this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n  }\n  async getAccessToken() {\n    // If cached access token is unavailable or expired, force refresh.\n    if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n      await this.refreshAccessTokenAsync();\n    }\n    // Return GCP access token in GetAccessTokenResponse format.\n    return {\n      token: this.cachedAccessToken.access_token,\n      res: this.cachedAccessToken.res\n    };\n  }\n  async getRequestHeaders() {\n    const accessTokenResponse = await this.getAccessToken();\n    const headers = {\n      Authorization: `Bearer ${accessTokenResponse.token}`\n    };\n    return this.addSharedMetadataHeaders(headers);\n  }\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\r\n   * Authenticates the provided HTTP request, processes it and resolves with the\r\n   * returned response.\r\n   * @param opts The HTTP request options.\r\n   * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.\r\n   * @return A promise that resolves with the successful response.\r\n   */\n  async requestAsync(opts, reAuthRetried = false) {\n    let response;\n    try {\n      const requestHeaders = await this.getRequestHeaders();\n      opts.headers = opts.headers || {};\n      if (requestHeaders && requestHeaders['x-goog-user-project']) {\n        opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n      }\n      if (requestHeaders && requestHeaders.Authorization) {\n        opts.headers.Authorization = requestHeaders.Authorization;\n      }\n      response = await this.transporter.request(opts);\n    } catch (e) {\n      const res = e.response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - forceRefreshOnFailure is true\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n          await this.refreshAccessTokenAsync();\n          return await this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return response;\n  }\n  /**\r\n   * Forces token refresh, even if unexpired tokens are currently cached.\r\n   * @return A promise that resolves with the refreshed credential.\r\n   */\n  async refreshAccessTokenAsync() {\n    // Refresh the access token using the refresh token.\n    const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);\n    this.cachedAccessToken = {\n      access_token: refreshResponse.access_token,\n      expiry_date: new Date().getTime() + refreshResponse.expires_in * 1000,\n      res: refreshResponse.res\n    };\n    if (refreshResponse.refresh_token !== undefined) {\n      this.refreshToken = refreshResponse.refresh_token;\n    }\n    return this.cachedAccessToken;\n  }\n  /**\r\n   * Returns whether the provided credentials are expired or not.\r\n   * If there is no expiry time, assumes the token is not expired or expiring.\r\n   * @param credentials The credentials to check for expiration.\r\n   * @return Whether the credentials are expired or not.\r\n   */\n  isExpired(credentials) {\n    const now = new Date().getTime();\n    return credentials.expiry_date ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n}\nexports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;","map":{"version":3,"names":["Object","defineProperty","exports","value","ExternalAccountAuthorizedUserClient","EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE","authclient_1","require","oauth2common_1","gaxios_1","stream","baseexternalclient_1","DEFAULT_TOKEN_URL","ExternalAccountAuthorizedUserHandler","OAuthClientAuthHandler","constructor","url","transporter","clientAuthentication","refreshToken","additionalHeaders","values","URLSearchParams","grant_type","refresh_token","headers","opts","RETRY_CONFIG","method","data","toString","responseType","applyClientAuthenticationOptions","response","request","tokenRefreshResponse","res","error","GaxiosError","getErrorFromOAuthErrorResponse","AuthClient","options","additionalOptions","_a","universe_domain","universeDomain","clientAuth","confidentialClientType","clientId","client_id","clientSecret","client_secret","externalAccountAuthorizedUserHandler","token_url","replace","cachedAccessToken","quotaProjectId","quota_project_id","eagerRefreshThresholdMillis","EXPIRATION_TIME_OFFSET","forceRefreshOnFailure","getAccessToken","isExpired","refreshAccessTokenAsync","token","access_token","getRequestHeaders","accessTokenResponse","Authorization","addSharedMetadataHeaders","callback","requestAsync","then","r","e","reAuthRetried","requestHeaders","statusCode","status","isReadableStream","config","Readable","isAuthErr","refreshResponse","expiry_date","Date","getTime","expires_in","undefined","credentials","now"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js"],"sourcesContent":["\"use strict\";\r\n// Copyright 2023 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;\r\nconst authclient_1 = require(\"./authclient\");\r\nconst oauth2common_1 = require(\"./oauth2common\");\r\nconst gaxios_1 = require(\"gaxios\");\r\nconst stream = require(\"stream\");\r\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\r\n/**\r\n * The credentials JSON file type for external account authorized user clients.\r\n */\r\nexports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = 'external_account_authorized_user';\r\nconst DEFAULT_TOKEN_URL = 'https://sts.{universeDomain}/v1/oauthtoken';\r\n/**\r\n * Handler for token refresh requests sent to the token_url endpoint for external\r\n * authorized user credentials.\r\n */\r\nclass ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {\r\n    /**\r\n     * Initializes an ExternalAccountAuthorizedUserHandler instance.\r\n     * @param url The URL of the token refresh endpoint.\r\n     * @param transporter The transporter to use for the refresh request.\r\n     * @param clientAuthentication The client authentication credentials to use\r\n     *   for the refresh request.\r\n     */\r\n    constructor(url, transporter, clientAuthentication) {\r\n        super(clientAuthentication);\r\n        this.url = url;\r\n        this.transporter = transporter;\r\n    }\r\n    /**\r\n     * Requests a new access token from the token_url endpoint using the provided\r\n     *   refresh token.\r\n     * @param refreshToken The refresh token to use to generate a new access token.\r\n     * @param additionalHeaders Optional additional headers to pass along the\r\n     *   request.\r\n     * @return A promise that resolves with the token refresh response containing\r\n     *   the requested access token and its expiration time.\r\n     */\r\n    async refreshToken(refreshToken, additionalHeaders) {\r\n        const values = new URLSearchParams({\r\n            grant_type: 'refresh_token',\r\n            refresh_token: refreshToken,\r\n        });\r\n        const headers = {\r\n            'Content-Type': 'application/x-www-form-urlencoded',\r\n            ...additionalHeaders,\r\n        };\r\n        const opts = {\r\n            ...ExternalAccountAuthorizedUserHandler.RETRY_CONFIG,\r\n            url: this.url,\r\n            method: 'POST',\r\n            headers,\r\n            data: values.toString(),\r\n            responseType: 'json',\r\n        };\r\n        // Apply OAuth client authentication.\r\n        this.applyClientAuthenticationOptions(opts);\r\n        try {\r\n            const response = await this.transporter.request(opts);\r\n            // Successful response.\r\n            const tokenRefreshResponse = response.data;\r\n            tokenRefreshResponse.res = response;\r\n            return tokenRefreshResponse;\r\n        }\r\n        catch (error) {\r\n            // Translate error to OAuthError.\r\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\r\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, \r\n                // Preserve other fields from the original error.\r\n                error);\r\n            }\r\n            // Request could fail before the server responds.\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n/**\r\n * External Account Authorized User Client. This is used for OAuth2 credentials\r\n * sourced using external identities through Workforce Identity Federation.\r\n * Obtaining the initial access and refresh token can be done through the\r\n * Google Cloud CLI.\r\n */\r\nclass ExternalAccountAuthorizedUserClient extends authclient_1.AuthClient {\r\n    /**\r\n     * Instantiates an ExternalAccountAuthorizedUserClient instances using the\r\n     * provided JSON object loaded from a credentials files.\r\n     * An error is throws if the credential is not valid.\r\n     * @param options The external account authorized user option object typically\r\n     *   from the external accoutn authorized user JSON credential file.\r\n     * @param additionalOptions **DEPRECATED, all options are available in the\r\n     *   `options` parameter.** Optional additional behavior customization options.\r\n     *   These currently customize expiration threshold time and whether to retry\r\n     *   on 401/403 API request errors.\r\n     */\r\n    constructor(options, additionalOptions) {\r\n        var _a;\r\n        super({ ...options, ...additionalOptions });\r\n        if (options.universe_domain) {\r\n            this.universeDomain = options.universe_domain;\r\n        }\r\n        this.refreshToken = options.refresh_token;\r\n        const clientAuth = {\r\n            confidentialClientType: 'basic',\r\n            clientId: options.client_id,\r\n            clientSecret: options.client_secret,\r\n        };\r\n        this.externalAccountAuthorizedUserHandler =\r\n            new ExternalAccountAuthorizedUserHandler((_a = options.token_url) !== null && _a !== void 0 ? _a : DEFAULT_TOKEN_URL.replace('{universeDomain}', this.universeDomain), this.transporter, clientAuth);\r\n        this.cachedAccessToken = null;\r\n        this.quotaProjectId = options.quota_project_id;\r\n        // As threshold could be zero,\r\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\r\n        // zero value.\r\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\r\n            this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;\r\n        }\r\n        else {\r\n            this.eagerRefreshThresholdMillis = additionalOptions\r\n                .eagerRefreshThresholdMillis;\r\n        }\r\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\r\n    }\r\n    async getAccessToken() {\r\n        // If cached access token is unavailable or expired, force refresh.\r\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\r\n            await this.refreshAccessTokenAsync();\r\n        }\r\n        // Return GCP access token in GetAccessTokenResponse format.\r\n        return {\r\n            token: this.cachedAccessToken.access_token,\r\n            res: this.cachedAccessToken.res,\r\n        };\r\n    }\r\n    async getRequestHeaders() {\r\n        const accessTokenResponse = await this.getAccessToken();\r\n        const headers = {\r\n            Authorization: `Bearer ${accessTokenResponse.token}`,\r\n        };\r\n        return this.addSharedMetadataHeaders(headers);\r\n    }\r\n    request(opts, callback) {\r\n        if (callback) {\r\n            this.requestAsync(opts).then(r => callback(null, r), e => {\r\n                return callback(e, e.response);\r\n            });\r\n        }\r\n        else {\r\n            return this.requestAsync(opts);\r\n        }\r\n    }\r\n    /**\r\n     * Authenticates the provided HTTP request, processes it and resolves with the\r\n     * returned response.\r\n     * @param opts The HTTP request options.\r\n     * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.\r\n     * @return A promise that resolves with the successful response.\r\n     */\r\n    async requestAsync(opts, reAuthRetried = false) {\r\n        let response;\r\n        try {\r\n            const requestHeaders = await this.getRequestHeaders();\r\n            opts.headers = opts.headers || {};\r\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\r\n                opts.headers['x-goog-user-project'] =\r\n                    requestHeaders['x-goog-user-project'];\r\n            }\r\n            if (requestHeaders && requestHeaders.Authorization) {\r\n                opts.headers.Authorization = requestHeaders.Authorization;\r\n            }\r\n            response = await this.transporter.request(opts);\r\n        }\r\n        catch (e) {\r\n            const res = e.response;\r\n            if (res) {\r\n                const statusCode = res.status;\r\n                // Retry the request for metadata if the following criteria are true:\r\n                // - We haven't already retried.  It only makes sense to retry once.\r\n                // - The response was a 401 or a 403\r\n                // - The request didn't send a readableStream\r\n                // - forceRefreshOnFailure is true\r\n                const isReadableStream = res.config.data instanceof stream.Readable;\r\n                const isAuthErr = statusCode === 401 || statusCode === 403;\r\n                if (!reAuthRetried &&\r\n                    isAuthErr &&\r\n                    !isReadableStream &&\r\n                    this.forceRefreshOnFailure) {\r\n                    await this.refreshAccessTokenAsync();\r\n                    return await this.requestAsync(opts, true);\r\n                }\r\n            }\r\n            throw e;\r\n        }\r\n        return response;\r\n    }\r\n    /**\r\n     * Forces token refresh, even if unexpired tokens are currently cached.\r\n     * @return A promise that resolves with the refreshed credential.\r\n     */\r\n    async refreshAccessTokenAsync() {\r\n        // Refresh the access token using the refresh token.\r\n        const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);\r\n        this.cachedAccessToken = {\r\n            access_token: refreshResponse.access_token,\r\n            expiry_date: new Date().getTime() + refreshResponse.expires_in * 1000,\r\n            res: refreshResponse.res,\r\n        };\r\n        if (refreshResponse.refresh_token !== undefined) {\r\n            this.refreshToken = refreshResponse.refresh_token;\r\n        }\r\n        return this.cachedAccessToken;\r\n    }\r\n    /**\r\n     * Returns whether the provided credentials are expired or not.\r\n     * If there is no expiry time, assumes the token is not expired or expiring.\r\n     * @param credentials The credentials to check for expiration.\r\n     * @return Whether the credentials are expired or not.\r\n     */\r\n    isExpired(credentials) {\r\n        const now = new Date().getTime();\r\n        return credentials.expiry_date\r\n            ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis\r\n            : false;\r\n    }\r\n}\r\nexports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}