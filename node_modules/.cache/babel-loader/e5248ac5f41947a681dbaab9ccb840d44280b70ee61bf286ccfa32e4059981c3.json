{"ast":null,"code":"/*! firebase-admin v13.0.1 */\n\"use strict\";\n\n/*!\r\n * Copyright 2019 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecurityRules = exports.Ruleset = exports.RulesetMetadataList = void 0;\nconst validator = require(\"../utils/validator\");\nconst security_rules_api_client_internal_1 = require(\"./security-rules-api-client-internal\");\nconst security_rules_internal_1 = require(\"./security-rules-internal\");\n/**\r\n * A page of ruleset metadata.\r\n */\nclass RulesetMetadataList {\n  /**\r\n   * @internal\r\n   */\n  constructor(response) {\n    if (!validator.isNonNullObject(response) || !validator.isArray(response.rulesets)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid ListRulesets response: ${JSON.stringify(response)}`);\n    }\n    this.rulesets = response.rulesets.map(rs => {\n      return {\n        name: stripProjectIdPrefix(rs.name),\n        createTime: new Date(rs.createTime).toUTCString()\n      };\n    });\n    if (response.nextPageToken) {\n      this.nextPageToken = response.nextPageToken;\n    }\n  }\n}\nexports.RulesetMetadataList = RulesetMetadataList;\n/**\r\n * A set of Firebase security rules.\r\n */\nclass Ruleset {\n  /**\r\n   * @internal\r\n   */\n  constructor(ruleset) {\n    if (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name) || !validator.isNonEmptyString(ruleset.createTime) || !validator.isNonNullObject(ruleset.source)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid Ruleset response: ${JSON.stringify(ruleset)}`);\n    }\n    this.name = stripProjectIdPrefix(ruleset.name);\n    this.createTime = new Date(ruleset.createTime).toUTCString();\n    this.source = ruleset.source.files || [];\n  }\n}\nexports.Ruleset = Ruleset;\n/**\r\n * The Firebase `SecurityRules` service interface.\r\n */\nclass SecurityRules {\n  /**\r\n   * @param app - The app for this SecurityRules service.\r\n   * @constructor\r\n   * @internal\r\n   */\n  constructor(app) {\n    this.app = app;\n    this.client = new security_rules_api_client_internal_1.SecurityRulesApiClient(app);\n  }\n  /**\r\n   * Gets the {@link Ruleset} identified by the given\r\n   * name. The input name should be the short name string without the project ID\r\n   * prefix. For example, to retrieve the `projects/project-id/rulesets/my-ruleset`,\r\n   * pass the short name \"my-ruleset\". Rejects with a `not-found` error if the\r\n   * specified `Ruleset` cannot be found.\r\n   *\r\n   * @param name - Name of the `Ruleset` to retrieve.\r\n   * @returns A promise that fulfills with the specified `Ruleset`.\r\n   */\n  getRuleset(name) {\n    return this.client.getRuleset(name).then(rulesetResponse => {\n      return new Ruleset(rulesetResponse);\n    });\n  }\n  /**\r\n   * Gets the {@link Ruleset} currently applied to\r\n   * Cloud Firestore. Rejects with a `not-found` error if no ruleset is applied\r\n   * on Firestore.\r\n   *\r\n   * @returns A promise that fulfills with the Firestore ruleset.\r\n   */\n  getFirestoreRuleset() {\n    return this.getRulesetForRelease(SecurityRules.CLOUD_FIRESTORE);\n  }\n  /**\r\n   * Creates a new {@link Ruleset} from the given\r\n   * source, and applies it to Cloud Firestore.\r\n   *\r\n   * @param source - Rules source to apply.\r\n   * @returns A promise that fulfills when the ruleset is created and released.\r\n   */\n  releaseFirestoreRulesetFromSource(source) {\n    return Promise.resolve().then(() => {\n      const rulesFile = this.createRulesFileFromSource('firestore.rules', source);\n      return this.createRuleset(rulesFile);\n    }).then(ruleset => {\n      return this.releaseFirestoreRuleset(ruleset).then(() => {\n        return ruleset;\n      });\n    });\n  }\n  /**\r\n   * Applies the specified {@link Ruleset} ruleset\r\n   * to Cloud Firestore.\r\n   *\r\n   * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object\r\n   *   containing the name.\r\n   * @returns A promise that fulfills when the ruleset is released.\r\n   */\n  releaseFirestoreRuleset(ruleset) {\n    return this.releaseRuleset(ruleset, SecurityRules.CLOUD_FIRESTORE);\n  }\n  /**\r\n   * Gets the {@link Ruleset} currently applied to a\r\n   * Cloud Storage bucket. Rejects with a `not-found` error if no ruleset is applied\r\n   * on the bucket.\r\n   *\r\n   * @param bucket - Optional name of the Cloud Storage bucket to be retrieved. If not\r\n   *   specified, retrieves the ruleset applied on the default bucket configured via\r\n   *   `AppOptions`.\r\n   * @returns A promise that fulfills with the Cloud Storage ruleset.\r\n   */\n  getStorageRuleset(bucket) {\n    return Promise.resolve().then(() => {\n      return this.getBucketName(bucket);\n    }).then(bucketName => {\n      return this.getRulesetForRelease(`${SecurityRules.FIREBASE_STORAGE}/${bucketName}`);\n    });\n  }\n  /**\r\n   * Creates a new {@link Ruleset} from the given\r\n   * source, and applies it to a Cloud Storage bucket.\r\n   *\r\n   * @param source - Rules source to apply.\r\n   * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If\r\n   *   not specified, applies the ruleset on the default bucket configured via\r\n   *   {@link firebase-admin.app#AppOptions}.\r\n   * @returns A promise that fulfills when the ruleset is created and released.\r\n   */\n  releaseStorageRulesetFromSource(source, bucket) {\n    return Promise.resolve().then(() => {\n      // Bucket name is not required until the last step. But since there's a createRuleset step\n      // before then, make sure to run this check and fail early if the bucket name is invalid.\n      this.getBucketName(bucket);\n      const rulesFile = this.createRulesFileFromSource('storage.rules', source);\n      return this.createRuleset(rulesFile);\n    }).then(ruleset => {\n      return this.releaseStorageRuleset(ruleset, bucket).then(() => {\n        return ruleset;\n      });\n    });\n  }\n  /**\r\n   * Applies the specified {@link Ruleset} ruleset\r\n   * to a Cloud Storage bucket.\r\n   *\r\n   * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object\r\n   *   containing the name.\r\n   * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If\r\n   *   not specified, applies the ruleset on the default bucket configured via\r\n   *   {@link firebase-admin.app#AppOptions}.\r\n   * @returns A promise that fulfills when the ruleset is released.\r\n   */\n  releaseStorageRuleset(ruleset, bucket) {\n    return Promise.resolve().then(() => {\n      return this.getBucketName(bucket);\n    }).then(bucketName => {\n      return this.releaseRuleset(ruleset, `${SecurityRules.FIREBASE_STORAGE}/${bucketName}`);\n    });\n  }\n  /**\r\n   * Creates a {@link RulesFile} with the given name\r\n   * and source. Throws an error if any of the arguments are invalid. This is a local\r\n   * operation, and does not involve any network API calls.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * const source = '// Some rules source';\r\n   * const rulesFile = admin.securityRules().createRulesFileFromSource(\r\n   *   'firestore.rules', source);\r\n   * ```\r\n   *\r\n   * @param name - Name to assign to the rules file. This is usually a short file name that\r\n   *   helps identify the file in a ruleset.\r\n   * @param source - Contents of the rules file.\r\n   * @returns A new rules file instance.\r\n   */\n  createRulesFileFromSource(name, source) {\n    if (!validator.isNonEmptyString(name)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Name must be a non-empty string.');\n    }\n    let content;\n    if (validator.isNonEmptyString(source)) {\n      content = source;\n    } else if (validator.isBuffer(source)) {\n      content = source.toString('utf-8');\n    } else {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Source must be a non-empty string or a Buffer.');\n    }\n    return {\n      name,\n      content\n    };\n  }\n  /**\r\n   * Creates a new {@link Ruleset} from the given {@link RulesFile}.\r\n   *\r\n   * @param file - Rules file to include in the new `Ruleset`.\r\n   * @returns A promise that fulfills with the newly created `Ruleset`.\r\n   */\n  createRuleset(file) {\n    const ruleset = {\n      source: {\n        files: [file]\n      }\n    };\n    return this.client.createRuleset(ruleset).then(rulesetResponse => {\n      return new Ruleset(rulesetResponse);\n    });\n  }\n  /**\r\n   * Deletes the {@link Ruleset} identified by the given\r\n   * name. The input name should be the short name string without the project ID\r\n   * prefix. For example, to delete the `projects/project-id/rulesets/my-ruleset`,\r\n   * pass the  short name \"my-ruleset\". Rejects with a `not-found` error if the\r\n   * specified `Ruleset` cannot be found.\r\n   *\r\n   * @param name - Name of the `Ruleset` to delete.\r\n   * @returns A promise that fulfills when the `Ruleset` is deleted.\r\n   */\n  deleteRuleset(name) {\n    return this.client.deleteRuleset(name);\n  }\n  /**\r\n   * Retrieves a page of ruleset metadata.\r\n   *\r\n   * @param pageSize - The page size, 100 if undefined. This is also the maximum allowed\r\n   *   limit.\r\n   * @param nextPageToken - The next page token. If not specified, returns rulesets\r\n   *   starting without any offset.\r\n   * @returns A promise that fulfills with a page of rulesets.\r\n   */\n  listRulesetMetadata(pageSize = 100, nextPageToken) {\n    return this.client.listRulesets(pageSize, nextPageToken).then(response => {\n      return new RulesetMetadataList(response);\n    });\n  }\n  getRulesetForRelease(releaseName) {\n    return this.client.getRelease(releaseName).then(release => {\n      const rulesetName = release.rulesetName;\n      if (!validator.isNonEmptyString(rulesetName)) {\n        throw new security_rules_internal_1.FirebaseSecurityRulesError('not-found', `Ruleset name not found for ${releaseName}.`);\n      }\n      return this.getRuleset(stripProjectIdPrefix(rulesetName));\n    });\n  }\n  releaseRuleset(ruleset, releaseName) {\n    if (!validator.isNonEmptyString(ruleset) && (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name))) {\n      const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'ruleset must be a non-empty name or a RulesetMetadata object.');\n      return Promise.reject(err);\n    }\n    const rulesetName = validator.isString(ruleset) ? ruleset : ruleset.name;\n    return this.client.updateOrCreateRelease(releaseName, rulesetName).then(() => {\n      return;\n    });\n  }\n  getBucketName(bucket) {\n    const bucketName = typeof bucket !== 'undefined' ? bucket : this.app.options.storageBucket;\n    if (!validator.isNonEmptyString(bucketName)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Bucket name not specified or invalid. Specify a default bucket name via the ' + 'storageBucket option when initializing the app, or specify the bucket name ' + 'explicitly when calling the rules API.');\n    }\n    return bucketName;\n  }\n}\nexports.SecurityRules = SecurityRules;\nSecurityRules.CLOUD_FIRESTORE = 'cloud.firestore';\nSecurityRules.FIREBASE_STORAGE = 'firebase.storage';\nfunction stripProjectIdPrefix(name) {\n  return name.split('/').pop();\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","SecurityRules","Ruleset","RulesetMetadataList","validator","require","security_rules_api_client_internal_1","security_rules_internal_1","constructor","response","isNonNullObject","isArray","rulesets","FirebaseSecurityRulesError","JSON","stringify","map","rs","name","stripProjectIdPrefix","createTime","Date","toUTCString","nextPageToken","ruleset","isNonEmptyString","source","files","app","client","SecurityRulesApiClient","getRuleset","then","rulesetResponse","getFirestoreRuleset","getRulesetForRelease","CLOUD_FIRESTORE","releaseFirestoreRulesetFromSource","Promise","resolve","rulesFile","createRulesFileFromSource","createRuleset","releaseFirestoreRuleset","releaseRuleset","getStorageRuleset","bucket","getBucketName","bucketName","FIREBASE_STORAGE","releaseStorageRulesetFromSource","releaseStorageRuleset","content","isBuffer","toString","file","deleteRuleset","listRulesetMetadata","pageSize","listRulesets","releaseName","getRelease","release","rulesetName","err","reject","isString","updateOrCreateRelease","options","storageBucket","split","pop"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/firebase-admin/lib/security-rules/security-rules.js"],"sourcesContent":["/*! firebase-admin v13.0.1 */\r\n\"use strict\";\r\n/*!\r\n * Copyright 2019 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SecurityRules = exports.Ruleset = exports.RulesetMetadataList = void 0;\r\nconst validator = require(\"../utils/validator\");\r\nconst security_rules_api_client_internal_1 = require(\"./security-rules-api-client-internal\");\r\nconst security_rules_internal_1 = require(\"./security-rules-internal\");\r\n/**\r\n * A page of ruleset metadata.\r\n */\r\nclass RulesetMetadataList {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(response) {\r\n        if (!validator.isNonNullObject(response) || !validator.isArray(response.rulesets)) {\r\n            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid ListRulesets response: ${JSON.stringify(response)}`);\r\n        }\r\n        this.rulesets = response.rulesets.map((rs) => {\r\n            return {\r\n                name: stripProjectIdPrefix(rs.name),\r\n                createTime: new Date(rs.createTime).toUTCString(),\r\n            };\r\n        });\r\n        if (response.nextPageToken) {\r\n            this.nextPageToken = response.nextPageToken;\r\n        }\r\n    }\r\n}\r\nexports.RulesetMetadataList = RulesetMetadataList;\r\n/**\r\n * A set of Firebase security rules.\r\n */\r\nclass Ruleset {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(ruleset) {\r\n        if (!validator.isNonNullObject(ruleset) ||\r\n            !validator.isNonEmptyString(ruleset.name) ||\r\n            !validator.isNonEmptyString(ruleset.createTime) ||\r\n            !validator.isNonNullObject(ruleset.source)) {\r\n            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid Ruleset response: ${JSON.stringify(ruleset)}`);\r\n        }\r\n        this.name = stripProjectIdPrefix(ruleset.name);\r\n        this.createTime = new Date(ruleset.createTime).toUTCString();\r\n        this.source = ruleset.source.files || [];\r\n    }\r\n}\r\nexports.Ruleset = Ruleset;\r\n/**\r\n * The Firebase `SecurityRules` service interface.\r\n */\r\nclass SecurityRules {\r\n    /**\r\n     * @param app - The app for this SecurityRules service.\r\n     * @constructor\r\n     * @internal\r\n     */\r\n    constructor(app) {\r\n        this.app = app;\r\n        this.client = new security_rules_api_client_internal_1.SecurityRulesApiClient(app);\r\n    }\r\n    /**\r\n     * Gets the {@link Ruleset} identified by the given\r\n     * name. The input name should be the short name string without the project ID\r\n     * prefix. For example, to retrieve the `projects/project-id/rulesets/my-ruleset`,\r\n     * pass the short name \"my-ruleset\". Rejects with a `not-found` error if the\r\n     * specified `Ruleset` cannot be found.\r\n     *\r\n     * @param name - Name of the `Ruleset` to retrieve.\r\n     * @returns A promise that fulfills with the specified `Ruleset`.\r\n     */\r\n    getRuleset(name) {\r\n        return this.client.getRuleset(name)\r\n            .then((rulesetResponse) => {\r\n            return new Ruleset(rulesetResponse);\r\n        });\r\n    }\r\n    /**\r\n     * Gets the {@link Ruleset} currently applied to\r\n     * Cloud Firestore. Rejects with a `not-found` error if no ruleset is applied\r\n     * on Firestore.\r\n     *\r\n     * @returns A promise that fulfills with the Firestore ruleset.\r\n     */\r\n    getFirestoreRuleset() {\r\n        return this.getRulesetForRelease(SecurityRules.CLOUD_FIRESTORE);\r\n    }\r\n    /**\r\n     * Creates a new {@link Ruleset} from the given\r\n     * source, and applies it to Cloud Firestore.\r\n     *\r\n     * @param source - Rules source to apply.\r\n     * @returns A promise that fulfills when the ruleset is created and released.\r\n     */\r\n    releaseFirestoreRulesetFromSource(source) {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n            const rulesFile = this.createRulesFileFromSource('firestore.rules', source);\r\n            return this.createRuleset(rulesFile);\r\n        })\r\n            .then((ruleset) => {\r\n            return this.releaseFirestoreRuleset(ruleset)\r\n                .then(() => {\r\n                return ruleset;\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Applies the specified {@link Ruleset} ruleset\r\n     * to Cloud Firestore.\r\n     *\r\n     * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object\r\n     *   containing the name.\r\n     * @returns A promise that fulfills when the ruleset is released.\r\n     */\r\n    releaseFirestoreRuleset(ruleset) {\r\n        return this.releaseRuleset(ruleset, SecurityRules.CLOUD_FIRESTORE);\r\n    }\r\n    /**\r\n     * Gets the {@link Ruleset} currently applied to a\r\n     * Cloud Storage bucket. Rejects with a `not-found` error if no ruleset is applied\r\n     * on the bucket.\r\n     *\r\n     * @param bucket - Optional name of the Cloud Storage bucket to be retrieved. If not\r\n     *   specified, retrieves the ruleset applied on the default bucket configured via\r\n     *   `AppOptions`.\r\n     * @returns A promise that fulfills with the Cloud Storage ruleset.\r\n     */\r\n    getStorageRuleset(bucket) {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n            return this.getBucketName(bucket);\r\n        })\r\n            .then((bucketName) => {\r\n            return this.getRulesetForRelease(`${SecurityRules.FIREBASE_STORAGE}/${bucketName}`);\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new {@link Ruleset} from the given\r\n     * source, and applies it to a Cloud Storage bucket.\r\n     *\r\n     * @param source - Rules source to apply.\r\n     * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If\r\n     *   not specified, applies the ruleset on the default bucket configured via\r\n     *   {@link firebase-admin.app#AppOptions}.\r\n     * @returns A promise that fulfills when the ruleset is created and released.\r\n     */\r\n    releaseStorageRulesetFromSource(source, bucket) {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n            // Bucket name is not required until the last step. But since there's a createRuleset step\r\n            // before then, make sure to run this check and fail early if the bucket name is invalid.\r\n            this.getBucketName(bucket);\r\n            const rulesFile = this.createRulesFileFromSource('storage.rules', source);\r\n            return this.createRuleset(rulesFile);\r\n        })\r\n            .then((ruleset) => {\r\n            return this.releaseStorageRuleset(ruleset, bucket)\r\n                .then(() => {\r\n                return ruleset;\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Applies the specified {@link Ruleset} ruleset\r\n     * to a Cloud Storage bucket.\r\n     *\r\n     * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object\r\n     *   containing the name.\r\n     * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If\r\n     *   not specified, applies the ruleset on the default bucket configured via\r\n     *   {@link firebase-admin.app#AppOptions}.\r\n     * @returns A promise that fulfills when the ruleset is released.\r\n     */\r\n    releaseStorageRuleset(ruleset, bucket) {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n            return this.getBucketName(bucket);\r\n        })\r\n            .then((bucketName) => {\r\n            return this.releaseRuleset(ruleset, `${SecurityRules.FIREBASE_STORAGE}/${bucketName}`);\r\n        });\r\n    }\r\n    /**\r\n     * Creates a {@link RulesFile} with the given name\r\n     * and source. Throws an error if any of the arguments are invalid. This is a local\r\n     * operation, and does not involve any network API calls.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const source = '// Some rules source';\r\n     * const rulesFile = admin.securityRules().createRulesFileFromSource(\r\n     *   'firestore.rules', source);\r\n     * ```\r\n     *\r\n     * @param name - Name to assign to the rules file. This is usually a short file name that\r\n     *   helps identify the file in a ruleset.\r\n     * @param source - Contents of the rules file.\r\n     * @returns A new rules file instance.\r\n     */\r\n    createRulesFileFromSource(name, source) {\r\n        if (!validator.isNonEmptyString(name)) {\r\n            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Name must be a non-empty string.');\r\n        }\r\n        let content;\r\n        if (validator.isNonEmptyString(source)) {\r\n            content = source;\r\n        }\r\n        else if (validator.isBuffer(source)) {\r\n            content = source.toString('utf-8');\r\n        }\r\n        else {\r\n            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Source must be a non-empty string or a Buffer.');\r\n        }\r\n        return {\r\n            name,\r\n            content,\r\n        };\r\n    }\r\n    /**\r\n     * Creates a new {@link Ruleset} from the given {@link RulesFile}.\r\n     *\r\n     * @param file - Rules file to include in the new `Ruleset`.\r\n     * @returns A promise that fulfills with the newly created `Ruleset`.\r\n     */\r\n    createRuleset(file) {\r\n        const ruleset = {\r\n            source: {\r\n                files: [file],\r\n            },\r\n        };\r\n        return this.client.createRuleset(ruleset)\r\n            .then((rulesetResponse) => {\r\n            return new Ruleset(rulesetResponse);\r\n        });\r\n    }\r\n    /**\r\n     * Deletes the {@link Ruleset} identified by the given\r\n     * name. The input name should be the short name string without the project ID\r\n     * prefix. For example, to delete the `projects/project-id/rulesets/my-ruleset`,\r\n     * pass the  short name \"my-ruleset\". Rejects with a `not-found` error if the\r\n     * specified `Ruleset` cannot be found.\r\n     *\r\n     * @param name - Name of the `Ruleset` to delete.\r\n     * @returns A promise that fulfills when the `Ruleset` is deleted.\r\n     */\r\n    deleteRuleset(name) {\r\n        return this.client.deleteRuleset(name);\r\n    }\r\n    /**\r\n     * Retrieves a page of ruleset metadata.\r\n     *\r\n     * @param pageSize - The page size, 100 if undefined. This is also the maximum allowed\r\n     *   limit.\r\n     * @param nextPageToken - The next page token. If not specified, returns rulesets\r\n     *   starting without any offset.\r\n     * @returns A promise that fulfills with a page of rulesets.\r\n     */\r\n    listRulesetMetadata(pageSize = 100, nextPageToken) {\r\n        return this.client.listRulesets(pageSize, nextPageToken)\r\n            .then((response) => {\r\n            return new RulesetMetadataList(response);\r\n        });\r\n    }\r\n    getRulesetForRelease(releaseName) {\r\n        return this.client.getRelease(releaseName)\r\n            .then((release) => {\r\n            const rulesetName = release.rulesetName;\r\n            if (!validator.isNonEmptyString(rulesetName)) {\r\n                throw new security_rules_internal_1.FirebaseSecurityRulesError('not-found', `Ruleset name not found for ${releaseName}.`);\r\n            }\r\n            return this.getRuleset(stripProjectIdPrefix(rulesetName));\r\n        });\r\n    }\r\n    releaseRuleset(ruleset, releaseName) {\r\n        if (!validator.isNonEmptyString(ruleset) &&\r\n            (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name))) {\r\n            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'ruleset must be a non-empty name or a RulesetMetadata object.');\r\n            return Promise.reject(err);\r\n        }\r\n        const rulesetName = validator.isString(ruleset) ? ruleset : ruleset.name;\r\n        return this.client.updateOrCreateRelease(releaseName, rulesetName)\r\n            .then(() => {\r\n            return;\r\n        });\r\n    }\r\n    getBucketName(bucket) {\r\n        const bucketName = (typeof bucket !== 'undefined') ? bucket : this.app.options.storageBucket;\r\n        if (!validator.isNonEmptyString(bucketName)) {\r\n            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Bucket name not specified or invalid. Specify a default bucket name via the ' +\r\n                'storageBucket option when initializing the app, or specify the bucket name ' +\r\n                'explicitly when calling the rules API.');\r\n        }\r\n        return bucketName;\r\n    }\r\n}\r\nexports.SecurityRules = SecurityRules;\r\nSecurityRules.CLOUD_FIRESTORE = 'cloud.firestore';\r\nSecurityRules.FIREBASE_STORAGE = 'firebase.storage';\r\nfunction stripProjectIdPrefix(name) {\r\n    return name.split('/').pop();\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}