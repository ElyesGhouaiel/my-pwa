{"ast":null,"code":"/**\r\n * Hash-based Message Authentication Code implementation. Requires a message\r\n * digest object that can be obtained, for example, from forge.md.sha1 or\r\n * forge.md.md5.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.\r\n */\nvar forge = require('./forge');\nrequire('./md');\nrequire('./util');\n\n/* HMAC API */\nvar hmac = module.exports = forge.hmac = forge.hmac || {};\n\n/**\r\n * Creates an HMAC object that uses the given message digest object.\r\n *\r\n * @return an HMAC object.\r\n */\nhmac.create = function () {\n  // the hmac key to use\n  var _key = null;\n\n  // the message digest to use\n  var _md = null;\n\n  // the inner padding\n  var _ipadding = null;\n\n  // the outer padding\n  var _opadding = null;\n\n  // hmac context\n  var ctx = {};\n\n  /**\r\n   * Starts or restarts the HMAC with the given key and message digest.\r\n   *\r\n   * @param md the message digest to use, null to reuse the previous one,\r\n   *           a string to use builtin 'sha1', 'md5', 'sha256'.\r\n   * @param key the key to use as a string, array of bytes, byte buffer,\r\n   *           or null to reuse the previous key.\r\n   */\n  ctx.start = function (md, key) {\n    if (md !== null) {\n      if (typeof md === 'string') {\n        // create builtin message digest\n        md = md.toLowerCase();\n        if (md in forge.md.algorithms) {\n          _md = forge.md.algorithms[md].create();\n        } else {\n          throw new Error('Unknown hash algorithm \"' + md + '\"');\n        }\n      } else {\n        // store message digest\n        _md = md;\n      }\n    }\n    if (key === null) {\n      // reuse previous key\n      key = _key;\n    } else {\n      if (typeof key === 'string') {\n        // convert string into byte buffer\n        key = forge.util.createBuffer(key);\n      } else if (forge.util.isArray(key)) {\n        // convert byte array into byte buffer\n        var tmp = key;\n        key = forge.util.createBuffer();\n        for (var i = 0; i < tmp.length; ++i) {\n          key.putByte(tmp[i]);\n        }\n      }\n\n      // if key is longer than blocksize, hash it\n      var keylen = key.length();\n      if (keylen > _md.blockLength) {\n        _md.start();\n        _md.update(key.bytes());\n        key = _md.digest();\n      }\n\n      // mix key into inner and outer padding\n      // ipadding = [0x36 * blocksize] ^ key\n      // opadding = [0x5C * blocksize] ^ key\n      _ipadding = forge.util.createBuffer();\n      _opadding = forge.util.createBuffer();\n      keylen = key.length();\n      for (var i = 0; i < keylen; ++i) {\n        var tmp = key.at(i);\n        _ipadding.putByte(0x36 ^ tmp);\n        _opadding.putByte(0x5C ^ tmp);\n      }\n\n      // if key is shorter than blocksize, add additional padding\n      if (keylen < _md.blockLength) {\n        var tmp = _md.blockLength - keylen;\n        for (var i = 0; i < tmp; ++i) {\n          _ipadding.putByte(0x36);\n          _opadding.putByte(0x5C);\n        }\n      }\n      _key = key;\n      _ipadding = _ipadding.bytes();\n      _opadding = _opadding.bytes();\n    }\n\n    // digest is done like so: hash(opadding | hash(ipadding | message))\n\n    // prepare to do inner hash\n    // hash(ipadding | message)\n    _md.start();\n    _md.update(_ipadding);\n  };\n\n  /**\r\n   * Updates the HMAC with the given message bytes.\r\n   *\r\n   * @param bytes the bytes to update with.\r\n   */\n  ctx.update = function (bytes) {\n    _md.update(bytes);\n  };\n\n  /**\r\n   * Produces the Message Authentication Code (MAC).\r\n   *\r\n   * @return a byte buffer containing the digest value.\r\n   */\n  ctx.getMac = function () {\n    // digest is done like so: hash(opadding | hash(ipadding | message))\n    // here we do the outer hashing\n    var inner = _md.digest().bytes();\n    _md.start();\n    _md.update(_opadding);\n    _md.update(inner);\n    return _md.digest();\n  };\n  // alias for getMac\n  ctx.digest = ctx.getMac;\n  return ctx;\n};","map":{"version":3,"names":["forge","require","hmac","module","exports","create","_key","_md","_ipadding","_opadding","ctx","start","md","key","toLowerCase","algorithms","Error","util","createBuffer","isArray","tmp","i","length","putByte","keylen","blockLength","update","bytes","digest","at","getMac","inner"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/node-forge/lib/hmac.js"],"sourcesContent":["/**\r\n * Hash-based Message Authentication Code implementation. Requires a message\r\n * digest object that can be obtained, for example, from forge.md.sha1 or\r\n * forge.md.md5.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.\r\n */\r\nvar forge = require('./forge');\r\nrequire('./md');\r\nrequire('./util');\r\n\r\n/* HMAC API */\r\nvar hmac = module.exports = forge.hmac = forge.hmac || {};\r\n\r\n/**\r\n * Creates an HMAC object that uses the given message digest object.\r\n *\r\n * @return an HMAC object.\r\n */\r\nhmac.create = function() {\r\n  // the hmac key to use\r\n  var _key = null;\r\n\r\n  // the message digest to use\r\n  var _md = null;\r\n\r\n  // the inner padding\r\n  var _ipadding = null;\r\n\r\n  // the outer padding\r\n  var _opadding = null;\r\n\r\n  // hmac context\r\n  var ctx = {};\r\n\r\n  /**\r\n   * Starts or restarts the HMAC with the given key and message digest.\r\n   *\r\n   * @param md the message digest to use, null to reuse the previous one,\r\n   *           a string to use builtin 'sha1', 'md5', 'sha256'.\r\n   * @param key the key to use as a string, array of bytes, byte buffer,\r\n   *           or null to reuse the previous key.\r\n   */\r\n  ctx.start = function(md, key) {\r\n    if(md !== null) {\r\n      if(typeof md === 'string') {\r\n        // create builtin message digest\r\n        md = md.toLowerCase();\r\n        if(md in forge.md.algorithms) {\r\n          _md = forge.md.algorithms[md].create();\r\n        } else {\r\n          throw new Error('Unknown hash algorithm \"' + md + '\"');\r\n        }\r\n      } else {\r\n        // store message digest\r\n        _md = md;\r\n      }\r\n    }\r\n\r\n    if(key === null) {\r\n      // reuse previous key\r\n      key = _key;\r\n    } else {\r\n      if(typeof key === 'string') {\r\n        // convert string into byte buffer\r\n        key = forge.util.createBuffer(key);\r\n      } else if(forge.util.isArray(key)) {\r\n        // convert byte array into byte buffer\r\n        var tmp = key;\r\n        key = forge.util.createBuffer();\r\n        for(var i = 0; i < tmp.length; ++i) {\r\n          key.putByte(tmp[i]);\r\n        }\r\n      }\r\n\r\n      // if key is longer than blocksize, hash it\r\n      var keylen = key.length();\r\n      if(keylen > _md.blockLength) {\r\n        _md.start();\r\n        _md.update(key.bytes());\r\n        key = _md.digest();\r\n      }\r\n\r\n      // mix key into inner and outer padding\r\n      // ipadding = [0x36 * blocksize] ^ key\r\n      // opadding = [0x5C * blocksize] ^ key\r\n      _ipadding = forge.util.createBuffer();\r\n      _opadding = forge.util.createBuffer();\r\n      keylen = key.length();\r\n      for(var i = 0; i < keylen; ++i) {\r\n        var tmp = key.at(i);\r\n        _ipadding.putByte(0x36 ^ tmp);\r\n        _opadding.putByte(0x5C ^ tmp);\r\n      }\r\n\r\n      // if key is shorter than blocksize, add additional padding\r\n      if(keylen < _md.blockLength) {\r\n        var tmp = _md.blockLength - keylen;\r\n        for(var i = 0; i < tmp; ++i) {\r\n          _ipadding.putByte(0x36);\r\n          _opadding.putByte(0x5C);\r\n        }\r\n      }\r\n      _key = key;\r\n      _ipadding = _ipadding.bytes();\r\n      _opadding = _opadding.bytes();\r\n    }\r\n\r\n    // digest is done like so: hash(opadding | hash(ipadding | message))\r\n\r\n    // prepare to do inner hash\r\n    // hash(ipadding | message)\r\n    _md.start();\r\n    _md.update(_ipadding);\r\n  };\r\n\r\n  /**\r\n   * Updates the HMAC with the given message bytes.\r\n   *\r\n   * @param bytes the bytes to update with.\r\n   */\r\n  ctx.update = function(bytes) {\r\n    _md.update(bytes);\r\n  };\r\n\r\n  /**\r\n   * Produces the Message Authentication Code (MAC).\r\n   *\r\n   * @return a byte buffer containing the digest value.\r\n   */\r\n  ctx.getMac = function() {\r\n    // digest is done like so: hash(opadding | hash(ipadding | message))\r\n    // here we do the outer hashing\r\n    var inner = _md.digest().bytes();\r\n    _md.start();\r\n    _md.update(_opadding);\r\n    _md.update(inner);\r\n    return _md.digest();\r\n  };\r\n  // alias for getMac\r\n  ctx.digest = ctx.getMac;\r\n\r\n  return ctx;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}