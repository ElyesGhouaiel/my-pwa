{"ast":null,"code":"\"use strict\";\n\n/*!\r\n * Copyright 2018 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Timestamp = void 0;\nconst validate_1 = require(\"./validate\");\n/*!\r\n * Number of nanoseconds in a millisecond.\r\n *\r\n * @type {number}\r\n */\nconst MS_TO_NANOS = 1000000;\n/*!\r\n * The minimum legal value for the \"seconds\" property of a Timestamp object.\r\n *\r\n * This value corresponds to 0001-01-01T00:00:00Z.\r\n *\r\n * @type {number}\r\n */\nconst MIN_SECONDS = -62135596800;\n/*!\r\n * The maximum legal value for the \"seconds\" property of a Timestamp object.\r\n *\r\n * This value corresponds to 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * @type {number}\r\n */\nconst MAX_SECONDS = 253402300799;\n/**\r\n * A Timestamp represents a point in time independent of any time zone or\r\n * calendar, represented as seconds and fractions of seconds at nanosecond\r\n * resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian\r\n * Calendar which extends the Gregorian calendar backwards to year one. It is\r\n * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are\r\n * \"smeared\" so that no leap second table is needed for interpretation. Range is\r\n * from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto\r\n */\nclass Timestamp {\n  /**\r\n   * Creates a new timestamp with the current date, with millisecond precision.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.set({ updateTime:Firestore.Timestamp.now() });\r\n   *\r\n   * ```\r\n   * @return {Timestamp} A new `Timestamp` representing the current date.\r\n   */\n  static now() {\n    return Timestamp.fromMillis(Date.now());\n  }\n  /**\r\n   * Creates a new timestamp from the given date.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * let date = Date.parse('01 Jan 2000 00:00:00 GMT');\r\n   * documentRef.set({ startTime:Firestore.Timestamp.fromDate(date) });\r\n   *\r\n   * ```\r\n   * @param {Date} date The date to initialize the `Timestamp` from.\r\n   * @return {Timestamp} A new `Timestamp` representing the same point in time\r\n   * as the given date.\r\n   */\n  static fromDate(date) {\n    return Timestamp.fromMillis(date.getTime());\n  }\n  /**\r\n   * Creates a new timestamp from the given number of milliseconds.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.set({ startTime:Firestore.Timestamp.fromMillis(42) });\r\n   *\r\n   * ```\r\n   * @param {number} milliseconds Number of milliseconds since Unix epoch\r\n   * 1970-01-01T00:00:00Z.\r\n   * @return {Timestamp}  A new `Timestamp` representing the same point in time\r\n   * as the given number of milliseconds.\r\n   */\n  static fromMillis(milliseconds) {\n    const seconds = Math.floor(milliseconds / 1000);\n    const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\n    return new Timestamp(seconds, nanos);\n  }\n  /**\r\n   * Generates a `Timestamp` object from a Timestamp proto.\r\n   *\r\n   * @private\r\n   * @internal\r\n   * @param {Object} timestamp The `Timestamp` Protobuf object.\r\n   */\n  static fromProto(timestamp) {\n    return new Timestamp(Number(timestamp.seconds || 0), timestamp.nanos || 0);\n  }\n  /**\r\n   * Creates a new timestamp.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.set({ startTime:new Firestore.Timestamp(42, 0) });\r\n   *\r\n   * ```\r\n   * @param {number} seconds The number of seconds of UTC time since Unix epoch\r\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n   * 9999-12-31T23:59:59Z inclusive.\r\n   * @param {number} nanoseconds The non-negative fractions of a second at\r\n   * nanosecond resolution. Negative second values with fractions must still\r\n   * have non-negative nanoseconds values that count forward in time. Must be\r\n   * from 0 to 999,999,999 inclusive.\r\n   */\n  constructor(seconds, nanoseconds) {\n    (0, validate_1.validateInteger)('seconds', seconds, {\n      minValue: MIN_SECONDS,\n      maxValue: MAX_SECONDS\n    });\n    (0, validate_1.validateInteger)('nanoseconds', nanoseconds, {\n      minValue: 0,\n      maxValue: 999999999\n    });\n    this._seconds = seconds;\n    this._nanoseconds = nanoseconds;\n  }\n  /**\r\n   * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(snap => {\r\n   *   let updated = snap.updateTime;\r\n   *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\r\n   * });\r\n   *\r\n   * ```\r\n   * @type {number}\r\n   */\n  get seconds() {\n    return this._seconds;\n  }\n  /**\r\n   * The non-negative fractions of a second at nanosecond resolution.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(snap => {\r\n   *   let updated = snap.updateTime;\r\n   *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\r\n   * });\r\n   *\r\n   * ```\r\n   * @type {number}\r\n   */\n  get nanoseconds() {\n    return this._nanoseconds;\n  }\n  /**\r\n   * Returns a new `Date` corresponding to this timestamp. This may lose\r\n   * precision.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(snap => {\r\n   *   console.log(`Document updated at: ${snap.updateTime.toDate()}`);\r\n   * });\r\n   *\r\n   * ```\r\n   * @return {Date} JavaScript `Date` object representing the same point in time\r\n   * as this `Timestamp`, with millisecond precision.\r\n   */\n  toDate() {\n    return new Date(this._seconds * 1000 + Math.round(this._nanoseconds / MS_TO_NANOS));\n  }\n  /**\r\n   * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(snap => {\r\n   *   let startTime = snap.get('startTime');\r\n   *   let endTime = snap.get('endTime');\r\n   *   console.log(`Duration: ${endTime - startTime}`);\r\n   * });\r\n   *\r\n   * ```\r\n   * @return {number} The point in time corresponding to this timestamp,\r\n   * represented as the number of milliseconds since Unix epoch\r\n   * 1970-01-01T00:00:00Z.\r\n   */\n  toMillis() {\n    return this._seconds * 1000 + Math.floor(this._nanoseconds / MS_TO_NANOS);\n  }\n  /**\r\n   * Returns 'true' if this `Timestamp` is equal to the provided one.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(snap => {\r\n   *   if (snap.createTime.isEqual(snap.updateTime)) {\r\n   *     console.log('Document is in its initial state.');\r\n   *   }\r\n   * });\r\n   *\r\n   * ```\r\n   * @param {any} other The `Timestamp` to compare against.\r\n   * @return {boolean} 'true' if this `Timestamp` is equal to the provided one.\r\n   */\n  isEqual(other) {\n    return this === other || other instanceof Timestamp && this._seconds === other.seconds && this._nanoseconds === other.nanoseconds;\n  }\n  /**\r\n   * Generates the Protobuf `Timestamp` object for this timestamp.\r\n   *\r\n   * @private\r\n   * @internal\r\n   * @returns {Object} The `Timestamp` Protobuf object.\r\n   */\n  toProto() {\n    const timestamp = {};\n    if (this.seconds) {\n      timestamp.seconds = this.seconds.toString();\n    }\n    if (this.nanoseconds) {\n      timestamp.nanos = this.nanoseconds;\n    }\n    return {\n      timestampValue: timestamp\n    };\n  }\n  /**\r\n   * Converts this object to a primitive `string`, which allows `Timestamp` objects to be compared\r\n   * using the `>`, `<=`, `>=` and `>` operators.\r\n   *\r\n   * @return {string} a string encoding of this object.\r\n   */\n  valueOf() {\n    // This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is\n    // translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded\n    // with zeroes to be a consistent length. Strings with this format then have a lexicographical\n    // ordering that matches the expected ordering. The <seconds> translation is done to avoid\n    // having a leading negative sign (i.e. a leading '-' character) in its string representation,\n    // which would affect its lexicographical ordering.\n    const adjustedSeconds = this.seconds - MIN_SECONDS;\n    // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.\n    const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n    const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n    return formattedSeconds + '.' + formattedNanoseconds;\n  }\n}\nexports.Timestamp = Timestamp;","map":{"version":3,"names":["Object","defineProperty","exports","value","Timestamp","validate_1","require","MS_TO_NANOS","MIN_SECONDS","MAX_SECONDS","now","fromMillis","Date","fromDate","date","getTime","milliseconds","seconds","Math","floor","nanos","fromProto","timestamp","Number","constructor","nanoseconds","validateInteger","minValue","maxValue","_seconds","_nanoseconds","toDate","round","toMillis","isEqual","other","toProto","toString","timestampValue","valueOf","adjustedSeconds","formattedSeconds","String","padStart","formattedNanoseconds"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@google-cloud/firestore/build/src/timestamp.js"],"sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2018 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Timestamp = void 0;\r\nconst validate_1 = require(\"./validate\");\r\n/*!\r\n * Number of nanoseconds in a millisecond.\r\n *\r\n * @type {number}\r\n */\r\nconst MS_TO_NANOS = 1000000;\r\n/*!\r\n * The minimum legal value for the \"seconds\" property of a Timestamp object.\r\n *\r\n * This value corresponds to 0001-01-01T00:00:00Z.\r\n *\r\n * @type {number}\r\n */\r\nconst MIN_SECONDS = -62135596800;\r\n/*!\r\n * The maximum legal value for the \"seconds\" property of a Timestamp object.\r\n *\r\n * This value corresponds to 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * @type {number}\r\n */\r\nconst MAX_SECONDS = 253402300799;\r\n/**\r\n * A Timestamp represents a point in time independent of any time zone or\r\n * calendar, represented as seconds and fractions of seconds at nanosecond\r\n * resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian\r\n * Calendar which extends the Gregorian calendar backwards to year one. It is\r\n * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are\r\n * \"smeared\" so that no leap second table is needed for interpretation. Range is\r\n * from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto\r\n */\r\nclass Timestamp {\r\n    /**\r\n     * Creates a new timestamp with the current date, with millisecond precision.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.set({ updateTime:Firestore.Timestamp.now() });\r\n     *\r\n     * ```\r\n     * @return {Timestamp} A new `Timestamp` representing the current date.\r\n     */\r\n    static now() {\r\n        return Timestamp.fromMillis(Date.now());\r\n    }\r\n    /**\r\n     * Creates a new timestamp from the given date.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * let date = Date.parse('01 Jan 2000 00:00:00 GMT');\r\n     * documentRef.set({ startTime:Firestore.Timestamp.fromDate(date) });\r\n     *\r\n     * ```\r\n     * @param {Date} date The date to initialize the `Timestamp` from.\r\n     * @return {Timestamp} A new `Timestamp` representing the same point in time\r\n     * as the given date.\r\n     */\r\n    static fromDate(date) {\r\n        return Timestamp.fromMillis(date.getTime());\r\n    }\r\n    /**\r\n     * Creates a new timestamp from the given number of milliseconds.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.set({ startTime:Firestore.Timestamp.fromMillis(42) });\r\n     *\r\n     * ```\r\n     * @param {number} milliseconds Number of milliseconds since Unix epoch\r\n     * 1970-01-01T00:00:00Z.\r\n     * @return {Timestamp}  A new `Timestamp` representing the same point in time\r\n     * as the given number of milliseconds.\r\n     */\r\n    static fromMillis(milliseconds) {\r\n        const seconds = Math.floor(milliseconds / 1000);\r\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\r\n        return new Timestamp(seconds, nanos);\r\n    }\r\n    /**\r\n     * Generates a `Timestamp` object from a Timestamp proto.\r\n     *\r\n     * @private\r\n     * @internal\r\n     * @param {Object} timestamp The `Timestamp` Protobuf object.\r\n     */\r\n    static fromProto(timestamp) {\r\n        return new Timestamp(Number(timestamp.seconds || 0), timestamp.nanos || 0);\r\n    }\r\n    /**\r\n     * Creates a new timestamp.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.set({ startTime:new Firestore.Timestamp(42, 0) });\r\n     *\r\n     * ```\r\n     * @param {number} seconds The number of seconds of UTC time since Unix epoch\r\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n     * 9999-12-31T23:59:59Z inclusive.\r\n     * @param {number} nanoseconds The non-negative fractions of a second at\r\n     * nanosecond resolution. Negative second values with fractions must still\r\n     * have non-negative nanoseconds values that count forward in time. Must be\r\n     * from 0 to 999,999,999 inclusive.\r\n     */\r\n    constructor(seconds, nanoseconds) {\r\n        (0, validate_1.validateInteger)('seconds', seconds, {\r\n            minValue: MIN_SECONDS,\r\n            maxValue: MAX_SECONDS,\r\n        });\r\n        (0, validate_1.validateInteger)('nanoseconds', nanoseconds, {\r\n            minValue: 0,\r\n            maxValue: 999999999,\r\n        });\r\n        this._seconds = seconds;\r\n        this._nanoseconds = nanoseconds;\r\n    }\r\n    /**\r\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(snap => {\r\n     *   let updated = snap.updateTime;\r\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\r\n     * });\r\n     *\r\n     * ```\r\n     * @type {number}\r\n     */\r\n    get seconds() {\r\n        return this._seconds;\r\n    }\r\n    /**\r\n     * The non-negative fractions of a second at nanosecond resolution.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(snap => {\r\n     *   let updated = snap.updateTime;\r\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\r\n     * });\r\n     *\r\n     * ```\r\n     * @type {number}\r\n     */\r\n    get nanoseconds() {\r\n        return this._nanoseconds;\r\n    }\r\n    /**\r\n     * Returns a new `Date` corresponding to this timestamp. This may lose\r\n     * precision.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(snap => {\r\n     *   console.log(`Document updated at: ${snap.updateTime.toDate()}`);\r\n     * });\r\n     *\r\n     * ```\r\n     * @return {Date} JavaScript `Date` object representing the same point in time\r\n     * as this `Timestamp`, with millisecond precision.\r\n     */\r\n    toDate() {\r\n        return new Date(this._seconds * 1000 + Math.round(this._nanoseconds / MS_TO_NANOS));\r\n    }\r\n    /**\r\n     * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(snap => {\r\n     *   let startTime = snap.get('startTime');\r\n     *   let endTime = snap.get('endTime');\r\n     *   console.log(`Duration: ${endTime - startTime}`);\r\n     * });\r\n     *\r\n     * ```\r\n     * @return {number} The point in time corresponding to this timestamp,\r\n     * represented as the number of milliseconds since Unix epoch\r\n     * 1970-01-01T00:00:00Z.\r\n     */\r\n    toMillis() {\r\n        return this._seconds * 1000 + Math.floor(this._nanoseconds / MS_TO_NANOS);\r\n    }\r\n    /**\r\n     * Returns 'true' if this `Timestamp` is equal to the provided one.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(snap => {\r\n     *   if (snap.createTime.isEqual(snap.updateTime)) {\r\n     *     console.log('Document is in its initial state.');\r\n     *   }\r\n     * });\r\n     *\r\n     * ```\r\n     * @param {any} other The `Timestamp` to compare against.\r\n     * @return {boolean} 'true' if this `Timestamp` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return (this === other ||\r\n            (other instanceof Timestamp &&\r\n                this._seconds === other.seconds &&\r\n                this._nanoseconds === other.nanoseconds));\r\n    }\r\n    /**\r\n     * Generates the Protobuf `Timestamp` object for this timestamp.\r\n     *\r\n     * @private\r\n     * @internal\r\n     * @returns {Object} The `Timestamp` Protobuf object.\r\n     */\r\n    toProto() {\r\n        const timestamp = {};\r\n        if (this.seconds) {\r\n            timestamp.seconds = this.seconds.toString();\r\n        }\r\n        if (this.nanoseconds) {\r\n            timestamp.nanos = this.nanoseconds;\r\n        }\r\n        return { timestampValue: timestamp };\r\n    }\r\n    /**\r\n     * Converts this object to a primitive `string`, which allows `Timestamp` objects to be compared\r\n     * using the `>`, `<=`, `>=` and `>` operators.\r\n     *\r\n     * @return {string} a string encoding of this object.\r\n     */\r\n    valueOf() {\r\n        // This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is\r\n        // translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded\r\n        // with zeroes to be a consistent length. Strings with this format then have a lexicographical\r\n        // ordering that matches the expected ordering. The <seconds> translation is done to avoid\r\n        // having a leading negative sign (i.e. a leading '-' character) in its string representation,\r\n        // which would affect its lexicographical ordering.\r\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\r\n        // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.\r\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\r\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\r\n        return formattedSeconds + '.' + formattedNanoseconds;\r\n    }\r\n}\r\nexports.Timestamp = Timestamp;\r\n//# sourceMappingURL=timestamp.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,SAAS,GAAG,KAAK,CAAC;AAC1B,MAAMC,UAAU,GAAGC,OAAO,CAAC,YAAY,CAAC;AACxC;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAG,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAG,CAAC,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAG,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAML,SAAS,CAAC;EACZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOM,GAAGA,CAAA,EAAG;IACT,OAAON,SAAS,CAACO,UAAU,CAACC,IAAI,CAACF,GAAG,CAAC,CAAC,CAAC;EAC3C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOG,QAAQA,CAACC,IAAI,EAAE;IAClB,OAAOV,SAAS,CAACO,UAAU,CAACG,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EAC/C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOJ,UAAUA,CAACK,YAAY,EAAE;IAC5B,MAAMC,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACH,YAAY,GAAG,IAAI,CAAC;IAC/C,MAAMI,KAAK,GAAGF,IAAI,CAACC,KAAK,CAAC,CAACH,YAAY,GAAGC,OAAO,GAAG,IAAI,IAAIV,WAAW,CAAC;IACvE,OAAO,IAAIH,SAAS,CAACa,OAAO,EAAEG,KAAK,CAAC;EACxC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}