{"ast":null,"code":"\"use strict\";\n\n/*!\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DocumentReader = void 0;\nconst document_1 = require(\"./document\");\nconst util_1 = require(\"./util\");\nconst logger_1 = require(\"./logger\");\nconst timestamp_1 = require(\"./timestamp\");\n/**\r\n * A wrapper around BatchGetDocumentsRequest that retries request upon stream\r\n * failure and returns ordered results.\r\n *\r\n * @private\r\n * @internal\r\n */\nclass DocumentReader {\n  /**\r\n   * Creates a new DocumentReader that fetches the provided documents (via\r\n   * `get()`).\r\n   *\r\n   * @param firestore The Firestore instance to use.\r\n   * @param allDocuments The documents to get.\r\n   * @param fieldMask An optional field mask to apply to this read\r\n   * @param transactionOrReadTime An optional transaction ID to use for this\r\n   * read or options for beginning a new transaction with this read\r\n   */\n  constructor(firestore, allDocuments, fieldMask, transactionOrReadTime) {\n    this.firestore = firestore;\n    this.allDocuments = allDocuments;\n    this.fieldMask = fieldMask;\n    this.transactionOrReadTime = transactionOrReadTime;\n    this.outstandingDocuments = new Set();\n    this.retrievedDocuments = new Map();\n    for (const docRef of this.allDocuments) {\n      this.outstandingDocuments.add(docRef.formattedName);\n    }\n  }\n  /**\r\n   * Invokes the BatchGetDocuments RPC and returns the results as an array of\r\n   * documents.\r\n   *\r\n   * @param requestTag A unique client-assigned identifier for this request.\r\n   */\n  async get(requestTag) {\n    const {\n      result\n    } = await this._get(requestTag);\n    return result;\n  }\n  /**\r\n   * Invokes the BatchGetDocuments RPC and returns the results with transaction\r\n   * metadata.\r\n   *\r\n   * @param requestTag A unique client-assigned identifier for this request.\r\n   */\n  async _get(requestTag) {\n    await this.fetchDocuments(requestTag);\n    // BatchGetDocuments doesn't preserve document order. We use the request\n    // order to sort the resulting documents.\n    const orderedDocuments = [];\n    for (const docRef of this.allDocuments) {\n      const document = this.retrievedDocuments.get(docRef.formattedName);\n      if (document !== undefined) {\n        // Recreate the DocumentSnapshot with the DocumentReference\n        // containing the original converter.\n        const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\n        finalDoc.fieldsProto = document._fieldsProto;\n        finalDoc.readTime = document.readTime;\n        finalDoc.createTime = document.createTime;\n        finalDoc.updateTime = document.updateTime;\n        orderedDocuments.push(finalDoc.build());\n      } else {\n        throw new Error(`Did not receive document for \"${docRef.path}\".`);\n      }\n    }\n    return {\n      result: orderedDocuments,\n      transaction: this.retrievedTransactionId\n    };\n  }\n  async fetchDocuments(requestTag) {\n    var _a;\n    if (!this.outstandingDocuments.size) {\n      return;\n    }\n    const request = {\n      database: this.firestore.formattedName,\n      documents: Array.from(this.outstandingDocuments)\n    };\n    if (this.transactionOrReadTime instanceof Uint8Array) {\n      request.transaction = this.transactionOrReadTime;\n    } else if (this.transactionOrReadTime instanceof timestamp_1.Timestamp) {\n      request.readTime = this.transactionOrReadTime.toProto().timestampValue;\n    } else if (this.transactionOrReadTime) {\n      request.newTransaction = this.transactionOrReadTime;\n    }\n    if (this.fieldMask) {\n      const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);\n      request.mask = {\n        fieldPaths\n      };\n    }\n    let resultCount = 0;\n    try {\n      const stream = await this.firestore.requestStream('batchGetDocuments', /* bidirectional= */false, request, requestTag);\n      stream.resume();\n      for await (const response of stream) {\n        // Proto comes with zero-length buffer by default\n        if ((_a = response.transaction) === null || _a === void 0 ? void 0 : _a.length) {\n          this.retrievedTransactionId = response.transaction;\n        }\n        let snapshot;\n        if (response.found) {\n          (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);\n          snapshot = this.firestore.snapshot_(response.found, response.readTime);\n        } else if (response.missing) {\n          (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);\n          snapshot = this.firestore.snapshot_(response.missing, response.readTime);\n        }\n        if (snapshot) {\n          const path = snapshot.ref.formattedName;\n          this.outstandingDocuments.delete(path);\n          this.retrievedDocuments.set(path, snapshot);\n          ++resultCount;\n        }\n      }\n    } catch (error) {\n      const shouldRetry =\n      // Transactional reads are retried via the transaction runner.\n      !request.transaction && !request.newTransaction &&\n      // Only retry if we made progress.\n      resultCount > 0 &&\n      // Don't retry permanent errors.\n      error.code !== undefined && !(0, util_1.isPermanentRpcError)(error, 'batchGetDocuments');\n      (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);\n      if (shouldRetry) {\n        return this.fetchDocuments(requestTag);\n      } else {\n        throw error;\n      }\n    } finally {\n      (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);\n    }\n  }\n}\nexports.DocumentReader = DocumentReader;","map":{"version":3,"names":["Object","defineProperty","exports","value","DocumentReader","document_1","require","util_1","logger_1","timestamp_1","constructor","firestore","allDocuments","fieldMask","transactionOrReadTime","outstandingDocuments","Set","retrievedDocuments","Map","docRef","add","formattedName","get","requestTag","result","_get","fetchDocuments","orderedDocuments","document","undefined","finalDoc","DocumentSnapshotBuilder","fieldsProto","_fieldsProto","readTime","createTime","updateTime","push","build","Error","path","transaction","retrievedTransactionId","_a","size","request","database","documents","Array","from","Uint8Array","Timestamp","toProto","timestampValue","newTransaction","fieldPaths","map","fieldPath","mask","resultCount","stream","requestStream","resume","response","length","snapshot","found","logger","name","snapshot_","missing","ref","delete","set","error","shouldRetry","code","isPermanentRpcError"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@google-cloud/firestore/build/src/document-reader.js"],"sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DocumentReader = void 0;\r\nconst document_1 = require(\"./document\");\r\nconst util_1 = require(\"./util\");\r\nconst logger_1 = require(\"./logger\");\r\nconst timestamp_1 = require(\"./timestamp\");\r\n/**\r\n * A wrapper around BatchGetDocumentsRequest that retries request upon stream\r\n * failure and returns ordered results.\r\n *\r\n * @private\r\n * @internal\r\n */\r\nclass DocumentReader {\r\n    /**\r\n     * Creates a new DocumentReader that fetches the provided documents (via\r\n     * `get()`).\r\n     *\r\n     * @param firestore The Firestore instance to use.\r\n     * @param allDocuments The documents to get.\r\n     * @param fieldMask An optional field mask to apply to this read\r\n     * @param transactionOrReadTime An optional transaction ID to use for this\r\n     * read or options for beginning a new transaction with this read\r\n     */\r\n    constructor(firestore, allDocuments, fieldMask, transactionOrReadTime) {\r\n        this.firestore = firestore;\r\n        this.allDocuments = allDocuments;\r\n        this.fieldMask = fieldMask;\r\n        this.transactionOrReadTime = transactionOrReadTime;\r\n        this.outstandingDocuments = new Set();\r\n        this.retrievedDocuments = new Map();\r\n        for (const docRef of this.allDocuments) {\r\n            this.outstandingDocuments.add(docRef.formattedName);\r\n        }\r\n    }\r\n    /**\r\n     * Invokes the BatchGetDocuments RPC and returns the results as an array of\r\n     * documents.\r\n     *\r\n     * @param requestTag A unique client-assigned identifier for this request.\r\n     */\r\n    async get(requestTag) {\r\n        const { result } = await this._get(requestTag);\r\n        return result;\r\n    }\r\n    /**\r\n     * Invokes the BatchGetDocuments RPC and returns the results with transaction\r\n     * metadata.\r\n     *\r\n     * @param requestTag A unique client-assigned identifier for this request.\r\n     */\r\n    async _get(requestTag) {\r\n        await this.fetchDocuments(requestTag);\r\n        // BatchGetDocuments doesn't preserve document order. We use the request\r\n        // order to sort the resulting documents.\r\n        const orderedDocuments = [];\r\n        for (const docRef of this.allDocuments) {\r\n            const document = this.retrievedDocuments.get(docRef.formattedName);\r\n            if (document !== undefined) {\r\n                // Recreate the DocumentSnapshot with the DocumentReference\r\n                // containing the original converter.\r\n                const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\r\n                finalDoc.fieldsProto = document._fieldsProto;\r\n                finalDoc.readTime = document.readTime;\r\n                finalDoc.createTime = document.createTime;\r\n                finalDoc.updateTime = document.updateTime;\r\n                orderedDocuments.push(finalDoc.build());\r\n            }\r\n            else {\r\n                throw new Error(`Did not receive document for \"${docRef.path}\".`);\r\n            }\r\n        }\r\n        return {\r\n            result: orderedDocuments,\r\n            transaction: this.retrievedTransactionId,\r\n        };\r\n    }\r\n    async fetchDocuments(requestTag) {\r\n        var _a;\r\n        if (!this.outstandingDocuments.size) {\r\n            return;\r\n        }\r\n        const request = {\r\n            database: this.firestore.formattedName,\r\n            documents: Array.from(this.outstandingDocuments),\r\n        };\r\n        if (this.transactionOrReadTime instanceof Uint8Array) {\r\n            request.transaction = this.transactionOrReadTime;\r\n        }\r\n        else if (this.transactionOrReadTime instanceof timestamp_1.Timestamp) {\r\n            request.readTime = this.transactionOrReadTime.toProto().timestampValue;\r\n        }\r\n        else if (this.transactionOrReadTime) {\r\n            request.newTransaction = this.transactionOrReadTime;\r\n        }\r\n        if (this.fieldMask) {\r\n            const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);\r\n            request.mask = { fieldPaths };\r\n        }\r\n        let resultCount = 0;\r\n        try {\r\n            const stream = await this.firestore.requestStream('batchGetDocuments', \r\n            /* bidirectional= */ false, request, requestTag);\r\n            stream.resume();\r\n            for await (const response of stream) {\r\n                // Proto comes with zero-length buffer by default\r\n                if ((_a = response.transaction) === null || _a === void 0 ? void 0 : _a.length) {\r\n                    this.retrievedTransactionId = response.transaction;\r\n                }\r\n                let snapshot;\r\n                if (response.found) {\r\n                    (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);\r\n                    snapshot = this.firestore.snapshot_(response.found, response.readTime);\r\n                }\r\n                else if (response.missing) {\r\n                    (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);\r\n                    snapshot = this.firestore.snapshot_(response.missing, response.readTime);\r\n                }\r\n                if (snapshot) {\r\n                    const path = snapshot.ref.formattedName;\r\n                    this.outstandingDocuments.delete(path);\r\n                    this.retrievedDocuments.set(path, snapshot);\r\n                    ++resultCount;\r\n                }\r\n            }\r\n        }\r\n        catch (error) {\r\n            const shouldRetry = \r\n            // Transactional reads are retried via the transaction runner.\r\n            !request.transaction &&\r\n                !request.newTransaction &&\r\n                // Only retry if we made progress.\r\n                resultCount > 0 &&\r\n                // Don't retry permanent errors.\r\n                error.code !== undefined &&\r\n                !(0, util_1.isPermanentRpcError)(error, 'batchGetDocuments');\r\n            (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);\r\n            if (shouldRetry) {\r\n                return this.fetchDocuments(requestTag);\r\n            }\r\n            else {\r\n                throw error;\r\n            }\r\n        }\r\n        finally {\r\n            (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);\r\n        }\r\n    }\r\n}\r\nexports.DocumentReader = DocumentReader;\r\n//# sourceMappingURL=document-reader.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}