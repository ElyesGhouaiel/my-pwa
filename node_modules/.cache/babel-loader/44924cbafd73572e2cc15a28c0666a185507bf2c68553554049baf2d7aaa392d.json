{"ast":null,"code":"/*! firebase-admin v13.0.1 */\n\"use strict\";\n\n/*!\r\n * @license\r\n * Copyright 2021 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoSignerErrorCode = exports.CryptoSignerError = exports.IAMSigner = exports.ServiceAccountSigner = void 0;\nexports.cryptoSignerFromApp = cryptoSignerFromApp;\nconst credential_internal_1 = require(\"../app/credential-internal\");\nconst api_request_1 = require(\"./api-request\");\nconst validator = require(\"../utils/validator\");\nconst ALGORITHM_RS256 = 'RS256';\n/**\r\n * A CryptoSigner implementation that uses an explicitly specified service account private key to\r\n * sign data. Performs all operations locally, and does not make any RPC calls.\r\n */\nclass ServiceAccountSigner {\n  /**\r\n   * Creates a new CryptoSigner instance from the given service account credential.\r\n   *\r\n   * @param credential - A service account credential.\r\n   */\n  constructor(credential) {\n    this.credential = credential;\n    this.algorithm = ALGORITHM_RS256;\n    if (!credential) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n        message: 'INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner.'\n      });\n    }\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n  sign(buffer) {\n    const crypto = require('crypto'); // eslint-disable-line @typescript-eslint/no-var-requires\n    const sign = crypto.createSign('RSA-SHA256');\n    sign.update(buffer);\n    return Promise.resolve(sign.sign(this.credential.privateKey));\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n  getAccountId() {\n    return Promise.resolve(this.credential.clientEmail);\n  }\n}\nexports.ServiceAccountSigner = ServiceAccountSigner;\n/**\r\n * A CryptoSigner implementation that uses the remote IAM service to sign data. If initialized without\r\n * a service account ID, attempts to discover a service account ID by consulting the local Metadata\r\n * service. This will succeed in managed environments like Google Cloud Functions and App Engine.\r\n *\r\n * @see https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob\r\n * @see https://cloud.google.com/compute/docs/storing-retrieving-metadata\r\n */\nclass IAMSigner {\n  constructor(httpClient, serviceAccountId) {\n    this.algorithm = ALGORITHM_RS256;\n    if (!httpClient) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n        message: 'INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner.'\n      });\n    }\n    if (typeof serviceAccountId !== 'undefined' && !validator.isNonEmptyString(serviceAccountId)) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n        message: 'INTERNAL ASSERT: Service account ID must be undefined or a non-empty string.'\n      });\n    }\n    this.httpClient = httpClient;\n    this.serviceAccountId = serviceAccountId;\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n  sign(buffer) {\n    return this.getAccountId().then(serviceAccount => {\n      const request = {\n        method: 'POST',\n        url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,\n        data: {\n          payload: buffer.toString('base64')\n        }\n      };\n      return this.httpClient.send(request);\n    }).then(response => {\n      // Response from IAM is base64 encoded. Decode it into a buffer and return.\n      return Buffer.from(response.data.signedBlob, 'base64');\n    }).catch(err => {\n      if (err instanceof api_request_1.RequestResponseError) {\n        throw new CryptoSignerError({\n          code: CryptoSignerErrorCode.SERVER_ERROR,\n          message: err.message,\n          cause: err\n        });\n      }\n      throw err;\n    });\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n  getAccountId() {\n    if (validator.isNonEmptyString(this.serviceAccountId)) {\n      return Promise.resolve(this.serviceAccountId);\n    }\n    const request = {\n      method: 'GET',\n      url: 'http://metadata/computeMetadata/v1/instance/service-accounts/default/email',\n      headers: {\n        'Metadata-Flavor': 'Google'\n      }\n    };\n    const client = new api_request_1.HttpClient();\n    return client.send(request).then(response => {\n      if (!response.text) {\n        throw new CryptoSignerError({\n          code: CryptoSignerErrorCode.INTERNAL_ERROR,\n          message: 'HTTP Response missing payload'\n        });\n      }\n      this.serviceAccountId = response.text;\n      return response.text;\n    }).catch(err => {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n        message: 'Failed to determine service account. Make sure to initialize ' + 'the SDK with a service account credential. Alternatively specify a service ' + `account with iam.serviceAccounts.signBlob permission. Original error: ${err}`\n      });\n    });\n  }\n}\nexports.IAMSigner = IAMSigner;\n/**\r\n * Creates a new CryptoSigner instance for the given app. If the app has been initialized with a\r\n * service account credential, creates a ServiceAccountSigner.\r\n *\r\n * @param app - A FirebaseApp instance.\r\n * @returns A CryptoSigner instance.\r\n */\nfunction cryptoSignerFromApp(app) {\n  const credential = app.options.credential;\n  if (credential instanceof credential_internal_1.ServiceAccountCredential) {\n    return new ServiceAccountSigner(credential);\n  }\n  return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app.options.serviceAccountId);\n}\n/**\r\n * CryptoSigner error code structure.\r\n *\r\n * @param errorInfo - The error information (code and message).\r\n * @constructor\r\n */\nclass CryptoSignerError extends Error {\n  constructor(errorInfo) {\n    super(errorInfo.message);\n    this.errorInfo = errorInfo;\n    /* tslint:disable:max-line-length */\n    // Set the prototype explicitly. See the following link for more details:\n    // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    /* tslint:enable:max-line-length */\n    this.__proto__ = CryptoSignerError.prototype;\n  }\n  /** @returns The error code. */\n  get code() {\n    return this.errorInfo.code;\n  }\n  /** @returns The error message. */\n  get message() {\n    return this.errorInfo.message;\n  }\n  /** @returns The error data. */\n  get cause() {\n    return this.errorInfo.cause;\n  }\n}\nexports.CryptoSignerError = CryptoSignerError;\n/**\r\n * Crypto Signer error codes and their default messages.\r\n */\nclass CryptoSignerErrorCode {}\nexports.CryptoSignerErrorCode = CryptoSignerErrorCode;\nCryptoSignerErrorCode.INVALID_ARGUMENT = 'invalid-argument';\nCryptoSignerErrorCode.INTERNAL_ERROR = 'internal-error';\nCryptoSignerErrorCode.INVALID_CREDENTIAL = 'invalid-credential';\nCryptoSignerErrorCode.SERVER_ERROR = 'server-error';","map":{"version":3,"names":["Object","defineProperty","exports","value","CryptoSignerErrorCode","CryptoSignerError","IAMSigner","ServiceAccountSigner","cryptoSignerFromApp","credential_internal_1","require","api_request_1","validator","ALGORITHM_RS256","constructor","credential","algorithm","code","INVALID_CREDENTIAL","message","sign","buffer","crypto","createSign","update","Promise","resolve","privateKey","getAccountId","clientEmail","httpClient","serviceAccountId","INVALID_ARGUMENT","isNonEmptyString","then","serviceAccount","request","method","url","data","payload","toString","send","response","Buffer","from","signedBlob","catch","err","RequestResponseError","SERVER_ERROR","cause","headers","client","HttpClient","text","INTERNAL_ERROR","app","options","ServiceAccountCredential","AuthorizedHttpClient","Error","errorInfo","__proto__","prototype"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/firebase-admin/lib/utils/crypto-signer.js"],"sourcesContent":["/*! firebase-admin v13.0.1 */\r\n\"use strict\";\r\n/*!\r\n * @license\r\n * Copyright 2021 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CryptoSignerErrorCode = exports.CryptoSignerError = exports.IAMSigner = exports.ServiceAccountSigner = void 0;\r\nexports.cryptoSignerFromApp = cryptoSignerFromApp;\r\nconst credential_internal_1 = require(\"../app/credential-internal\");\r\nconst api_request_1 = require(\"./api-request\");\r\nconst validator = require(\"../utils/validator\");\r\nconst ALGORITHM_RS256 = 'RS256';\r\n/**\r\n * A CryptoSigner implementation that uses an explicitly specified service account private key to\r\n * sign data. Performs all operations locally, and does not make any RPC calls.\r\n */\r\nclass ServiceAccountSigner {\r\n    /**\r\n     * Creates a new CryptoSigner instance from the given service account credential.\r\n     *\r\n     * @param credential - A service account credential.\r\n     */\r\n    constructor(credential) {\r\n        this.credential = credential;\r\n        this.algorithm = ALGORITHM_RS256;\r\n        if (!credential) {\r\n            throw new CryptoSignerError({\r\n                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\r\n                message: 'INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner.',\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    sign(buffer) {\r\n        const crypto = require('crypto'); // eslint-disable-line @typescript-eslint/no-var-requires\r\n        const sign = crypto.createSign('RSA-SHA256');\r\n        sign.update(buffer);\r\n        return Promise.resolve(sign.sign(this.credential.privateKey));\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    getAccountId() {\r\n        return Promise.resolve(this.credential.clientEmail);\r\n    }\r\n}\r\nexports.ServiceAccountSigner = ServiceAccountSigner;\r\n/**\r\n * A CryptoSigner implementation that uses the remote IAM service to sign data. If initialized without\r\n * a service account ID, attempts to discover a service account ID by consulting the local Metadata\r\n * service. This will succeed in managed environments like Google Cloud Functions and App Engine.\r\n *\r\n * @see https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob\r\n * @see https://cloud.google.com/compute/docs/storing-retrieving-metadata\r\n */\r\nclass IAMSigner {\r\n    constructor(httpClient, serviceAccountId) {\r\n        this.algorithm = ALGORITHM_RS256;\r\n        if (!httpClient) {\r\n            throw new CryptoSignerError({\r\n                code: CryptoSignerErrorCode.INVALID_ARGUMENT,\r\n                message: 'INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner.',\r\n            });\r\n        }\r\n        if (typeof serviceAccountId !== 'undefined' && !validator.isNonEmptyString(serviceAccountId)) {\r\n            throw new CryptoSignerError({\r\n                code: CryptoSignerErrorCode.INVALID_ARGUMENT,\r\n                message: 'INTERNAL ASSERT: Service account ID must be undefined or a non-empty string.',\r\n            });\r\n        }\r\n        this.httpClient = httpClient;\r\n        this.serviceAccountId = serviceAccountId;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    sign(buffer) {\r\n        return this.getAccountId().then((serviceAccount) => {\r\n            const request = {\r\n                method: 'POST',\r\n                url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,\r\n                data: { payload: buffer.toString('base64') },\r\n            };\r\n            return this.httpClient.send(request);\r\n        }).then((response) => {\r\n            // Response from IAM is base64 encoded. Decode it into a buffer and return.\r\n            return Buffer.from(response.data.signedBlob, 'base64');\r\n        }).catch((err) => {\r\n            if (err instanceof api_request_1.RequestResponseError) {\r\n                throw new CryptoSignerError({\r\n                    code: CryptoSignerErrorCode.SERVER_ERROR,\r\n                    message: err.message,\r\n                    cause: err\r\n                });\r\n            }\r\n            throw err;\r\n        });\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    getAccountId() {\r\n        if (validator.isNonEmptyString(this.serviceAccountId)) {\r\n            return Promise.resolve(this.serviceAccountId);\r\n        }\r\n        const request = {\r\n            method: 'GET',\r\n            url: 'http://metadata/computeMetadata/v1/instance/service-accounts/default/email',\r\n            headers: {\r\n                'Metadata-Flavor': 'Google',\r\n            },\r\n        };\r\n        const client = new api_request_1.HttpClient();\r\n        return client.send(request).then((response) => {\r\n            if (!response.text) {\r\n                throw new CryptoSignerError({\r\n                    code: CryptoSignerErrorCode.INTERNAL_ERROR,\r\n                    message: 'HTTP Response missing payload',\r\n                });\r\n            }\r\n            this.serviceAccountId = response.text;\r\n            return response.text;\r\n        }).catch((err) => {\r\n            throw new CryptoSignerError({\r\n                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\r\n                message: 'Failed to determine service account. Make sure to initialize ' +\r\n                    'the SDK with a service account credential. Alternatively specify a service ' +\r\n                    `account with iam.serviceAccounts.signBlob permission. Original error: ${err}`,\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.IAMSigner = IAMSigner;\r\n/**\r\n * Creates a new CryptoSigner instance for the given app. If the app has been initialized with a\r\n * service account credential, creates a ServiceAccountSigner.\r\n *\r\n * @param app - A FirebaseApp instance.\r\n * @returns A CryptoSigner instance.\r\n */\r\nfunction cryptoSignerFromApp(app) {\r\n    const credential = app.options.credential;\r\n    if (credential instanceof credential_internal_1.ServiceAccountCredential) {\r\n        return new ServiceAccountSigner(credential);\r\n    }\r\n    return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app.options.serviceAccountId);\r\n}\r\n/**\r\n * CryptoSigner error code structure.\r\n *\r\n * @param errorInfo - The error information (code and message).\r\n * @constructor\r\n */\r\nclass CryptoSignerError extends Error {\r\n    constructor(errorInfo) {\r\n        super(errorInfo.message);\r\n        this.errorInfo = errorInfo;\r\n        /* tslint:disable:max-line-length */\r\n        // Set the prototype explicitly. See the following link for more details:\r\n        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        /* tslint:enable:max-line-length */\r\n        this.__proto__ = CryptoSignerError.prototype;\r\n    }\r\n    /** @returns The error code. */\r\n    get code() {\r\n        return this.errorInfo.code;\r\n    }\r\n    /** @returns The error message. */\r\n    get message() {\r\n        return this.errorInfo.message;\r\n    }\r\n    /** @returns The error data. */\r\n    get cause() {\r\n        return this.errorInfo.cause;\r\n    }\r\n}\r\nexports.CryptoSignerError = CryptoSignerError;\r\n/**\r\n * Crypto Signer error codes and their default messages.\r\n */\r\nclass CryptoSignerErrorCode {\r\n}\r\nexports.CryptoSignerErrorCode = CryptoSignerErrorCode;\r\nCryptoSignerErrorCode.INVALID_ARGUMENT = 'invalid-argument';\r\nCryptoSignerErrorCode.INTERNAL_ERROR = 'internal-error';\r\nCryptoSignerErrorCode.INVALID_CREDENTIAL = 'invalid-credential';\r\nCryptoSignerErrorCode.SERVER_ERROR = 'server-error';\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}