{"ast":null,"code":"\"use strict\";\n\n/*!\r\n * Copyright 2017 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExponentialBackoff = exports.delayExecution = exports.MAX_RETRY_ATTEMPTS = exports.DEFAULT_BACKOFF_FACTOR = exports.DEFAULT_BACKOFF_MAX_DELAY_MS = exports.DEFAULT_BACKOFF_INITIAL_DELAY_MS = void 0;\nexports.setTimeoutHandler = setTimeoutHandler;\nconst logger_1 = require(\"./logger\");\n/*\r\n * @module firestore/backoff\r\n * @private\r\n * @internal\r\n *\r\n * Contains backoff logic to facilitate RPC error handling. This class derives\r\n * its implementation from the Firestore Mobile Web Client.\r\n *\r\n * @see https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/remote/backoff.ts\r\n */\n/*!\r\n * The default initial backoff time in milliseconds after an error.\r\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\r\n */\nexports.DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\n/*!\r\n * The default maximum backoff time in milliseconds.\r\n */\nexports.DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n/*!\r\n * The default factor to increase the backup by after each failed attempt.\r\n */\nexports.DEFAULT_BACKOFF_FACTOR = 1.5;\n/*!\r\n * The default jitter to distribute the backoff attempts by (0 means no\r\n * randomization, 1.0 means +/-50% randomization).\r\n */\nconst DEFAULT_JITTER_FACTOR = 1.0;\n/*!\r\n * The maximum number of retries that will be attempted by backoff\r\n * before stopping all retry attempts.\r\n */\nexports.MAX_RETRY_ATTEMPTS = 10;\n/*!\r\n * The timeout handler used by `ExponentialBackoff` and `BulkWriter`.\r\n */\nexports.delayExecution = setTimeout;\n/**\r\n * Allows overriding of the timeout handler used by the exponential backoff\r\n * implementation. If not invoked, we default to `setTimeout()`.\r\n *\r\n * Used only in testing.\r\n *\r\n * @private\r\n * @internal\r\n * @param {function} handler A handler than matches the API of `setTimeout()`.\r\n */\nfunction setTimeoutHandler(handler) {\n  exports.delayExecution = (f, ms) => {\n    handler(f, ms);\n    const timeout = {\n      hasRef: () => {\n        throw new Error('For tests only. Not Implemented');\n      },\n      ref: () => {\n        throw new Error('For tests only. Not Implemented');\n      },\n      refresh: () => {\n        throw new Error('For tests only. Not Implemented');\n      },\n      unref: () => {\n        throw new Error('For tests only. Not Implemented');\n      },\n      [Symbol.toPrimitive]: () => {\n        throw new Error('For tests only. Not Implemented');\n      }\n    };\n    // `NodeJS.Timeout` type signature change:\n    // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/66176/files#diff-e838d0ace9cd5f6516bacfbd3ad00d02cd37bd60f9993ce6223f52d889a1fdbaR122-R126\n    //\n    // Adding `[Symbol.dispose](): void;` cannot be done on older versions of\n    // NodeJS. So we simply cast to `NodeJS.Timeout`.\n    return timeout;\n  };\n}\n/**\r\n * A helper for running delayed tasks following an exponential backoff curve\r\n * between attempts.\r\n *\r\n * Each delay is made up of a \"base\" delay which follows the exponential\r\n * backoff curve, and a \"jitter\" (+/- 50% by default)  that is calculated and\r\n * added to the base delay. This prevents clients from accidentally\r\n * synchronizing their delays causing spikes of load to the backend.\r\n *\r\n * @private\r\n * @internal\r\n */\nclass ExponentialBackoff {\n  constructor(options = {}) {\n    /**\r\n     * The number of retries that has been attempted.\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\n    this._retryCount = 0;\n    /**\r\n     * The backoff delay of the current attempt.\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\n    this.currentBaseMs = 0;\n    /**\r\n     * Whether we are currently waiting for backoff to complete.\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\n    this.awaitingBackoffCompletion = false;\n    this.initialDelayMs = options.initialDelayMs !== undefined ? options.initialDelayMs : exports.DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n    this.backoffFactor = options.backoffFactor !== undefined ? options.backoffFactor : exports.DEFAULT_BACKOFF_FACTOR;\n    this.maxDelayMs = options.maxDelayMs !== undefined ? options.maxDelayMs : exports.DEFAULT_BACKOFF_MAX_DELAY_MS;\n    this.jitterFactor = options.jitterFactor !== undefined ? options.jitterFactor : DEFAULT_JITTER_FACTOR;\n  }\n  /**\r\n   * Resets the backoff delay and retry count.\r\n   *\r\n   * The very next backoffAndWait() will have no delay. If it is called again\r\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\r\n   * subsequent ones will increase according to the backoffFactor.\r\n   *\r\n   * @private\r\n   * @internal\r\n   */\n  reset() {\n    this._retryCount = 0;\n    this.currentBaseMs = 0;\n  }\n  /**\r\n   * Resets the backoff delay to the maximum delay (e.g. for use after a\r\n   * RESOURCE_EXHAUSTED error).\r\n   *\r\n   * @private\r\n   * @internal\r\n   */\n  resetToMax() {\n    this.currentBaseMs = this.maxDelayMs;\n  }\n  /**\r\n   * Returns a promise that resolves after currentDelayMs, and increases the\r\n   * delay for any subsequent attempts.\r\n   *\r\n   * @return A Promise that resolves when the current delay elapsed.\r\n   * @private\r\n   * @internal\r\n   */\n  backoffAndWait() {\n    if (this.awaitingBackoffCompletion) {\n      return Promise.reject(new Error('A backoff operation is already in progress.'));\n    }\n    if (this.retryCount > exports.MAX_RETRY_ATTEMPTS) {\n      return Promise.reject(new Error('Exceeded maximum number of retries allowed.'));\n    }\n    // First schedule using the current base (which may be 0 and should be\n    // honored as such).\n    const delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n    if (this.currentBaseMs > 0) {\n      (0, logger_1.logger)('ExponentialBackoff.backoffAndWait', null, `Backing off for ${delayWithJitterMs} ms ` + `(base delay: ${this.currentBaseMs} ms)`);\n    }\n    // Apply backoff factor to determine next delay and ensure it is within\n    // bounds.\n    this.currentBaseMs *= this.backoffFactor;\n    this.currentBaseMs = Math.max(this.currentBaseMs, this.initialDelayMs);\n    this.currentBaseMs = Math.min(this.currentBaseMs, this.maxDelayMs);\n    this._retryCount += 1;\n    return new Promise(resolve => {\n      this.awaitingBackoffCompletion = true;\n      (0, exports.delayExecution)(() => {\n        this.awaitingBackoffCompletion = false;\n        resolve();\n      }, delayWithJitterMs);\n    });\n  }\n  // Visible for testing.\n  get retryCount() {\n    return this._retryCount;\n  }\n  /**\r\n   * Returns a randomized \"jitter\" delay based on the current base and jitter\r\n   * factor.\r\n   *\r\n   * @returns {number} The jitter to apply based on the current delay.\r\n   * @private\r\n   * @internal\r\n   */\n  jitterDelayMs() {\n    return (Math.random() - 0.5) * this.jitterFactor * this.currentBaseMs;\n  }\n}\nexports.ExponentialBackoff = ExponentialBackoff;","map":{"version":3,"names":["Object","defineProperty","exports","value","ExponentialBackoff","delayExecution","MAX_RETRY_ATTEMPTS","DEFAULT_BACKOFF_FACTOR","DEFAULT_BACKOFF_MAX_DELAY_MS","DEFAULT_BACKOFF_INITIAL_DELAY_MS","setTimeoutHandler","logger_1","require","DEFAULT_JITTER_FACTOR","setTimeout","handler","f","ms","timeout","hasRef","Error","ref","refresh","unref","Symbol","toPrimitive","constructor","options","_retryCount","currentBaseMs","awaitingBackoffCompletion","initialDelayMs","undefined","backoffFactor","maxDelayMs","jitterFactor","reset","resetToMax","backoffAndWait","Promise","reject","retryCount","delayWithJitterMs","jitterDelayMs","logger","Math","max","min","resolve","random"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@google-cloud/firestore/build/src/backoff.js"],"sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2017 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ExponentialBackoff = exports.delayExecution = exports.MAX_RETRY_ATTEMPTS = exports.DEFAULT_BACKOFF_FACTOR = exports.DEFAULT_BACKOFF_MAX_DELAY_MS = exports.DEFAULT_BACKOFF_INITIAL_DELAY_MS = void 0;\r\nexports.setTimeoutHandler = setTimeoutHandler;\r\nconst logger_1 = require(\"./logger\");\r\n/*\r\n * @module firestore/backoff\r\n * @private\r\n * @internal\r\n *\r\n * Contains backoff logic to facilitate RPC error handling. This class derives\r\n * its implementation from the Firestore Mobile Web Client.\r\n *\r\n * @see https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/remote/backoff.ts\r\n */\r\n/*!\r\n * The default initial backoff time in milliseconds after an error.\r\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\r\n */\r\nexports.DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\r\n/*!\r\n * The default maximum backoff time in milliseconds.\r\n */\r\nexports.DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\r\n/*!\r\n * The default factor to increase the backup by after each failed attempt.\r\n */\r\nexports.DEFAULT_BACKOFF_FACTOR = 1.5;\r\n/*!\r\n * The default jitter to distribute the backoff attempts by (0 means no\r\n * randomization, 1.0 means +/-50% randomization).\r\n */\r\nconst DEFAULT_JITTER_FACTOR = 1.0;\r\n/*!\r\n * The maximum number of retries that will be attempted by backoff\r\n * before stopping all retry attempts.\r\n */\r\nexports.MAX_RETRY_ATTEMPTS = 10;\r\n/*!\r\n * The timeout handler used by `ExponentialBackoff` and `BulkWriter`.\r\n */\r\nexports.delayExecution = setTimeout;\r\n/**\r\n * Allows overriding of the timeout handler used by the exponential backoff\r\n * implementation. If not invoked, we default to `setTimeout()`.\r\n *\r\n * Used only in testing.\r\n *\r\n * @private\r\n * @internal\r\n * @param {function} handler A handler than matches the API of `setTimeout()`.\r\n */\r\nfunction setTimeoutHandler(handler) {\r\n    exports.delayExecution = (f, ms) => {\r\n        handler(f, ms);\r\n        const timeout = {\r\n            hasRef: () => {\r\n                throw new Error('For tests only. Not Implemented');\r\n            },\r\n            ref: () => {\r\n                throw new Error('For tests only. Not Implemented');\r\n            },\r\n            refresh: () => {\r\n                throw new Error('For tests only. Not Implemented');\r\n            },\r\n            unref: () => {\r\n                throw new Error('For tests only. Not Implemented');\r\n            },\r\n            [Symbol.toPrimitive]: () => {\r\n                throw new Error('For tests only. Not Implemented');\r\n            },\r\n        };\r\n        // `NodeJS.Timeout` type signature change:\r\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/66176/files#diff-e838d0ace9cd5f6516bacfbd3ad00d02cd37bd60f9993ce6223f52d889a1fdbaR122-R126\r\n        //\r\n        // Adding `[Symbol.dispose](): void;` cannot be done on older versions of\r\n        // NodeJS. So we simply cast to `NodeJS.Timeout`.\r\n        return timeout;\r\n    };\r\n}\r\n/**\r\n * A helper for running delayed tasks following an exponential backoff curve\r\n * between attempts.\r\n *\r\n * Each delay is made up of a \"base\" delay which follows the exponential\r\n * backoff curve, and a \"jitter\" (+/- 50% by default)  that is calculated and\r\n * added to the base delay. This prevents clients from accidentally\r\n * synchronizing their delays causing spikes of load to the backend.\r\n *\r\n * @private\r\n * @internal\r\n */\r\nclass ExponentialBackoff {\r\n    constructor(options = {}) {\r\n        /**\r\n         * The number of retries that has been attempted.\r\n         *\r\n         * @private\r\n         * @internal\r\n         */\r\n        this._retryCount = 0;\r\n        /**\r\n         * The backoff delay of the current attempt.\r\n         *\r\n         * @private\r\n         * @internal\r\n         */\r\n        this.currentBaseMs = 0;\r\n        /**\r\n         * Whether we are currently waiting for backoff to complete.\r\n         *\r\n         * @private\r\n         * @internal\r\n         */\r\n        this.awaitingBackoffCompletion = false;\r\n        this.initialDelayMs =\r\n            options.initialDelayMs !== undefined\r\n                ? options.initialDelayMs\r\n                : exports.DEFAULT_BACKOFF_INITIAL_DELAY_MS;\r\n        this.backoffFactor =\r\n            options.backoffFactor !== undefined\r\n                ? options.backoffFactor\r\n                : exports.DEFAULT_BACKOFF_FACTOR;\r\n        this.maxDelayMs =\r\n            options.maxDelayMs !== undefined\r\n                ? options.maxDelayMs\r\n                : exports.DEFAULT_BACKOFF_MAX_DELAY_MS;\r\n        this.jitterFactor =\r\n            options.jitterFactor !== undefined\r\n                ? options.jitterFactor\r\n                : DEFAULT_JITTER_FACTOR;\r\n    }\r\n    /**\r\n     * Resets the backoff delay and retry count.\r\n     *\r\n     * The very next backoffAndWait() will have no delay. If it is called again\r\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\r\n     * subsequent ones will increase according to the backoffFactor.\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\r\n    reset() {\r\n        this._retryCount = 0;\r\n        this.currentBaseMs = 0;\r\n    }\r\n    /**\r\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\r\n     * RESOURCE_EXHAUSTED error).\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\r\n    resetToMax() {\r\n        this.currentBaseMs = this.maxDelayMs;\r\n    }\r\n    /**\r\n     * Returns a promise that resolves after currentDelayMs, and increases the\r\n     * delay for any subsequent attempts.\r\n     *\r\n     * @return A Promise that resolves when the current delay elapsed.\r\n     * @private\r\n     * @internal\r\n     */\r\n    backoffAndWait() {\r\n        if (this.awaitingBackoffCompletion) {\r\n            return Promise.reject(new Error('A backoff operation is already in progress.'));\r\n        }\r\n        if (this.retryCount > exports.MAX_RETRY_ATTEMPTS) {\r\n            return Promise.reject(new Error('Exceeded maximum number of retries allowed.'));\r\n        }\r\n        // First schedule using the current base (which may be 0 and should be\r\n        // honored as such).\r\n        const delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\r\n        if (this.currentBaseMs > 0) {\r\n            (0, logger_1.logger)('ExponentialBackoff.backoffAndWait', null, `Backing off for ${delayWithJitterMs} ms ` +\r\n                `(base delay: ${this.currentBaseMs} ms)`);\r\n        }\r\n        // Apply backoff factor to determine next delay and ensure it is within\r\n        // bounds.\r\n        this.currentBaseMs *= this.backoffFactor;\r\n        this.currentBaseMs = Math.max(this.currentBaseMs, this.initialDelayMs);\r\n        this.currentBaseMs = Math.min(this.currentBaseMs, this.maxDelayMs);\r\n        this._retryCount += 1;\r\n        return new Promise(resolve => {\r\n            this.awaitingBackoffCompletion = true;\r\n            (0, exports.delayExecution)(() => {\r\n                this.awaitingBackoffCompletion = false;\r\n                resolve();\r\n            }, delayWithJitterMs);\r\n        });\r\n    }\r\n    // Visible for testing.\r\n    get retryCount() {\r\n        return this._retryCount;\r\n    }\r\n    /**\r\n     * Returns a randomized \"jitter\" delay based on the current base and jitter\r\n     * factor.\r\n     *\r\n     * @returns {number} The jitter to apply based on the current delay.\r\n     * @private\r\n     * @internal\r\n     */\r\n    jitterDelayMs() {\r\n        return (Math.random() - 0.5) * this.jitterFactor * this.currentBaseMs;\r\n    }\r\n}\r\nexports.ExponentialBackoff = ExponentialBackoff;\r\n//# sourceMappingURL=backoff.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}