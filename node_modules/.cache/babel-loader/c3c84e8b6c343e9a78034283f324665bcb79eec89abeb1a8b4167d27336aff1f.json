{"ast":null,"code":"/*! firebase-admin v13.0.1 */\n\"use strict\";\n\n/*!\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserRecord = exports.UserInfo = exports.UserMetadata = exports.MultiFactorSettings = exports.TotpMultiFactorInfo = exports.TotpInfo = exports.PhoneMultiFactorInfo = exports.MultiFactorInfo = void 0;\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst validator_1 = require(\"../utils/validator\");\nconst utils = require(\"../utils\");\nconst error_1 = require(\"../utils/error\");\n/**\r\n * 'REDACTED', encoded as a base64 string.\r\n */\nconst B64_REDACTED = Buffer.from('REDACTED').toString('base64');\n/**\r\n * Parses a time stamp string or number and returns the corresponding date if valid.\r\n *\r\n * @param time - The unix timestamp string or number in milliseconds.\r\n * @returns The corresponding date as a UTC string, if valid. Otherwise, null.\r\n */\nfunction parseDate(time) {\n  try {\n    const date = new Date(parseInt(time, 10));\n    if (!isNaN(date.getTime())) {\n      return date.toUTCString();\n    }\n  } catch (e) {\n    // Do nothing. null will be returned.\n  }\n  return null;\n}\nvar MultiFactorId;\n(function (MultiFactorId) {\n  MultiFactorId[\"Phone\"] = \"phone\";\n  MultiFactorId[\"Totp\"] = \"totp\";\n})(MultiFactorId || (MultiFactorId = {}));\n/**\r\n * Interface representing the common properties of a user-enrolled second factor.\r\n */\nclass MultiFactorInfo {\n  /**\r\n   * Initializes the MultiFactorInfo associated subclass using the server side.\r\n   * If no MultiFactorInfo is associated with the response, null is returned.\r\n   *\r\n   * @param response - The server side response.\r\n   * @internal\r\n   */\n  static initMultiFactorInfo(response) {\n    let multiFactorInfo = null;\n    // PhoneMultiFactorInfo, TotpMultiFactorInfo currently available.\n    try {\n      if (response.phoneInfo !== undefined) {\n        multiFactorInfo = new PhoneMultiFactorInfo(response);\n      } else if (response.totpInfo !== undefined) {\n        multiFactorInfo = new TotpMultiFactorInfo(response);\n      } else {\n        // Ignore the other SDK unsupported MFA factors to prevent blocking developers using the current SDK.\n      }\n    } catch (e) {\n      // Ignore error.\n    }\n    return multiFactorInfo;\n  }\n  /**\r\n   * Initializes the MultiFactorInfo object using the server side response.\r\n   *\r\n   * @param response - The server side response.\r\n   * @constructor\r\n   * @internal\r\n   */\n  constructor(response) {\n    this.initFromServerResponse(response);\n  }\n  /**\r\n   * Returns a JSON-serializable representation of this object.\r\n   *\r\n   * @returns A JSON-serializable representation of this object.\r\n   */\n  toJSON() {\n    return {\n      uid: this.uid,\n      displayName: this.displayName,\n      factorId: this.factorId,\n      enrollmentTime: this.enrollmentTime\n    };\n  }\n  /**\r\n   * Initializes the MultiFactorInfo object using the provided server response.\r\n   *\r\n   * @param response - The server side response.\r\n   */\n  initFromServerResponse(response) {\n    const factorId = response && this.getFactorId(response);\n    if (!factorId || !response || !response.mfaEnrollmentId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor info response');\n    }\n    utils.addReadonlyGetter(this, 'uid', response.mfaEnrollmentId);\n    utils.addReadonlyGetter(this, 'factorId', factorId);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName);\n    // Encoded using [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.\n    // For example, \"2017-01-15T01:30:15.01Z\".\n    // This can be parsed directly via Date constructor.\n    // This can be computed using Data.prototype.toISOString.\n    if (response.enrolledAt) {\n      utils.addReadonlyGetter(this, 'enrollmentTime', new Date(response.enrolledAt).toUTCString());\n    } else {\n      utils.addReadonlyGetter(this, 'enrollmentTime', null);\n    }\n  }\n}\nexports.MultiFactorInfo = MultiFactorInfo;\n/**\r\n * Interface representing a phone specific user-enrolled second factor.\r\n */\nclass PhoneMultiFactorInfo extends MultiFactorInfo {\n  /**\r\n   * Initializes the PhoneMultiFactorInfo object using the server side response.\r\n   *\r\n   * @param response - The server side response.\r\n   * @constructor\r\n   * @internal\r\n   */\n  constructor(response) {\n    super(response);\n    utils.addReadonlyGetter(this, 'phoneNumber', response.phoneInfo);\n  }\n  /**\r\n   * {@inheritdoc MultiFactorInfo.toJSON}\r\n   */\n  toJSON() {\n    return Object.assign(super.toJSON(), {\n      phoneNumber: this.phoneNumber\n    });\n  }\n  /**\r\n   * Returns the factor ID based on the response provided.\r\n   *\r\n   * @param response - The server side response.\r\n   * @returns The multi-factor ID associated with the provided response. If the response is\r\n   *     not associated with any known multi-factor ID, null is returned.\r\n   *\r\n   * @internal\r\n   */\n  getFactorId(response) {\n    return response && response.phoneInfo ? MultiFactorId.Phone : null;\n  }\n}\nexports.PhoneMultiFactorInfo = PhoneMultiFactorInfo;\n/**\r\n * `TotpInfo` struct associated with a second factor\r\n */\nclass TotpInfo {}\nexports.TotpInfo = TotpInfo;\n/**\r\n * Interface representing a TOTP specific user-enrolled second factor.\r\n */\nclass TotpMultiFactorInfo extends MultiFactorInfo {\n  /**\r\n   * Initializes the `TotpMultiFactorInfo` object using the server side response.\r\n   *\r\n   * @param response - The server side response.\r\n   * @constructor\r\n   * @internal\r\n   */\n  constructor(response) {\n    super(response);\n    utils.addReadonlyGetter(this, 'totpInfo', response.totpInfo);\n  }\n  /**\r\n   * {@inheritdoc MultiFactorInfo.toJSON}\r\n   */\n  toJSON() {\n    return Object.assign(super.toJSON(), {\n      totpInfo: this.totpInfo\n    });\n  }\n  /**\r\n   * Returns the factor ID based on the response provided.\r\n   *\r\n   * @param response - The server side response.\r\n   * @returns The multi-factor ID associated with the provided response. If the response is\r\n   *     not associated with any known multi-factor ID, `null` is returned.\r\n   *\r\n   * @internal\r\n   */\n  getFactorId(response) {\n    return response && response.totpInfo ? MultiFactorId.Totp : null;\n  }\n}\nexports.TotpMultiFactorInfo = TotpMultiFactorInfo;\n/**\r\n * The multi-factor related user settings.\r\n */\nclass MultiFactorSettings {\n  /**\r\n   * Initializes the `MultiFactor` object using the server side or JWT format response.\r\n   *\r\n   * @param response - The server side response.\r\n   * @constructor\r\n   * @internal\r\n   */\n  constructor(response) {\n    const parsedEnrolledFactors = [];\n    if (!(0, validator_1.isNonNullObject)(response)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor response');\n    } else if (response.mfaInfo) {\n      response.mfaInfo.forEach(factorResponse => {\n        const multiFactorInfo = MultiFactorInfo.initMultiFactorInfo(factorResponse);\n        if (multiFactorInfo) {\n          parsedEnrolledFactors.push(multiFactorInfo);\n        }\n      });\n    }\n    // Make enrolled factors immutable.\n    utils.addReadonlyGetter(this, 'enrolledFactors', Object.freeze(parsedEnrolledFactors));\n  }\n  /**\r\n   * Returns a JSON-serializable representation of this multi-factor object.\r\n   *\r\n   * @returns A JSON-serializable representation of this multi-factor object.\r\n   */\n  toJSON() {\n    return {\n      enrolledFactors: this.enrolledFactors.map(info => info.toJSON())\n    };\n  }\n}\nexports.MultiFactorSettings = MultiFactorSettings;\n/**\r\n * Represents a user's metadata.\r\n */\nclass UserMetadata {\n  /**\r\n   * @param response - The server side response returned from the `getAccountInfo`\r\n   *     endpoint.\r\n   * @constructor\r\n   * @internal\r\n   */\n  constructor(response) {\n    // Creation date should always be available but due to some backend bugs there\n    // were cases in the past where users did not have creation date properly set.\n    // This included legacy Firebase migrating project users and some anonymous users.\n    // These bugs have already been addressed since then.\n    utils.addReadonlyGetter(this, 'creationTime', parseDate(response.createdAt));\n    utils.addReadonlyGetter(this, 'lastSignInTime', parseDate(response.lastLoginAt));\n    const lastRefreshAt = response.lastRefreshAt ? new Date(response.lastRefreshAt).toUTCString() : null;\n    utils.addReadonlyGetter(this, 'lastRefreshTime', lastRefreshAt);\n  }\n  /**\r\n   * Returns a JSON-serializable representation of this object.\r\n   *\r\n   * @returns A JSON-serializable representation of this object.\r\n   */\n  toJSON() {\n    return {\n      lastSignInTime: this.lastSignInTime,\n      creationTime: this.creationTime,\n      lastRefreshTime: this.lastRefreshTime\n    };\n  }\n}\nexports.UserMetadata = UserMetadata;\n/**\r\n * Represents a user's info from a third-party identity provider\r\n * such as Google or Facebook.\r\n */\nclass UserInfo {\n  /**\r\n   * @param response - The server side response returned from the `getAccountInfo`\r\n   *     endpoint.\r\n   * @constructor\r\n   * @internal\r\n   */\n  constructor(response) {\n    // Provider user id and provider id are required.\n    if (!response.rawId || !response.providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user info response');\n    }\n    utils.addReadonlyGetter(this, 'uid', response.rawId);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName);\n    utils.addReadonlyGetter(this, 'email', response.email);\n    utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\n    utils.addReadonlyGetter(this, 'providerId', response.providerId);\n    utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\n  }\n  /**\r\n   * Returns a JSON-serializable representation of this object.\r\n   *\r\n   * @returns A JSON-serializable representation of this object.\r\n   */\n  toJSON() {\n    return {\n      uid: this.uid,\n      displayName: this.displayName,\n      email: this.email,\n      photoURL: this.photoURL,\n      providerId: this.providerId,\n      phoneNumber: this.phoneNumber\n    };\n  }\n}\nexports.UserInfo = UserInfo;\n/**\r\n * Represents a user.\r\n */\nclass UserRecord {\n  /**\r\n   * @param response - The server side response returned from the getAccountInfo\r\n   *     endpoint.\r\n   * @constructor\r\n   * @internal\r\n   */\n  constructor(response) {\n    // The Firebase user id is required.\n    if (!response.localId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user response');\n    }\n    utils.addReadonlyGetter(this, 'uid', response.localId);\n    utils.addReadonlyGetter(this, 'email', response.email);\n    utils.addReadonlyGetter(this, 'emailVerified', !!response.emailVerified);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName);\n    utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\n    utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\n    // If disabled is not provided, the account is enabled by default.\n    utils.addReadonlyGetter(this, 'disabled', response.disabled || false);\n    utils.addReadonlyGetter(this, 'metadata', new UserMetadata(response));\n    const providerData = [];\n    for (const entry of response.providerUserInfo || []) {\n      providerData.push(new UserInfo(entry));\n    }\n    utils.addReadonlyGetter(this, 'providerData', providerData);\n    // If the password hash is redacted (probably due to missing permissions)\n    // then clear it out, similar to how the salt is returned. (Otherwise, it\n    // *looks* like a b64-encoded hash is present, which is confusing.)\n    if (response.passwordHash === B64_REDACTED) {\n      utils.addReadonlyGetter(this, 'passwordHash', undefined);\n    } else {\n      utils.addReadonlyGetter(this, 'passwordHash', response.passwordHash);\n    }\n    utils.addReadonlyGetter(this, 'passwordSalt', response.salt);\n    if (response.customAttributes) {\n      utils.addReadonlyGetter(this, 'customClaims', JSON.parse(response.customAttributes));\n    }\n    let validAfterTime = null;\n    // Convert validSince first to UTC milliseconds and then to UTC date string.\n    if (typeof response.validSince !== 'undefined') {\n      validAfterTime = parseDate(parseInt(response.validSince, 10) * 1000);\n    }\n    utils.addReadonlyGetter(this, 'tokensValidAfterTime', validAfterTime || undefined);\n    utils.addReadonlyGetter(this, 'tenantId', response.tenantId);\n    const multiFactor = new MultiFactorSettings(response);\n    if (multiFactor.enrolledFactors.length > 0) {\n      utils.addReadonlyGetter(this, 'multiFactor', multiFactor);\n    }\n  }\n  /**\r\n   * Returns a JSON-serializable representation of this object.\r\n   *\r\n   * @returns A JSON-serializable representation of this object.\r\n   */\n  toJSON() {\n    const json = {\n      uid: this.uid,\n      email: this.email,\n      emailVerified: this.emailVerified,\n      displayName: this.displayName,\n      photoURL: this.photoURL,\n      phoneNumber: this.phoneNumber,\n      disabled: this.disabled,\n      // Convert metadata to json.\n      metadata: this.metadata.toJSON(),\n      passwordHash: this.passwordHash,\n      passwordSalt: this.passwordSalt,\n      customClaims: (0, deep_copy_1.deepCopy)(this.customClaims),\n      tokensValidAfterTime: this.tokensValidAfterTime,\n      tenantId: this.tenantId\n    };\n    if (this.multiFactor) {\n      json.multiFactor = this.multiFactor.toJSON();\n    }\n    json.providerData = [];\n    for (const entry of this.providerData) {\n      // Convert each provider data to json.\n      json.providerData.push(entry.toJSON());\n    }\n    return json;\n  }\n}\nexports.UserRecord = UserRecord;","map":{"version":3,"names":["Object","defineProperty","exports","value","UserRecord","UserInfo","UserMetadata","MultiFactorSettings","TotpMultiFactorInfo","TotpInfo","PhoneMultiFactorInfo","MultiFactorInfo","deep_copy_1","require","validator_1","utils","error_1","B64_REDACTED","Buffer","from","toString","parseDate","time","date","Date","parseInt","isNaN","getTime","toUTCString","e","MultiFactorId","initMultiFactorInfo","response","multiFactorInfo","phoneInfo","undefined","totpInfo","constructor","initFromServerResponse","toJSON","uid","displayName","factorId","enrollmentTime","getFactorId","mfaEnrollmentId","FirebaseAuthError","AuthClientErrorCode","INTERNAL_ERROR","addReadonlyGetter","enrolledAt","assign","phoneNumber","Phone","Totp","parsedEnrolledFactors","isNonNullObject","mfaInfo","forEach","factorResponse","push","freeze","enrolledFactors","map","info","createdAt","lastLoginAt","lastRefreshAt","lastSignInTime","creationTime","lastRefreshTime","rawId","providerId","email","photoUrl","photoURL","localId","emailVerified","disabled","providerData","entry","providerUserInfo","passwordHash","salt","customAttributes","JSON","parse","validAfterTime","validSince","tenantId","multiFactor","length","json","metadata","passwordSalt","customClaims","deepCopy","tokensValidAfterTime"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/firebase-admin/lib/auth/user-record.js"],"sourcesContent":["/*! firebase-admin v13.0.1 */\r\n\"use strict\";\r\n/*!\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UserRecord = exports.UserInfo = exports.UserMetadata = exports.MultiFactorSettings = exports.TotpMultiFactorInfo = exports.TotpInfo = exports.PhoneMultiFactorInfo = exports.MultiFactorInfo = void 0;\r\nconst deep_copy_1 = require(\"../utils/deep-copy\");\r\nconst validator_1 = require(\"../utils/validator\");\r\nconst utils = require(\"../utils\");\r\nconst error_1 = require(\"../utils/error\");\r\n/**\r\n * 'REDACTED', encoded as a base64 string.\r\n */\r\nconst B64_REDACTED = Buffer.from('REDACTED').toString('base64');\r\n/**\r\n * Parses a time stamp string or number and returns the corresponding date if valid.\r\n *\r\n * @param time - The unix timestamp string or number in milliseconds.\r\n * @returns The corresponding date as a UTC string, if valid. Otherwise, null.\r\n */\r\nfunction parseDate(time) {\r\n    try {\r\n        const date = new Date(parseInt(time, 10));\r\n        if (!isNaN(date.getTime())) {\r\n            return date.toUTCString();\r\n        }\r\n    }\r\n    catch (e) {\r\n        // Do nothing. null will be returned.\r\n    }\r\n    return null;\r\n}\r\nvar MultiFactorId;\r\n(function (MultiFactorId) {\r\n    MultiFactorId[\"Phone\"] = \"phone\";\r\n    MultiFactorId[\"Totp\"] = \"totp\";\r\n})(MultiFactorId || (MultiFactorId = {}));\r\n/**\r\n * Interface representing the common properties of a user-enrolled second factor.\r\n */\r\nclass MultiFactorInfo {\r\n    /**\r\n     * Initializes the MultiFactorInfo associated subclass using the server side.\r\n     * If no MultiFactorInfo is associated with the response, null is returned.\r\n     *\r\n     * @param response - The server side response.\r\n     * @internal\r\n     */\r\n    static initMultiFactorInfo(response) {\r\n        let multiFactorInfo = null;\r\n        // PhoneMultiFactorInfo, TotpMultiFactorInfo currently available.\r\n        try {\r\n            if (response.phoneInfo !== undefined) {\r\n                multiFactorInfo = new PhoneMultiFactorInfo(response);\r\n            }\r\n            else if (response.totpInfo !== undefined) {\r\n                multiFactorInfo = new TotpMultiFactorInfo(response);\r\n            }\r\n            else {\r\n                // Ignore the other SDK unsupported MFA factors to prevent blocking developers using the current SDK.\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Ignore error.\r\n        }\r\n        return multiFactorInfo;\r\n    }\r\n    /**\r\n     * Initializes the MultiFactorInfo object using the server side response.\r\n     *\r\n     * @param response - The server side response.\r\n     * @constructor\r\n     * @internal\r\n     */\r\n    constructor(response) {\r\n        this.initFromServerResponse(response);\r\n    }\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     *\r\n     * @returns A JSON-serializable representation of this object.\r\n     */\r\n    toJSON() {\r\n        return {\r\n            uid: this.uid,\r\n            displayName: this.displayName,\r\n            factorId: this.factorId,\r\n            enrollmentTime: this.enrollmentTime,\r\n        };\r\n    }\r\n    /**\r\n     * Initializes the MultiFactorInfo object using the provided server response.\r\n     *\r\n     * @param response - The server side response.\r\n     */\r\n    initFromServerResponse(response) {\r\n        const factorId = response && this.getFactorId(response);\r\n        if (!factorId || !response || !response.mfaEnrollmentId) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor info response');\r\n        }\r\n        utils.addReadonlyGetter(this, 'uid', response.mfaEnrollmentId);\r\n        utils.addReadonlyGetter(this, 'factorId', factorId);\r\n        utils.addReadonlyGetter(this, 'displayName', response.displayName);\r\n        // Encoded using [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.\r\n        // For example, \"2017-01-15T01:30:15.01Z\".\r\n        // This can be parsed directly via Date constructor.\r\n        // This can be computed using Data.prototype.toISOString.\r\n        if (response.enrolledAt) {\r\n            utils.addReadonlyGetter(this, 'enrollmentTime', new Date(response.enrolledAt).toUTCString());\r\n        }\r\n        else {\r\n            utils.addReadonlyGetter(this, 'enrollmentTime', null);\r\n        }\r\n    }\r\n}\r\nexports.MultiFactorInfo = MultiFactorInfo;\r\n/**\r\n * Interface representing a phone specific user-enrolled second factor.\r\n */\r\nclass PhoneMultiFactorInfo extends MultiFactorInfo {\r\n    /**\r\n     * Initializes the PhoneMultiFactorInfo object using the server side response.\r\n     *\r\n     * @param response - The server side response.\r\n     * @constructor\r\n     * @internal\r\n     */\r\n    constructor(response) {\r\n        super(response);\r\n        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneInfo);\r\n    }\r\n    /**\r\n     * {@inheritdoc MultiFactorInfo.toJSON}\r\n     */\r\n    toJSON() {\r\n        return Object.assign(super.toJSON(), {\r\n            phoneNumber: this.phoneNumber,\r\n        });\r\n    }\r\n    /**\r\n     * Returns the factor ID based on the response provided.\r\n     *\r\n     * @param response - The server side response.\r\n     * @returns The multi-factor ID associated with the provided response. If the response is\r\n     *     not associated with any known multi-factor ID, null is returned.\r\n     *\r\n     * @internal\r\n     */\r\n    getFactorId(response) {\r\n        return (response && response.phoneInfo) ? MultiFactorId.Phone : null;\r\n    }\r\n}\r\nexports.PhoneMultiFactorInfo = PhoneMultiFactorInfo;\r\n/**\r\n * `TotpInfo` struct associated with a second factor\r\n */\r\nclass TotpInfo {\r\n}\r\nexports.TotpInfo = TotpInfo;\r\n/**\r\n * Interface representing a TOTP specific user-enrolled second factor.\r\n */\r\nclass TotpMultiFactorInfo extends MultiFactorInfo {\r\n    /**\r\n     * Initializes the `TotpMultiFactorInfo` object using the server side response.\r\n     *\r\n     * @param response - The server side response.\r\n     * @constructor\r\n     * @internal\r\n     */\r\n    constructor(response) {\r\n        super(response);\r\n        utils.addReadonlyGetter(this, 'totpInfo', response.totpInfo);\r\n    }\r\n    /**\r\n     * {@inheritdoc MultiFactorInfo.toJSON}\r\n     */\r\n    toJSON() {\r\n        return Object.assign(super.toJSON(), {\r\n            totpInfo: this.totpInfo,\r\n        });\r\n    }\r\n    /**\r\n     * Returns the factor ID based on the response provided.\r\n     *\r\n     * @param response - The server side response.\r\n     * @returns The multi-factor ID associated with the provided response. If the response is\r\n     *     not associated with any known multi-factor ID, `null` is returned.\r\n     *\r\n     * @internal\r\n     */\r\n    getFactorId(response) {\r\n        return (response && response.totpInfo) ? MultiFactorId.Totp : null;\r\n    }\r\n}\r\nexports.TotpMultiFactorInfo = TotpMultiFactorInfo;\r\n/**\r\n * The multi-factor related user settings.\r\n */\r\nclass MultiFactorSettings {\r\n    /**\r\n     * Initializes the `MultiFactor` object using the server side or JWT format response.\r\n     *\r\n     * @param response - The server side response.\r\n     * @constructor\r\n     * @internal\r\n     */\r\n    constructor(response) {\r\n        const parsedEnrolledFactors = [];\r\n        if (!(0, validator_1.isNonNullObject)(response)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor response');\r\n        }\r\n        else if (response.mfaInfo) {\r\n            response.mfaInfo.forEach((factorResponse) => {\r\n                const multiFactorInfo = MultiFactorInfo.initMultiFactorInfo(factorResponse);\r\n                if (multiFactorInfo) {\r\n                    parsedEnrolledFactors.push(multiFactorInfo);\r\n                }\r\n            });\r\n        }\r\n        // Make enrolled factors immutable.\r\n        utils.addReadonlyGetter(this, 'enrolledFactors', Object.freeze(parsedEnrolledFactors));\r\n    }\r\n    /**\r\n     * Returns a JSON-serializable representation of this multi-factor object.\r\n     *\r\n     * @returns A JSON-serializable representation of this multi-factor object.\r\n     */\r\n    toJSON() {\r\n        return {\r\n            enrolledFactors: this.enrolledFactors.map((info) => info.toJSON()),\r\n        };\r\n    }\r\n}\r\nexports.MultiFactorSettings = MultiFactorSettings;\r\n/**\r\n * Represents a user's metadata.\r\n */\r\nclass UserMetadata {\r\n    /**\r\n     * @param response - The server side response returned from the `getAccountInfo`\r\n     *     endpoint.\r\n     * @constructor\r\n     * @internal\r\n     */\r\n    constructor(response) {\r\n        // Creation date should always be available but due to some backend bugs there\r\n        // were cases in the past where users did not have creation date properly set.\r\n        // This included legacy Firebase migrating project users and some anonymous users.\r\n        // These bugs have already been addressed since then.\r\n        utils.addReadonlyGetter(this, 'creationTime', parseDate(response.createdAt));\r\n        utils.addReadonlyGetter(this, 'lastSignInTime', parseDate(response.lastLoginAt));\r\n        const lastRefreshAt = response.lastRefreshAt ? new Date(response.lastRefreshAt).toUTCString() : null;\r\n        utils.addReadonlyGetter(this, 'lastRefreshTime', lastRefreshAt);\r\n    }\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     *\r\n     * @returns A JSON-serializable representation of this object.\r\n     */\r\n    toJSON() {\r\n        return {\r\n            lastSignInTime: this.lastSignInTime,\r\n            creationTime: this.creationTime,\r\n            lastRefreshTime: this.lastRefreshTime,\r\n        };\r\n    }\r\n}\r\nexports.UserMetadata = UserMetadata;\r\n/**\r\n * Represents a user's info from a third-party identity provider\r\n * such as Google or Facebook.\r\n */\r\nclass UserInfo {\r\n    /**\r\n     * @param response - The server side response returned from the `getAccountInfo`\r\n     *     endpoint.\r\n     * @constructor\r\n     * @internal\r\n     */\r\n    constructor(response) {\r\n        // Provider user id and provider id are required.\r\n        if (!response.rawId || !response.providerId) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user info response');\r\n        }\r\n        utils.addReadonlyGetter(this, 'uid', response.rawId);\r\n        utils.addReadonlyGetter(this, 'displayName', response.displayName);\r\n        utils.addReadonlyGetter(this, 'email', response.email);\r\n        utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\r\n        utils.addReadonlyGetter(this, 'providerId', response.providerId);\r\n        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\r\n    }\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     *\r\n     * @returns A JSON-serializable representation of this object.\r\n     */\r\n    toJSON() {\r\n        return {\r\n            uid: this.uid,\r\n            displayName: this.displayName,\r\n            email: this.email,\r\n            photoURL: this.photoURL,\r\n            providerId: this.providerId,\r\n            phoneNumber: this.phoneNumber,\r\n        };\r\n    }\r\n}\r\nexports.UserInfo = UserInfo;\r\n/**\r\n * Represents a user.\r\n */\r\nclass UserRecord {\r\n    /**\r\n     * @param response - The server side response returned from the getAccountInfo\r\n     *     endpoint.\r\n     * @constructor\r\n     * @internal\r\n     */\r\n    constructor(response) {\r\n        // The Firebase user id is required.\r\n        if (!response.localId) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user response');\r\n        }\r\n        utils.addReadonlyGetter(this, 'uid', response.localId);\r\n        utils.addReadonlyGetter(this, 'email', response.email);\r\n        utils.addReadonlyGetter(this, 'emailVerified', !!response.emailVerified);\r\n        utils.addReadonlyGetter(this, 'displayName', response.displayName);\r\n        utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\r\n        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\r\n        // If disabled is not provided, the account is enabled by default.\r\n        utils.addReadonlyGetter(this, 'disabled', response.disabled || false);\r\n        utils.addReadonlyGetter(this, 'metadata', new UserMetadata(response));\r\n        const providerData = [];\r\n        for (const entry of (response.providerUserInfo || [])) {\r\n            providerData.push(new UserInfo(entry));\r\n        }\r\n        utils.addReadonlyGetter(this, 'providerData', providerData);\r\n        // If the password hash is redacted (probably due to missing permissions)\r\n        // then clear it out, similar to how the salt is returned. (Otherwise, it\r\n        // *looks* like a b64-encoded hash is present, which is confusing.)\r\n        if (response.passwordHash === B64_REDACTED) {\r\n            utils.addReadonlyGetter(this, 'passwordHash', undefined);\r\n        }\r\n        else {\r\n            utils.addReadonlyGetter(this, 'passwordHash', response.passwordHash);\r\n        }\r\n        utils.addReadonlyGetter(this, 'passwordSalt', response.salt);\r\n        if (response.customAttributes) {\r\n            utils.addReadonlyGetter(this, 'customClaims', JSON.parse(response.customAttributes));\r\n        }\r\n        let validAfterTime = null;\r\n        // Convert validSince first to UTC milliseconds and then to UTC date string.\r\n        if (typeof response.validSince !== 'undefined') {\r\n            validAfterTime = parseDate(parseInt(response.validSince, 10) * 1000);\r\n        }\r\n        utils.addReadonlyGetter(this, 'tokensValidAfterTime', validAfterTime || undefined);\r\n        utils.addReadonlyGetter(this, 'tenantId', response.tenantId);\r\n        const multiFactor = new MultiFactorSettings(response);\r\n        if (multiFactor.enrolledFactors.length > 0) {\r\n            utils.addReadonlyGetter(this, 'multiFactor', multiFactor);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     *\r\n     * @returns A JSON-serializable representation of this object.\r\n     */\r\n    toJSON() {\r\n        const json = {\r\n            uid: this.uid,\r\n            email: this.email,\r\n            emailVerified: this.emailVerified,\r\n            displayName: this.displayName,\r\n            photoURL: this.photoURL,\r\n            phoneNumber: this.phoneNumber,\r\n            disabled: this.disabled,\r\n            // Convert metadata to json.\r\n            metadata: this.metadata.toJSON(),\r\n            passwordHash: this.passwordHash,\r\n            passwordSalt: this.passwordSalt,\r\n            customClaims: (0, deep_copy_1.deepCopy)(this.customClaims),\r\n            tokensValidAfterTime: this.tokensValidAfterTime,\r\n            tenantId: this.tenantId,\r\n        };\r\n        if (this.multiFactor) {\r\n            json.multiFactor = this.multiFactor.toJSON();\r\n        }\r\n        json.providerData = [];\r\n        for (const entry of this.providerData) {\r\n            // Convert each provider data to json.\r\n            json.providerData.push(entry.toJSON());\r\n        }\r\n        return json;\r\n    }\r\n}\r\nexports.UserRecord = UserRecord;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}