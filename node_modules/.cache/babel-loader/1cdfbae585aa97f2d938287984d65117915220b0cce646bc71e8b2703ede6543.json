{"ast":null,"code":"/**\r\n * Password-Based Key-Derivation Function #2 implementation.\r\n *\r\n * See RFC 2898 for details.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\r\n */\nvar forge = require('./forge');\nrequire('./hmac');\nrequire('./md');\nrequire('./util');\nvar pkcs5 = forge.pkcs5 = forge.pkcs5 || {};\nvar crypto;\nif (forge.util.isNodejs && !forge.options.usePureJavaScript) {\n  crypto = require('crypto');\n}\n\n/**\r\n * Derives a key from a password.\r\n *\r\n * @param p the password as a binary-encoded string of bytes.\r\n * @param s the salt as a binary-encoded string of bytes.\r\n * @param c the iteration count, a positive integer.\r\n * @param dkLen the intended length, in bytes, of the derived key,\r\n *          (max: 2^32 - 1) * hash length of the PRF.\r\n * @param [md] the message digest (or algorithm identifier as a string) to use\r\n *          in the PRF, defaults to SHA-1.\r\n * @param [callback(err, key)] presence triggers asynchronous version, called\r\n *          once the operation completes.\r\n *\r\n * @return the derived key, as a binary-encoded string of bytes, for the\r\n *           synchronous version (if no callback is specified).\r\n */\nmodule.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function (p, s, c, dkLen, md, callback) {\n  if (typeof md === 'function') {\n    callback = md;\n    md = null;\n  }\n\n  // use native implementation if possible and not disabled, note that\n  // some node versions only support SHA-1, others allow digest to be changed\n  if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || typeof md !== 'object') && (crypto.pbkdf2Sync.length > 4 || !md || md === 'sha1')) {\n    if (typeof md !== 'string') {\n      // default prf to SHA-1\n      md = 'sha1';\n    }\n    p = Buffer.from(p, 'binary');\n    s = Buffer.from(s, 'binary');\n    if (!callback) {\n      if (crypto.pbkdf2Sync.length === 4) {\n        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');\n      }\n      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');\n    }\n    if (crypto.pbkdf2Sync.length === 4) {\n      return crypto.pbkdf2(p, s, c, dkLen, function (err, key) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, key.toString('binary'));\n      });\n    }\n    return crypto.pbkdf2(p, s, c, dkLen, md, function (err, key) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, key.toString('binary'));\n    });\n  }\n  if (typeof md === 'undefined' || md === null) {\n    // default prf to SHA-1\n    md = 'sha1';\n  }\n  if (typeof md === 'string') {\n    if (!(md in forge.md.algorithms)) {\n      throw new Error('Unknown hash algorithm: ' + md);\n    }\n    md = forge.md[md].create();\n  }\n  var hLen = md.digestLength;\n\n  /* 1. If dkLen > (2^32 - 1) * hLen, output \"derived key too long\" and\r\n    stop. */\n  if (dkLen > 0xFFFFFFFF * hLen) {\n    var err = new Error('Derived key is too long.');\n    if (callback) {\n      return callback(err);\n    }\n    throw err;\n  }\n\n  /* 2. Let len be the number of hLen-octet blocks in the derived key,\r\n    rounding up, and let r be the number of octets in the last\r\n    block:\r\n      len = CEIL(dkLen / hLen),\r\n    r = dkLen - (len - 1) * hLen. */\n  var len = Math.ceil(dkLen / hLen);\n  var r = dkLen - (len - 1) * hLen;\n\n  /* 3. For each block of the derived key apply the function F defined\r\n    below to the password P, the salt S, the iteration count c, and\r\n    the block index to compute the block:\r\n      T_1 = F(P, S, c, 1),\r\n    T_2 = F(P, S, c, 2),\r\n    ...\r\n    T_len = F(P, S, c, len),\r\n      where the function F is defined as the exclusive-or sum of the\r\n    first c iterates of the underlying pseudorandom function PRF\r\n    applied to the password P and the concatenation of the salt S\r\n    and the block index i:\r\n      F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c\r\n      where\r\n      u_1 = PRF(P, S || INT(i)),\r\n    u_2 = PRF(P, u_1),\r\n    ...\r\n    u_c = PRF(P, u_{c-1}).\r\n      Here, INT(i) is a four-octet encoding of the integer i, most\r\n    significant octet first. */\n  var prf = forge.hmac.create();\n  prf.start(md, p);\n  var dk = '';\n  var xor, u_c, u_c1;\n\n  // sync version\n  if (!callback) {\n    for (var i = 1; i <= len; ++i) {\n      // PRF(P, S || INT(i)) (first iteration)\n      prf.start(null, null);\n      prf.update(s);\n      prf.update(forge.util.int32ToBytes(i));\n      xor = u_c1 = prf.digest().getBytes();\n\n      // PRF(P, u_{c-1}) (other iterations)\n      for (var j = 2; j <= c; ++j) {\n        prf.start(null, null);\n        prf.update(u_c1);\n        u_c = prf.digest().getBytes();\n        // F(p, s, c, i)\n        xor = forge.util.xorBytes(xor, u_c, hLen);\n        u_c1 = u_c;\n      }\n\n      /* 4. Concatenate the blocks and extract the first dkLen octets to\r\n        produce a derived key DK:\r\n          DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\n      dk += i < len ? xor : xor.substr(0, r);\n    }\n    /* 5. Output the derived key DK. */\n    return dk;\n  }\n\n  // async version\n  var i = 1,\n    j;\n  function outer() {\n    if (i > len) {\n      // done\n      return callback(null, dk);\n    }\n\n    // PRF(P, S || INT(i)) (first iteration)\n    prf.start(null, null);\n    prf.update(s);\n    prf.update(forge.util.int32ToBytes(i));\n    xor = u_c1 = prf.digest().getBytes();\n\n    // PRF(P, u_{c-1}) (other iterations)\n    j = 2;\n    inner();\n  }\n  function inner() {\n    if (j <= c) {\n      prf.start(null, null);\n      prf.update(u_c1);\n      u_c = prf.digest().getBytes();\n      // F(p, s, c, i)\n      xor = forge.util.xorBytes(xor, u_c, hLen);\n      u_c1 = u_c;\n      ++j;\n      return forge.util.setImmediate(inner);\n    }\n\n    /* 4. Concatenate the blocks and extract the first dkLen octets to\r\n      produce a derived key DK:\r\n        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\n    dk += i < len ? xor : xor.substr(0, r);\n    ++i;\n    outer();\n  }\n  outer();\n};","map":{"version":3,"names":["forge","require","pkcs5","crypto","util","isNodejs","options","usePureJavaScript","module","exports","pbkdf2","p","s","c","dkLen","md","callback","pbkdf2Sync","length","Buffer","from","toString","err","key","algorithms","Error","create","hLen","digestLength","len","Math","ceil","r","prf","hmac","start","dk","xor","u_c","u_c1","i","update","int32ToBytes","digest","getBytes","j","xorBytes","substr","outer","inner","setImmediate"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/node-forge/lib/pbkdf2.js"],"sourcesContent":["/**\r\n * Password-Based Key-Derivation Function #2 implementation.\r\n *\r\n * See RFC 2898 for details.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\r\n */\r\nvar forge = require('./forge');\r\nrequire('./hmac');\r\nrequire('./md');\r\nrequire('./util');\r\n\r\nvar pkcs5 = forge.pkcs5 = forge.pkcs5 || {};\r\n\r\nvar crypto;\r\nif(forge.util.isNodejs && !forge.options.usePureJavaScript) {\r\n  crypto = require('crypto');\r\n}\r\n\r\n/**\r\n * Derives a key from a password.\r\n *\r\n * @param p the password as a binary-encoded string of bytes.\r\n * @param s the salt as a binary-encoded string of bytes.\r\n * @param c the iteration count, a positive integer.\r\n * @param dkLen the intended length, in bytes, of the derived key,\r\n *          (max: 2^32 - 1) * hash length of the PRF.\r\n * @param [md] the message digest (or algorithm identifier as a string) to use\r\n *          in the PRF, defaults to SHA-1.\r\n * @param [callback(err, key)] presence triggers asynchronous version, called\r\n *          once the operation completes.\r\n *\r\n * @return the derived key, as a binary-encoded string of bytes, for the\r\n *           synchronous version (if no callback is specified).\r\n */\r\nmodule.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(\r\n  p, s, c, dkLen, md, callback) {\r\n  if(typeof md === 'function') {\r\n    callback = md;\r\n    md = null;\r\n  }\r\n\r\n  // use native implementation if possible and not disabled, note that\r\n  // some node versions only support SHA-1, others allow digest to be changed\r\n  if(forge.util.isNodejs && !forge.options.usePureJavaScript &&\r\n    crypto.pbkdf2 && (md === null || typeof md !== 'object') &&\r\n    (crypto.pbkdf2Sync.length > 4 || (!md || md === 'sha1'))) {\r\n    if(typeof md !== 'string') {\r\n      // default prf to SHA-1\r\n      md = 'sha1';\r\n    }\r\n    p = Buffer.from(p, 'binary');\r\n    s = Buffer.from(s, 'binary');\r\n    if(!callback) {\r\n      if(crypto.pbkdf2Sync.length === 4) {\r\n        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');\r\n      }\r\n      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');\r\n    }\r\n    if(crypto.pbkdf2Sync.length === 4) {\r\n      return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {\r\n        if(err) {\r\n          return callback(err);\r\n        }\r\n        callback(null, key.toString('binary'));\r\n      });\r\n    }\r\n    return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {\r\n      if(err) {\r\n        return callback(err);\r\n      }\r\n      callback(null, key.toString('binary'));\r\n    });\r\n  }\r\n\r\n  if(typeof md === 'undefined' || md === null) {\r\n    // default prf to SHA-1\r\n    md = 'sha1';\r\n  }\r\n  if(typeof md === 'string') {\r\n    if(!(md in forge.md.algorithms)) {\r\n      throw new Error('Unknown hash algorithm: ' + md);\r\n    }\r\n    md = forge.md[md].create();\r\n  }\r\n\r\n  var hLen = md.digestLength;\r\n\r\n  /* 1. If dkLen > (2^32 - 1) * hLen, output \"derived key too long\" and\r\n    stop. */\r\n  if(dkLen > (0xFFFFFFFF * hLen)) {\r\n    var err = new Error('Derived key is too long.');\r\n    if(callback) {\r\n      return callback(err);\r\n    }\r\n    throw err;\r\n  }\r\n\r\n  /* 2. Let len be the number of hLen-octet blocks in the derived key,\r\n    rounding up, and let r be the number of octets in the last\r\n    block:\r\n\r\n    len = CEIL(dkLen / hLen),\r\n    r = dkLen - (len - 1) * hLen. */\r\n  var len = Math.ceil(dkLen / hLen);\r\n  var r = dkLen - (len - 1) * hLen;\r\n\r\n  /* 3. For each block of the derived key apply the function F defined\r\n    below to the password P, the salt S, the iteration count c, and\r\n    the block index to compute the block:\r\n\r\n    T_1 = F(P, S, c, 1),\r\n    T_2 = F(P, S, c, 2),\r\n    ...\r\n    T_len = F(P, S, c, len),\r\n\r\n    where the function F is defined as the exclusive-or sum of the\r\n    first c iterates of the underlying pseudorandom function PRF\r\n    applied to the password P and the concatenation of the salt S\r\n    and the block index i:\r\n\r\n    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c\r\n\r\n    where\r\n\r\n    u_1 = PRF(P, S || INT(i)),\r\n    u_2 = PRF(P, u_1),\r\n    ...\r\n    u_c = PRF(P, u_{c-1}).\r\n\r\n    Here, INT(i) is a four-octet encoding of the integer i, most\r\n    significant octet first. */\r\n  var prf = forge.hmac.create();\r\n  prf.start(md, p);\r\n  var dk = '';\r\n  var xor, u_c, u_c1;\r\n\r\n  // sync version\r\n  if(!callback) {\r\n    for(var i = 1; i <= len; ++i) {\r\n      // PRF(P, S || INT(i)) (first iteration)\r\n      prf.start(null, null);\r\n      prf.update(s);\r\n      prf.update(forge.util.int32ToBytes(i));\r\n      xor = u_c1 = prf.digest().getBytes();\r\n\r\n      // PRF(P, u_{c-1}) (other iterations)\r\n      for(var j = 2; j <= c; ++j) {\r\n        prf.start(null, null);\r\n        prf.update(u_c1);\r\n        u_c = prf.digest().getBytes();\r\n        // F(p, s, c, i)\r\n        xor = forge.util.xorBytes(xor, u_c, hLen);\r\n        u_c1 = u_c;\r\n      }\r\n\r\n      /* 4. Concatenate the blocks and extract the first dkLen octets to\r\n        produce a derived key DK:\r\n\r\n        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\r\n      dk += (i < len) ? xor : xor.substr(0, r);\r\n    }\r\n    /* 5. Output the derived key DK. */\r\n    return dk;\r\n  }\r\n\r\n  // async version\r\n  var i = 1, j;\r\n  function outer() {\r\n    if(i > len) {\r\n      // done\r\n      return callback(null, dk);\r\n    }\r\n\r\n    // PRF(P, S || INT(i)) (first iteration)\r\n    prf.start(null, null);\r\n    prf.update(s);\r\n    prf.update(forge.util.int32ToBytes(i));\r\n    xor = u_c1 = prf.digest().getBytes();\r\n\r\n    // PRF(P, u_{c-1}) (other iterations)\r\n    j = 2;\r\n    inner();\r\n  }\r\n\r\n  function inner() {\r\n    if(j <= c) {\r\n      prf.start(null, null);\r\n      prf.update(u_c1);\r\n      u_c = prf.digest().getBytes();\r\n      // F(p, s, c, i)\r\n      xor = forge.util.xorBytes(xor, u_c, hLen);\r\n      u_c1 = u_c;\r\n      ++j;\r\n      return forge.util.setImmediate(inner);\r\n    }\r\n\r\n    /* 4. Concatenate the blocks and extract the first dkLen octets to\r\n      produce a derived key DK:\r\n\r\n      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\r\n    dk += (i < len) ? xor : xor.substr(0, r);\r\n\r\n    ++i;\r\n    outer();\r\n  }\r\n\r\n  outer();\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}