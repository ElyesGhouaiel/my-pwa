{"ast":null,"code":"/*! firebase-admin v13.0.1 */\n\"use strict\";\n\n/*!\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TenantAwareAuthRequestHandler = exports.AuthRequestHandler = exports.AbstractAuthRequestHandler = exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = exports.FIREBASE_AUTH_DELETE_ACCOUNT = exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = exports.EMAIL_ACTION_REQUEST_TYPES = exports.RESERVED_CLAIMS = void 0;\nexports.useEmulator = useEmulator;\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\nconst api_request_1 = require(\"../utils/api-request\");\nconst utils = require(\"../utils/index\");\nconst user_import_builder_1 = require(\"./user-import-builder\");\nconst action_code_settings_builder_1 = require(\"./action-code-settings-builder\");\nconst tenant_1 = require(\"./tenant\");\nconst identifier_1 = require(\"./identifier\");\nconst auth_config_1 = require(\"./auth-config\");\nconst project_config_1 = require(\"./project-config\");\n/** Firebase Auth request header. */\nconst FIREBASE_AUTH_HEADERS = {\n  'X-Client-Version': `Node/Admin/${utils.getSdkVersion()}`\n};\n/** Firebase Auth request timeout duration in milliseconds. */\nconst FIREBASE_AUTH_TIMEOUT = 25000;\n/** List of reserved claims which cannot be provided when creating a custom token. */\nexports.RESERVED_CLAIMS = ['acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat', 'iss', 'jti', 'nbf', 'nonce', 'sub', 'firebase'];\n/** List of supported email action request types. */\nexports.EMAIL_ACTION_REQUEST_TYPES = ['PASSWORD_RESET', 'VERIFY_EMAIL', 'EMAIL_SIGNIN', 'VERIFY_AND_CHANGE_EMAIL'];\n/** Maximum allowed number of characters in the custom claims payload. */\nconst MAX_CLAIMS_PAYLOAD_SIZE = 1000;\n/** Maximum allowed number of users to batch download at one time. */\nconst MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1000;\n/** Maximum allowed number of users to batch upload at one time. */\nconst MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1000;\n/** Maximum allowed number of users to batch get at one time. */\nconst MAX_GET_ACCOUNTS_BATCH_SIZE = 100;\n/** Maximum allowed number of users to batch delete at one time. */\nconst MAX_DELETE_ACCOUNTS_BATCH_SIZE = 1000;\n/** Minimum allowed session cookie duration in seconds (5 minutes). */\nconst MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;\n/** Maximum allowed session cookie duration in seconds (2 weeks). */\nconst MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;\n/** Maximum allowed number of provider configurations to batch download at one time. */\nconst MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;\n/** The Firebase Auth backend base URL format. */\nconst FIREBASE_AUTH_BASE_URL_FORMAT = 'https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\n/** Firebase Auth base URlLformat when using the auth emultor. */\nconst FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT = 'http://{host}/identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\n/** The Firebase Auth backend multi-tenancy base URL format. */\nconst FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\n/** Firebase Auth base URL format when using the auth emultor with multi-tenancy. */\nconst FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT = FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\n/** Maximum allowed number of tenants to download at one time. */\nconst MAX_LIST_TENANT_PAGE_SIZE = 1000;\n/**\r\n * Enum for the user write operation type.\r\n */\nvar WriteOperationType;\n(function (WriteOperationType) {\n  WriteOperationType[\"Create\"] = \"create\";\n  WriteOperationType[\"Update\"] = \"update\";\n  WriteOperationType[\"Upload\"] = \"upload\";\n})(WriteOperationType || (WriteOperationType = {}));\n/** Defines a base utility to help with resource URL construction. */\nclass AuthResourceUrlBuilder {\n  /**\r\n   * The resource URL builder constructor.\r\n   *\r\n   * @param projectId - The resource project ID.\r\n   * @param version - The endpoint API version.\r\n   * @constructor\r\n   */\n  constructor(app, version = 'v1') {\n    this.app = app;\n    this.version = version;\n    if (useEmulator()) {\n      this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT, {\n        host: emulatorHost()\n      });\n    } else {\n      this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;\n    }\n  }\n  /**\r\n   * Returns the resource URL corresponding to the provided parameters.\r\n   *\r\n   * @param api - The backend API name.\r\n   * @param params - The optional additional parameters to substitute in the\r\n   *     URL path.\r\n   * @returns The corresponding resource URL.\r\n   */\n  getUrl(api, params) {\n    return this.getProjectId().then(projectId => {\n      const baseParams = {\n        version: this.version,\n        projectId,\n        api: api || ''\n      };\n      const baseUrl = utils.formatString(this.urlFormat, baseParams);\n      // Substitute additional api related parameters.\n      return utils.formatString(baseUrl, params || {});\n    });\n  }\n  getProjectId() {\n    if (this.projectId) {\n      return Promise.resolve(this.projectId);\n    }\n    return utils.findProjectId(this.app).then(projectId => {\n      if (!validator.isNonEmptyString(projectId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'Failed to determine project ID for Auth. Initialize the ' + 'SDK with service account credentials or set project ID as an app option. ' + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\n      }\n      this.projectId = projectId;\n      return projectId;\n    });\n  }\n}\n/** Tenant aware resource builder utility. */\nclass TenantAwareAuthResourceUrlBuilder extends AuthResourceUrlBuilder {\n  /**\r\n   * The tenant aware resource URL builder constructor.\r\n   *\r\n   * @param projectId - The resource project ID.\r\n   * @param version - The endpoint API version.\r\n   * @param tenantId - The tenant ID.\r\n   * @constructor\r\n   */\n  constructor(app, version, tenantId) {\n    super(app, version);\n    this.app = app;\n    this.version = version;\n    this.tenantId = tenantId;\n    if (useEmulator()) {\n      this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT, {\n        host: emulatorHost()\n      });\n    } else {\n      this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;\n    }\n  }\n  /**\r\n   * Returns the resource URL corresponding to the provided parameters.\r\n   *\r\n   * @param api - The backend API name.\r\n   * @param params - The optional additional parameters to substitute in the\r\n   *     URL path.\r\n   * @returns The corresponding resource URL.\r\n   */\n  getUrl(api, params) {\n    return super.getUrl(api, params).then(url => {\n      return utils.formatString(url, {\n        tenantId: this.tenantId\n      });\n    });\n  }\n}\n/**\r\n * Auth-specific HTTP client which uses the special \"owner\" token\r\n * when communicating with the Auth Emulator.\r\n */\nclass AuthHttpClient extends api_request_1.AuthorizedHttpClient {\n  getToken() {\n    if (useEmulator()) {\n      return Promise.resolve('owner');\n    }\n    return super.getToken();\n  }\n}\n/**\r\n * Validates an AuthFactorInfo object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param request - The AuthFactorInfo request object.\r\n */\nfunction validateAuthFactorInfo(request) {\n  const validKeys = {\n    mfaEnrollmentId: true,\n    displayName: true,\n    phoneInfo: true,\n    enrolledAt: true\n  };\n  // Remove unsupported keys from the original request.\n  for (const key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  }\n  // No enrollment ID is available for signupNewUser. Use another identifier.\n  const authFactorInfoIdentifier = request.mfaEnrollmentId || request.phoneInfo || JSON.stringify(request);\n  // Enrollment uid may or may not be specified for update operations.\n  if (typeof request.mfaEnrollmentId !== 'undefined' && !validator.isNonEmptyString(request.mfaEnrollmentId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, 'The second factor \"uid\" must be a valid non-empty string.');\n  }\n  if (typeof request.displayName !== 'undefined' && !validator.isString(request.displayName)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The second factor \"displayName\" for \"${authFactorInfoIdentifier}\" must be a valid string.`);\n  }\n  // enrolledAt must be a valid UTC date string.\n  if (typeof request.enrolledAt !== 'undefined' && !validator.isISODateString(request.enrolledAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor \"enrollmentTime\" for \"${authFactorInfoIdentifier}\" must be a valid ` + 'UTC date string.');\n  }\n  // Validate required fields depending on second factor type.\n  if (typeof request.phoneInfo !== 'undefined') {\n    // phoneNumber should be a string and a valid phone number.\n    if (!validator.isPhoneNumber(request.phoneInfo)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER, `The second factor \"phoneNumber\" for \"${authFactorInfoIdentifier}\" must be a non-empty ` + 'E.164 standard compliant identifier string.');\n    }\n  } else {\n    // Invalid second factor. For example, a phone second factor may have been provided without\n    // a phone number. A TOTP based second factor may require a secret key, etc.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS, 'MFAInfo object provided is invalid.');\n  }\n}\n/**\r\n * Validates a providerUserInfo object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param request - The providerUserInfo request object.\r\n */\nfunction validateProviderUserInfo(request) {\n  const validKeys = {\n    rawId: true,\n    providerId: true,\n    email: true,\n    displayName: true,\n    photoUrl: true\n  };\n  // Remove invalid keys from original request.\n  for (const key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  }\n  if (!validator.isNonEmptyString(request.providerId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n  }\n  if (typeof request.displayName !== 'undefined' && typeof request.displayName !== 'string') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The provider \"displayName\" for \"${request.providerId}\" must be a valid string.`);\n  }\n  if (!validator.isNonEmptyString(request.rawId)) {\n    // This is called localId on the backend but the developer specifies this as\n    // uid externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, `The provider \"uid\" for \"${request.providerId}\" must be a valid non-empty string.`);\n  }\n  // email should be a string and a valid email.\n  if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, `The provider \"email\" for \"${request.providerId}\" must be a valid email string.`);\n  }\n  // photoUrl should be a URL.\n  if (typeof request.photoUrl !== 'undefined' && !validator.isURL(request.photoUrl)) {\n    // This is called photoUrl on the backend but the developer specifies this as\n    // photoURL externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, `The provider \"photoURL\" for \"${request.providerId}\" must be a valid URL string.`);\n  }\n}\n/**\r\n * Validates a create/edit request object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param request - The create/edit request object.\r\n * @param writeOperationType - The write operation type.\r\n */\nfunction validateCreateEditRequest(request, writeOperationType) {\n  const uploadAccountRequest = writeOperationType === WriteOperationType.Upload;\n  // Hash set of whitelisted parameters.\n  const validKeys = {\n    displayName: true,\n    localId: true,\n    email: true,\n    password: true,\n    rawPassword: true,\n    emailVerified: true,\n    photoUrl: true,\n    disabled: true,\n    disableUser: true,\n    deleteAttribute: true,\n    deleteProvider: true,\n    sanityCheck: true,\n    phoneNumber: true,\n    customAttributes: true,\n    validSince: true,\n    // Pass linkProviderUserInfo only for updates (i.e. not for uploads.)\n    linkProviderUserInfo: !uploadAccountRequest,\n    // Pass tenantId only for uploadAccount requests.\n    tenantId: uploadAccountRequest,\n    passwordHash: uploadAccountRequest,\n    salt: uploadAccountRequest,\n    createdAt: uploadAccountRequest,\n    lastLoginAt: uploadAccountRequest,\n    providerUserInfo: uploadAccountRequest,\n    mfaInfo: uploadAccountRequest,\n    // Only for non-uploadAccount requests.\n    mfa: !uploadAccountRequest\n  };\n  // Remove invalid keys from original request.\n  for (const key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  }\n  if (typeof request.tenantId !== 'undefined' && !validator.isNonEmptyString(request.tenantId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\n  }\n  // For any invalid parameter, use the external key name in the error description.\n  // displayName should be a string.\n  if (typeof request.displayName !== 'undefined' && !validator.isString(request.displayName)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);\n  }\n  if ((typeof request.localId !== 'undefined' || uploadAccountRequest) && !validator.isUid(request.localId)) {\n    // This is called localId on the backend but the developer specifies this as\n    // uid externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n  }\n  // email should be a string and a valid email.\n  if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n  }\n  // phoneNumber should be a string and a valid phone number.\n  if (typeof request.phoneNumber !== 'undefined' && !validator.isPhoneNumber(request.phoneNumber)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\n  }\n  // password should be a string and a minimum of 6 chars.\n  if (typeof request.password !== 'undefined' && !validator.isPassword(request.password)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n  }\n  // rawPassword should be a string and a minimum of 6 chars.\n  if (typeof request.rawPassword !== 'undefined' && !validator.isPassword(request.rawPassword)) {\n    // This is called rawPassword on the backend but the developer specifies this as\n    // password externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n  }\n  // emailVerified should be a boolean.\n  if (typeof request.emailVerified !== 'undefined' && typeof request.emailVerified !== 'boolean') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);\n  }\n  // photoUrl should be a URL.\n  if (typeof request.photoUrl !== 'undefined' && !validator.isURL(request.photoUrl)) {\n    // This is called photoUrl on the backend but the developer specifies this as\n    // photoURL externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);\n  }\n  // disabled should be a boolean.\n  if (typeof request.disabled !== 'undefined' && typeof request.disabled !== 'boolean') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n  }\n  // validSince should be a number.\n  if (typeof request.validSince !== 'undefined' && !validator.isNumber(request.validSince)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);\n  }\n  // createdAt should be a number.\n  if (typeof request.createdAt !== 'undefined' && !validator.isNumber(request.createdAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);\n  }\n  // lastSignInAt should be a number.\n  if (typeof request.lastLoginAt !== 'undefined' && !validator.isNumber(request.lastLoginAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);\n  }\n  // disableUser should be a boolean.\n  if (typeof request.disableUser !== 'undefined' && typeof request.disableUser !== 'boolean') {\n    // This is called disableUser on the backend but the developer specifies this as\n    // disabled externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n  }\n  // customAttributes should be stringified JSON with no blacklisted claims.\n  // The payload should not exceed 1KB.\n  if (typeof request.customAttributes !== 'undefined') {\n    let developerClaims;\n    try {\n      developerClaims = JSON.parse(request.customAttributes);\n    } catch (error) {\n      // JSON parsing error. This should never happen as we stringify the claims internally.\n      // However, we still need to check since setAccountInfo via edit requests could pass\n      // this field.\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error.message);\n    }\n    const invalidClaims = [];\n    // Check for any invalid claims.\n    exports.RESERVED_CLAIMS.forEach(blacklistedClaim => {\n      if (Object.prototype.hasOwnProperty.call(developerClaims, blacklistedClaim)) {\n        invalidClaims.push(blacklistedClaim);\n      }\n    });\n    // Throw an error if an invalid claim is detected.\n    if (invalidClaims.length > 0) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims.length > 1 ? `Developer claims \"${invalidClaims.join('\", \"')}\" are reserved and cannot be specified.` : `Developer claim \"${invalidClaims[0]}\" is reserved and cannot be specified.`);\n    }\n    // Check claims payload does not exceed maxmimum size.\n    if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, `Developer claims payload should not exceed ${MAX_CLAIMS_PAYLOAD_SIZE} characters.`);\n    }\n  }\n  // passwordHash has to be a base64 encoded string.\n  if (typeof request.passwordHash !== 'undefined' && !validator.isString(request.passwordHash)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n  }\n  // salt has to be a base64 encoded string.\n  if (typeof request.salt !== 'undefined' && !validator.isString(request.salt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n  }\n  // providerUserInfo has to be an array of valid UserInfo requests.\n  if (typeof request.providerUserInfo !== 'undefined' && !validator.isArray(request.providerUserInfo)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);\n  } else if (validator.isArray(request.providerUserInfo)) {\n    request.providerUserInfo.forEach(providerUserInfoEntry => {\n      validateProviderUserInfo(providerUserInfoEntry);\n    });\n  }\n  // linkProviderUserInfo must be a (single) UserProvider value.\n  if (typeof request.linkProviderUserInfo !== 'undefined') {\n    validateProviderUserInfo(request.linkProviderUserInfo);\n  }\n  // mfaInfo is used for importUsers.\n  // mfa.enrollments is used for setAccountInfo.\n  // enrollments has to be an array of valid AuthFactorInfo requests.\n  let enrollments = null;\n  if (request.mfaInfo) {\n    enrollments = request.mfaInfo;\n  } else if (request.mfa && request.mfa.enrollments) {\n    enrollments = request.mfa.enrollments;\n  }\n  if (enrollments) {\n    if (!validator.isArray(enrollments)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS);\n    }\n    enrollments.forEach(authFactorInfoEntry => {\n      validateAuthFactorInfo(authFactorInfoEntry);\n    });\n  }\n}\n/**\r\n * Instantiates the createSessionCookie endpoint settings.\r\n *\r\n * @internal\r\n */\nexports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(':createSessionCookie', 'POST')\n// Set request validator.\n.setRequestValidator(request => {\n  // Validate the ID token is a non-empty string.\n  if (!validator.isNonEmptyString(request.idToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);\n  }\n  // Validate the custom session cookie duration.\n  if (!validator.isNumber(request.validDuration) || request.validDuration < MIN_SESSION_COOKIE_DURATION_SECS || request.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);\n  }\n})\n// Set response validator.\n.setResponseValidator(response => {\n  // Response should always contain the session cookie.\n  if (!validator.isNonEmptyString(response.sessionCookie)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);\n  }\n});\n/**\r\n * Instantiates the uploadAccount endpoint settings.\r\n *\r\n * @internal\r\n */\nexports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchCreate', 'POST');\n/**\r\n * Instantiates the downloadAccount endpoint settings.\r\n *\r\n * @internal\r\n */\nexports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchGet', 'GET')\n// Set request validator.\n.setRequestValidator(request => {\n  // Validate next page token.\n  if (typeof request.nextPageToken !== 'undefined' && !validator.isNonEmptyString(request.nextPageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  }\n  // Validate max results.\n  if (!validator.isNumber(request.maxResults) || request.maxResults <= 0 || request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' + `${MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE}.`);\n  }\n});\n/**\r\n * Instantiates the getAccountInfo endpoint settings.\r\n *\r\n * @internal\r\n */\nexports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')\n// Set request validator.\n.setRequestValidator(request => {\n  if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n})\n// Set response validator.\n.setResponseValidator(response => {\n  if (!response.users || !response.users.length) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n  }\n});\n/**\r\n * Instantiates the getAccountInfo endpoint settings for use when fetching info\r\n * for multiple accounts.\r\n *\r\n * @internal\r\n */\nexports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')\n// Set request validator.\n.setRequestValidator(request => {\n  if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n});\n/**\r\n * Instantiates the deleteAccount endpoint settings.\r\n *\r\n * @internal\r\n */\nexports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings('/accounts:delete', 'POST')\n// Set request validator.\n.setRequestValidator(request => {\n  if (!request.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n});\n/**\r\n * @internal\r\n */\nexports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = new api_request_1.ApiSettings('/accounts:batchDelete', 'POST').setRequestValidator(request => {\n  if (!request.localIds) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifiers');\n  }\n  if (typeof request.force === 'undefined' || request.force !== true) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing force=true field');\n  }\n}).setResponseValidator(response => {\n  const errors = response.errors || [];\n  errors.forEach(batchDeleteErrorInfo => {\n    if (typeof batchDeleteErrorInfo.index === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.index field');\n    }\n    if (!batchDeleteErrorInfo.localId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.localId field');\n    }\n    // Allow the (error) message to be missing/undef.\n  });\n});\n/**\r\n * Instantiates the setAccountInfo endpoint settings for updating existing accounts.\r\n *\r\n * @internal\r\n */\nexports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:update', 'POST')\n// Set request validator.\n.setRequestValidator(request => {\n  // localId is a required parameter.\n  if (typeof request.localId === 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n  // Throw error when tenantId is passed in POST body.\n  if (typeof request.tenantId !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"UpdateRequest\" property.');\n  }\n  validateCreateEditRequest(request, WriteOperationType.Update);\n})\n// Set response validator.\n.setResponseValidator(response => {\n  // If the localId is not returned, then the request failed.\n  if (!response.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n  }\n});\n/**\r\n * Instantiates the signupNewUser endpoint settings for creating a new user with or without\r\n * uid being specified. The backend will create a new one if not provided and return it.\r\n *\r\n * @internal\r\n */\nexports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings('/accounts', 'POST')\n// Set request validator.\n.setRequestValidator(request => {\n  // signupNewUser does not support customAttributes.\n  if (typeof request.customAttributes !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"customAttributes\" cannot be set when creating a new user.');\n  }\n  // signupNewUser does not support validSince.\n  if (typeof request.validSince !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"validSince\" cannot be set when creating a new user.');\n  }\n  // Throw error when tenantId is passed in POST body.\n  if (typeof request.tenantId !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"CreateRequest\" property.');\n  }\n  validateCreateEditRequest(request, WriteOperationType.Create);\n})\n// Set response validator.\n.setResponseValidator(response => {\n  // If the localId is not returned, then the request failed.\n  if (!response.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new user');\n  }\n});\nconst FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings('/accounts:sendOobCode', 'POST')\n// Set request validator.\n.setRequestValidator(request => {\n  if (!validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n  }\n  if (typeof request.newEmail !== 'undefined' && !validator.isEmail(request.newEmail)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_NEW_EMAIL);\n  }\n  if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request.requestType) === -1) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `\"${request.requestType}\" is not a supported email action request type.`);\n  }\n})\n// Set response validator.\n.setResponseValidator(response => {\n  // If the oobLink is not returned, then the request failed.\n  if (!response.oobLink) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create the email action link');\n  }\n});\n/**\r\n * Instantiates the retrieve OIDC configuration endpoint settings.\r\n *\r\n * @internal\r\n */\nconst GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'GET')\n// Set response validator.\n.setResponseValidator(response => {\n  // Response should always contain the OIDC provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get OIDC configuration');\n  }\n});\n/**\r\n * Instantiates the delete OIDC configuration endpoint settings.\r\n *\r\n * @internal\r\n */\nconst DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'DELETE');\n/**\r\n * Instantiates the create OIDC configuration endpoint settings.\r\n *\r\n * @internal\r\n */\nconst CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs?oauthIdpConfigId={providerId}', 'POST')\n// Set response validator.\n.setResponseValidator(response => {\n  // Response should always contain the OIDC provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC configuration');\n  }\n});\n/**\r\n * Instantiates the update OIDC configuration endpoint settings.\r\n *\r\n * @internal\r\n */\nconst UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}?updateMask={updateMask}', 'PATCH')\n// Set response validator.\n.setResponseValidator(response => {\n  // Response should always contain the configuration resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC configuration');\n  }\n});\n/**\r\n * Instantiates the list OIDC configuration endpoint settings.\r\n *\r\n * @internal\r\n */\nconst LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings('/oauthIdpConfigs', 'GET')\n// Set request validator.\n.setRequestValidator(request => {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  }\n  // Validate max results.\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' + `${MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE}.`);\n  }\n});\n/**\r\n * Instantiates the retrieve SAML configuration endpoint settings.\r\n *\r\n * @internal\r\n */\nconst GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'GET')\n// Set response validator.\n.setResponseValidator(response => {\n  // Response should always contain the SAML provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get SAML configuration');\n  }\n});\n/**\r\n * Instantiates the delete SAML configuration endpoint settings.\r\n *\r\n * @internal\r\n */\nconst DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'DELETE');\n/**\r\n * Instantiates the create SAML configuration endpoint settings.\r\n *\r\n * @internal\r\n */\nconst CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs?inboundSamlConfigId={providerId}', 'POST')\n// Set response validator.\n.setResponseValidator(response => {\n  // Response should always contain the SAML provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML configuration');\n  }\n});\n/**\r\n * Instantiates the update SAML configuration endpoint settings.\r\n *\r\n * @internal\r\n */\nconst UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}?updateMask={updateMask}', 'PATCH')\n// Set response validator.\n.setResponseValidator(response => {\n  // Response should always contain the configuration resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML configuration');\n  }\n});\n/**\r\n * Instantiates the list SAML configuration endpoint settings.\r\n *\r\n * @internal\r\n */\nconst LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings('/inboundSamlConfigs', 'GET')\n// Set request validator.\n.setRequestValidator(request => {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  }\n  // Validate max results.\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' + `${MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE}.`);\n  }\n});\n/**\r\n * Class that provides the mechanism to send requests to the Firebase Auth backend endpoints.\r\n *\r\n * @internal\r\n */\nclass AbstractAuthRequestHandler {\n  /**\r\n   * @param response - The response to check for errors.\r\n   * @returns The error code if present; null otherwise.\r\n   */\n  static getErrorCode(response) {\n    return validator.isNonNullObject(response) && response.error && response.error.message || null;\n  }\n  static addUidToRequest(id, request) {\n    if (!validator.isUid(id.uid)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n    }\n    request.localId ? request.localId.push(id.uid) : request.localId = [id.uid];\n    return request;\n  }\n  static addEmailToRequest(id, request) {\n    if (!validator.isEmail(id.email)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n    }\n    request.email ? request.email.push(id.email) : request.email = [id.email];\n    return request;\n  }\n  static addPhoneToRequest(id, request) {\n    if (!validator.isPhoneNumber(id.phoneNumber)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\n    }\n    request.phoneNumber ? request.phoneNumber.push(id.phoneNumber) : request.phoneNumber = [id.phoneNumber];\n    return request;\n  }\n  static addProviderToRequest(id, request) {\n    if (!validator.isNonEmptyString(id.providerId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n    }\n    if (!validator.isNonEmptyString(id.providerUid)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_UID);\n    }\n    const federatedUserId = {\n      providerId: id.providerId,\n      rawId: id.providerUid\n    };\n    request.federatedUserId ? request.federatedUserId.push(federatedUserId) : request.federatedUserId = [federatedUserId];\n    return request;\n  }\n  /**\r\n   * @param app - The app used to fetch access tokens to sign API requests.\r\n   * @constructor\r\n   */\n  constructor(app) {\n    this.app = app;\n    if (typeof app !== 'object' || app === null || !('options' in app)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');\n    }\n    this.httpClient = new AuthHttpClient(app);\n  }\n  /**\r\n   * Creates a new Firebase session cookie with the specified duration that can be used for\r\n   * session management (set as a server side session cookie with custom cookie policy).\r\n   * The session cookie JWT will have the same payload claims as the provided ID token.\r\n   *\r\n   * @param idToken - The Firebase ID token to exchange for a session cookie.\r\n   * @param expiresIn - The session cookie duration in milliseconds.\r\n   *\r\n   * @returns A promise that resolves on success with the created session cookie.\r\n   */\n  createSessionCookie(idToken, expiresIn) {\n    const request = {\n      idToken,\n      // Convert to seconds.\n      validDuration: Math.floor(expiresIn / 1000)\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request).then(response => response.sessionCookie);\n  }\n  /**\r\n   * Looks up a user by uid.\r\n   *\r\n   * @param uid - The uid of the user to lookup.\r\n   * @returns A promise that resolves with the user information.\r\n   */\n  getAccountInfoByUid(uid) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n    const request = {\n      localId: [uid]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  }\n  /**\r\n   * Looks up a user by email.\r\n   *\r\n   * @param email - The email of the user to lookup.\r\n   * @returns A promise that resolves with the user information.\r\n   */\n  getAccountInfoByEmail(email) {\n    if (!validator.isEmail(email)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));\n    }\n    const request = {\n      email: [email]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  }\n  /**\r\n   * Looks up a user by phone number.\r\n   *\r\n   * @param phoneNumber - The phone number of the user to lookup.\r\n   * @returns A promise that resolves with the user information.\r\n   */\n  getAccountInfoByPhoneNumber(phoneNumber) {\n    if (!validator.isPhoneNumber(phoneNumber)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));\n    }\n    const request = {\n      phoneNumber: [phoneNumber]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  }\n  getAccountInfoByFederatedUid(providerId, rawId) {\n    if (!validator.isNonEmptyString(providerId) || !validator.isNonEmptyString(rawId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n    }\n    const request = {\n      federatedUserId: [{\n        providerId,\n        rawId\n      }]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  }\n  /**\r\n   * Looks up multiple users by their identifiers (uid, email, etc).\r\n   *\r\n   * @param identifiers - The identifiers indicating the users\r\n   *     to be looked up. Must have <= 100 entries.\r\n   * @param A - promise that resolves with the set of successfully\r\n   *     looked up users. Possibly empty if no users were looked up.\r\n   */\n  getAccountInfoByIdentifiers(identifiers) {\n    if (identifiers.length === 0) {\n      return Promise.resolve({\n        users: []\n      });\n    } else if (identifiers.length > MAX_GET_ACCOUNTS_BATCH_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`identifiers` parameter must have <= ' + MAX_GET_ACCOUNTS_BATCH_SIZE + ' entries.');\n    }\n    let request = {};\n    for (const id of identifiers) {\n      if ((0, identifier_1.isUidIdentifier)(id)) {\n        request = AbstractAuthRequestHandler.addUidToRequest(id, request);\n      } else if ((0, identifier_1.isEmailIdentifier)(id)) {\n        request = AbstractAuthRequestHandler.addEmailToRequest(id, request);\n      } else if ((0, identifier_1.isPhoneIdentifier)(id)) {\n        request = AbstractAuthRequestHandler.addPhoneToRequest(id, request);\n      } else if ((0, identifier_1.isProviderIdentifier)(id)) {\n        request = AbstractAuthRequestHandler.addProviderToRequest(id, request);\n      } else {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Unrecognized identifier: ' + id);\n      }\n    }\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO, request);\n  }\n  /**\r\n   * Exports the users (single batch only) with a size of maxResults and starting from\r\n   * the offset as specified by pageToken.\r\n   *\r\n   * @param maxResults - The page size, 1000 if undefined. This is also the maximum\r\n   *     allowed limit.\r\n   * @param pageToken - The next page token. If not specified, returns users starting\r\n   *     without any offset. Users are returned in the order they were created from oldest to\r\n   *     newest, relative to the page token offset.\r\n   * @returns A promise that resolves with the current batch of downloaded\r\n   *     users and the next page token if available. For the last page, an empty list of users\r\n   *     and no page token are returned.\r\n   */\n  downloadAccount(maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE, pageToken) {\n    // Construct request.\n    const request = {\n      maxResults,\n      nextPageToken: pageToken\n    };\n    // Remove next page token if not provided.\n    if (typeof request.nextPageToken === 'undefined') {\n      delete request.nextPageToken;\n    }\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request).then(response => {\n      // No more users available.\n      if (!response.users) {\n        response.users = [];\n      }\n      return response;\n    });\n  }\n  /**\r\n   * Imports the list of users provided to Firebase Auth. This is useful when\r\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\r\n   * At most, 1000 users are allowed to be imported one at a time.\r\n   * When importing a list of password users, UserImportOptions are required to be specified.\r\n   *\r\n   * @param users - The list of user records to import to Firebase Auth.\r\n   * @param options - The user import options, required when the users provided\r\n   *     include password credentials.\r\n   * @returns A promise that resolves when the operation completes\r\n   *     with the result of the import. This includes the number of successful imports, the number\r\n   *     of failed uploads and their corresponding errors.\r\n   */\n  uploadAccount(users, options) {\n    // This will throw if any error is detected in the hash options.\n    // For errors in the list of users, this will not throw and will report the errors and the\n    // corresponding user index in the user import generated response below.\n    // No need to validate raw request or raw response as this is done in UserImportBuilder.\n    const userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, userRequest => {\n      // Pass true to validate the uploadAccount specific fields.\n      validateCreateEditRequest(userRequest, WriteOperationType.Upload);\n    });\n    const request = userImportBuilder.buildRequest();\n    // Fail quickly if more users than allowed are to be imported.\n    if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, `A maximum of ${MAX_UPLOAD_ACCOUNT_BATCH_SIZE} users can be imported at once.`);\n    }\n    // If no remaining user in request after client side processing, there is no need\n    // to send the request to the server.\n    if (!request.users || request.users.length === 0) {\n      return Promise.resolve(userImportBuilder.buildResponse([]));\n    }\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request).then(response => {\n      // No error object is returned if no error encountered.\n      const failedUploads = response.error || [];\n      // Rewrite response as UserImportResult and re-insert client previously detected errors.\n      return userImportBuilder.buildResponse(failedUploads);\n    });\n  }\n  /**\r\n   * Deletes an account identified by a uid.\r\n   *\r\n   * @param uid - The uid of the user to delete.\r\n   * @returns A promise that resolves when the user is deleted.\r\n   */\n  deleteAccount(uid) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n    const request = {\n      localId: uid\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);\n  }\n  deleteAccounts(uids, force) {\n    if (uids.length === 0) {\n      return Promise.resolve({});\n    } else if (uids.length > MAX_DELETE_ACCOUNTS_BATCH_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`uids` parameter must have <= ' + MAX_DELETE_ACCOUNTS_BATCH_SIZE + ' entries.');\n    }\n    const request = {\n      localIds: [],\n      force\n    };\n    uids.forEach(uid => {\n      if (!validator.isUid(uid)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n      }\n      request.localIds.push(uid);\n    });\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS, request);\n  }\n  /**\r\n   * Sets additional developer claims on an existing user identified by provided UID.\r\n   *\r\n   * @param uid - The user to edit.\r\n   * @param customUserClaims - The developer claims to set.\r\n   * @returns A promise that resolves when the operation completes\r\n   *     with the user id that was edited.\r\n   */\n  setCustomUserClaims(uid, customUserClaims) {\n    // Validate user UID.\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    } else if (!validator.isObject(customUserClaims)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'CustomUserClaims argument must be an object or null.'));\n    }\n    // Delete operation. Replace null with an empty object.\n    if (customUserClaims === null) {\n      customUserClaims = {};\n    }\n    // Construct custom user attribute editting request.\n    const request = {\n      localId: uid,\n      customAttributes: JSON.stringify(customUserClaims)\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(response => {\n      return response.localId;\n    });\n  }\n  /**\r\n   * Edits an existing user.\r\n   *\r\n   * @param uid - The user to edit.\r\n   * @param properties - The properties to set on the user.\r\n   * @returns A promise that resolves when the operation completes\r\n   *     with the user id that was edited.\r\n   */\n  updateExistingAccount(uid, properties) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    } else if (!validator.isNonNullObject(properties)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n    } else if (validator.isNonNullObject(properties.providerToLink)) {\n      // TODO(rsgowman): These checks overlap somewhat with\n      // validateProviderUserInfo. It may be possible to refactor a bit.\n      if (!validator.isNonEmptyString(properties.providerToLink.providerId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.providerId of properties argument must be a non-empty string.');\n      }\n      if (!validator.isNonEmptyString(properties.providerToLink.uid)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.uid of properties argument must be a non-empty string.');\n      }\n    } else if (typeof properties.providersToUnlink !== 'undefined') {\n      if (!validator.isArray(properties.providersToUnlink)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');\n      }\n      properties.providersToUnlink.forEach(providerId => {\n        if (!validator.isNonEmptyString(providerId)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');\n        }\n      });\n    }\n    // Build the setAccountInfo request.\n    const request = (0, deep_copy_1.deepCopy)(properties);\n    request.localId = uid;\n    // For deleting displayName or photoURL, these values must be passed as null.\n    // They will be removed from the backend request and an additional parameter\n    // deleteAttribute: ['PHOTO_URL', 'DISPLAY_NAME']\n    // with an array of the parameter names to delete will be passed.\n    // Parameters that are deletable and their deleteAttribute names.\n    // Use client facing names, photoURL instead of photoUrl.\n    const deletableParams = {\n      displayName: 'DISPLAY_NAME',\n      photoURL: 'PHOTO_URL'\n    };\n    // Properties to delete if available.\n    request.deleteAttribute = [];\n    for (const key in deletableParams) {\n      if (request[key] === null) {\n        // Add property identifier to list of attributes to delete.\n        request.deleteAttribute.push(deletableParams[key]);\n        // Remove property from request.\n        delete request[key];\n      }\n    }\n    if (request.deleteAttribute.length === 0) {\n      delete request.deleteAttribute;\n    }\n    // For deleting phoneNumber, this value must be passed as null.\n    // It will be removed from the backend request and an additional parameter\n    // deleteProvider: ['phone'] with an array of providerIds (phone in this case),\n    // will be passed.\n    if (request.phoneNumber === null) {\n      request.deleteProvider ? request.deleteProvider.push('phone') : request.deleteProvider = ['phone'];\n      delete request.phoneNumber;\n    }\n    if (typeof request.providerToLink !== 'undefined') {\n      request.linkProviderUserInfo = (0, deep_copy_1.deepCopy)(request.providerToLink);\n      delete request.providerToLink;\n      request.linkProviderUserInfo.rawId = request.linkProviderUserInfo.uid;\n      delete request.linkProviderUserInfo.uid;\n    }\n    if (typeof request.providersToUnlink !== 'undefined') {\n      if (!validator.isArray(request.deleteProvider)) {\n        request.deleteProvider = [];\n      }\n      request.deleteProvider = request.deleteProvider.concat(request.providersToUnlink);\n      delete request.providersToUnlink;\n    }\n    // Rewrite photoURL to photoUrl.\n    if (typeof request.photoURL !== 'undefined') {\n      request.photoUrl = request.photoURL;\n      delete request.photoURL;\n    }\n    // Rewrite disabled to disableUser.\n    if (typeof request.disabled !== 'undefined') {\n      request.disableUser = request.disabled;\n      delete request.disabled;\n    }\n    // Construct mfa related user data.\n    if (validator.isNonNullObject(request.multiFactor)) {\n      if (request.multiFactor.enrolledFactors === null) {\n        // Remove all second factors.\n        request.mfa = {};\n      } else if (validator.isArray(request.multiFactor.enrolledFactors)) {\n        request.mfa = {\n          enrollments: []\n        };\n        try {\n          request.multiFactor.enrolledFactors.forEach(multiFactorInfo => {\n            request.mfa.enrollments.push((0, user_import_builder_1.convertMultiFactorInfoToServerFormat)(multiFactorInfo));\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n        if (request.mfa.enrollments.length === 0) {\n          delete request.mfa.enrollments;\n        }\n      }\n      delete request.multiFactor;\n    }\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(response => {\n      return response.localId;\n    });\n  }\n  /**\r\n   * Revokes all refresh tokens for the specified user identified by the uid provided.\r\n   * In addition to revoking all refresh tokens for a user, all ID tokens issued\r\n   * before revocation will also be revoked on the Auth backend. Any request with an\r\n   * ID token generated before revocation will be rejected with a token expired error.\r\n   * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in\r\n   * the same second as the revocation will still be valid. If there is a chance that a token\r\n   * was minted in the last second, delay for 1 second before revoking.\r\n   *\r\n   * @param uid - The user whose tokens are to be revoked.\r\n   * @returns A promise that resolves when the operation completes\r\n   *     successfully with the user id of the corresponding user.\r\n   */\n  revokeRefreshTokens(uid) {\n    // Validate user UID.\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n    const request = {\n      localId: uid,\n      // validSince is in UTC seconds.\n      validSince: Math.floor(new Date().getTime() / 1000)\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(response => {\n      return response.localId;\n    });\n  }\n  /**\r\n   * Create a new user with the properties supplied.\r\n   *\r\n   * @param properties - The properties to set on the user.\r\n   * @returns A promise that resolves when the operation completes\r\n   *     with the user id that was created.\r\n   */\n  createNewAccount(properties) {\n    if (!validator.isNonNullObject(properties)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n    }\n    const request = (0, deep_copy_1.deepCopy)(properties);\n    // Rewrite photoURL to photoUrl.\n    if (typeof request.photoURL !== 'undefined') {\n      request.photoUrl = request.photoURL;\n      delete request.photoURL;\n    }\n    // Rewrite uid to localId if it exists.\n    if (typeof request.uid !== 'undefined') {\n      request.localId = request.uid;\n      delete request.uid;\n    }\n    // Construct mfa related user data.\n    if (validator.isNonNullObject(request.multiFactor)) {\n      if (validator.isNonEmptyArray(request.multiFactor.enrolledFactors)) {\n        const mfaInfo = [];\n        try {\n          request.multiFactor.enrolledFactors.forEach(multiFactorInfo => {\n            // Enrollment time and uid are not allowed for signupNewUser endpoint.\n            // They will automatically be provisioned server side.\n            if ('enrollmentTime' in multiFactorInfo) {\n              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"enrollmentTime\" is not supported when adding second factors via \"createUser()\"');\n            } else if ('uid' in multiFactorInfo) {\n              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"uid\" is not supported when adding second factors via \"createUser()\"');\n            }\n            mfaInfo.push((0, user_import_builder_1.convertMultiFactorInfoToServerFormat)(multiFactorInfo));\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n        request.mfaInfo = mfaInfo;\n      }\n      delete request.multiFactor;\n    }\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request).then(response => {\n      // Return the user id.\n      return response.localId;\n    });\n  }\n  /**\r\n   * Generates the out of band email action link for the email specified using the action code settings provided.\r\n   * Returns a promise that resolves with the generated link.\r\n   *\r\n   * @param requestType - The request type. This could be either used for password reset,\r\n   *     email verification, email link sign-in.\r\n   * @param email - The email of the user the link is being sent to.\r\n   * @param actionCodeSettings - The optional action code setings which defines whether\r\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\r\n   *     deep link, etc. Required when requestType === 'EMAIL_SIGNIN'\r\n   * @param newEmail - The email address the account is being updated to.\r\n   *     Required only for VERIFY_AND_CHANGE_EMAIL requests.\r\n   * @returns A promise that resolves with the email action link.\r\n   */\n  getEmailActionLink(requestType, email, actionCodeSettings, newEmail) {\n    let request = {\n      requestType,\n      email,\n      returnOobLink: true,\n      ...(typeof newEmail !== 'undefined' && {\n        newEmail\n      })\n    };\n    // ActionCodeSettings required for email link sign-in to determine the url where the sign-in will\n    // be completed.\n    if (typeof actionCodeSettings === 'undefined' && requestType === 'EMAIL_SIGNIN') {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"`actionCodeSettings` is required when `requestType` === 'EMAIL_SIGNIN'\"));\n    }\n    if (typeof actionCodeSettings !== 'undefined' || requestType === 'EMAIL_SIGNIN') {\n      try {\n        const builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);\n        request = (0, deep_copy_1.deepExtend)(request, builder.buildRequest());\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n    if (requestType === 'VERIFY_AND_CHANGE_EMAIL' && typeof newEmail === 'undefined') {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"`newEmail` is required when `requestType` === 'VERIFY_AND_CHANGE_EMAIL'\"));\n    }\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request).then(response => {\n      // Return the link.\n      return response.oobLink;\n    });\n  }\n  /**\r\n   * Looks up an OIDC provider configuration by provider ID.\r\n   *\r\n   * @param providerId - The provider identifier of the configuration to lookup.\r\n   * @returns A promise that resolves with the provider configuration information.\r\n   */\n  getOAuthIdpConfig(providerId) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, {\n      providerId\n    });\n  }\n  /**\r\n   * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from\r\n   * the offset as specified by pageToken.\r\n   *\r\n   * @param maxResults - The page size, 100 if undefined. This is also the maximum\r\n   *     allowed limit.\r\n   * @param pageToken - The next page token. If not specified, returns OIDC configurations\r\n   *     without any offset. Configurations are returned in the order they were created from oldest to\r\n   *     newest, relative to the page token offset.\r\n   * @returns A promise that resolves with the current batch of downloaded\r\n   *     OIDC configurations and the next page token if available. For the last page, an empty list of provider\r\n   *     configuration and no page token are returned.\r\n   */\n  listOAuthIdpConfigs(maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE, pageToken) {\n    const request = {\n      pageSize: maxResults\n    };\n    // Add next page token if provided.\n    if (typeof pageToken !== 'undefined') {\n      request.pageToken = pageToken;\n    }\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request).then(response => {\n      if (!response.oauthIdpConfigs) {\n        response.oauthIdpConfigs = [];\n        delete response.nextPageToken;\n      }\n      return response;\n    });\n  }\n  /**\r\n   * Deletes an OIDC configuration identified by a providerId.\r\n   *\r\n   * @param providerId - The identifier of the OIDC configuration to delete.\r\n   * @returns A promise that resolves when the OIDC provider is deleted.\r\n   */\n  deleteOAuthIdpConfig(providerId) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, {\n      providerId\n    }).then(() => {\n      // Return nothing.\n    });\n  }\n  /**\r\n   * Creates a new OIDC provider configuration with the properties provided.\r\n   *\r\n   * @param options - The properties to set on the new OIDC provider configuration to be created.\r\n   * @returns A promise that resolves with the newly created OIDC\r\n   *     configuration.\r\n   */\n  createOAuthIdpConfig(options) {\n    // Construct backend request.\n    let request;\n    try {\n      request = auth_config_1.OIDCConfig.buildServerRequest(options) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    const providerId = options.providerId;\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request, {\n      providerId\n    }).then(response => {\n      if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration');\n      }\n      return response;\n    });\n  }\n  /**\r\n   * Updates an existing OIDC provider configuration with the properties provided.\r\n   *\r\n   * @param providerId - The provider identifier of the OIDC configuration to update.\r\n   * @param options - The properties to update on the existing configuration.\r\n   * @returns A promise that resolves with the modified provider\r\n   *     configuration.\r\n   */\n  updateOAuthIdpConfig(providerId, options) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n    // Construct backend request.\n    let request;\n    try {\n      request = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    const updateMask = utils.generateUpdateMask(request);\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request, {\n      providerId,\n      updateMask: updateMask.join(',')\n    }).then(response => {\n      if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration');\n      }\n      return response;\n    });\n  }\n  /**\r\n   * Looks up an SAML provider configuration by provider ID.\r\n   *\r\n   * @param providerId - The provider identifier of the configuration to lookup.\r\n   * @returns A promise that resolves with the provider configuration information.\r\n   */\n  getInboundSamlConfig(providerId) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, {\n      providerId\n    });\n  }\n  /**\r\n   * Lists the SAML configurations (single batch only) with a size of maxResults and starting from\r\n   * the offset as specified by pageToken.\r\n   *\r\n   * @param maxResults - The page size, 100 if undefined. This is also the maximum\r\n   *     allowed limit.\r\n   * @param pageToken - The next page token. If not specified, returns SAML configurations starting\r\n   *     without any offset. Configurations are returned in the order they were created from oldest to\r\n   *     newest, relative to the page token offset.\r\n   * @returns A promise that resolves with the current batch of downloaded\r\n   *     SAML configurations and the next page token if available. For the last page, an empty list of provider\r\n   *     configuration and no page token are returned.\r\n   */\n  listInboundSamlConfigs(maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE, pageToken) {\n    const request = {\n      pageSize: maxResults\n    };\n    // Add next page token if provided.\n    if (typeof pageToken !== 'undefined') {\n      request.pageToken = pageToken;\n    }\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request).then(response => {\n      if (!response.inboundSamlConfigs) {\n        response.inboundSamlConfigs = [];\n        delete response.nextPageToken;\n      }\n      return response;\n    });\n  }\n  /**\r\n   * Deletes a SAML configuration identified by a providerId.\r\n   *\r\n   * @param providerId - The identifier of the SAML configuration to delete.\r\n   * @returns A promise that resolves when the SAML provider is deleted.\r\n   */\n  deleteInboundSamlConfig(providerId) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, {\n      providerId\n    }).then(() => {\n      // Return nothing.\n    });\n  }\n  /**\r\n   * Creates a new SAML provider configuration with the properties provided.\r\n   *\r\n   * @param options - The properties to set on the new SAML provider configuration to be created.\r\n   * @returns A promise that resolves with the newly created SAML\r\n   *     configuration.\r\n   */\n  createInboundSamlConfig(options) {\n    // Construct backend request.\n    let request;\n    try {\n      request = auth_config_1.SAMLConfig.buildServerRequest(options) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    const providerId = options.providerId;\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request, {\n      providerId\n    }).then(response => {\n      if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration');\n      }\n      return response;\n    });\n  }\n  /**\r\n   * Updates an existing SAML provider configuration with the properties provided.\r\n   *\r\n   * @param providerId - The provider identifier of the SAML configuration to update.\r\n   * @param options - The properties to update on the existing configuration.\r\n   * @returns A promise that resolves with the modified provider\r\n   *     configuration.\r\n   */\n  updateInboundSamlConfig(providerId, options) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n    // Construct backend request.\n    let request;\n    try {\n      request = auth_config_1.SAMLConfig.buildServerRequest(options, true) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    const updateMask = utils.generateUpdateMask(request);\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request, {\n      providerId,\n      updateMask: updateMask.join(',')\n    }).then(response => {\n      if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML provider configuration');\n      }\n      return response;\n    });\n  }\n  /**\r\n   * Invokes the request handler based on the API settings object passed.\r\n   *\r\n   * @param urlBuilder - The URL builder for Auth endpoints.\r\n   * @param apiSettings - The API endpoint settings to apply to request and response.\r\n   * @param requestData - The request data.\r\n   * @param additionalResourceParams - Additional resource related params if needed.\r\n   * @returns A promise that resolves with the response.\r\n   */\n  invokeRequestHandler(urlBuilder, apiSettings, requestData, additionalResourceParams) {\n    return urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams).then(url => {\n      // Validate request.\n      if (requestData) {\n        const requestValidator = apiSettings.getRequestValidator();\n        requestValidator(requestData);\n      }\n      // Process request.\n      const req = {\n        method: apiSettings.getHttpMethod(),\n        url,\n        headers: FIREBASE_AUTH_HEADERS,\n        data: requestData,\n        timeout: FIREBASE_AUTH_TIMEOUT\n      };\n      return this.httpClient.send(req);\n    }).then(response => {\n      // Validate response.\n      const responseValidator = apiSettings.getResponseValidator();\n      responseValidator(response.data);\n      // Return entire response.\n      return response.data;\n    }).catch(err => {\n      if (err instanceof api_request_1.RequestResponseError) {\n        const error = err.response.data;\n        const errorCode = AbstractAuthRequestHandler.getErrorCode(error);\n        if (!errorCode) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + error + '. Additionally, an ' + 'internal error occurred while attempting to extract the ' + 'errorcode from the error.');\n        }\n        throw error_1.FirebaseAuthError.fromServerError(errorCode, /* message */undefined, error);\n      }\n      throw err;\n    });\n  }\n  /**\r\n   * @returns The current Auth user management resource URL builder.\r\n   */\n  getAuthUrlBuilder() {\n    if (!this.authUrlBuilder) {\n      this.authUrlBuilder = this.newAuthUrlBuilder();\n    }\n    return this.authUrlBuilder;\n  }\n  /**\r\n   * @returns The current project config resource URL builder.\r\n   */\n  getProjectConfigUrlBuilder() {\n    if (!this.projectConfigUrlBuilder) {\n      this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();\n    }\n    return this.projectConfigUrlBuilder;\n  }\n}\nexports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;\n/** Instantiates the getConfig endpoint settings. */\nconst GET_PROJECT_CONFIG = new api_request_1.ApiSettings('/config', 'GET').setResponseValidator(response => {\n  // Response should always contain at least the config name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get project config');\n  }\n});\n/** Instantiates the updateConfig endpoint settings. */\nconst UPDATE_PROJECT_CONFIG = new api_request_1.ApiSettings('/config?updateMask={updateMask}', 'PATCH').setResponseValidator(response => {\n  // Response should always contain at least the config name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update project config');\n  }\n});\n/** Instantiates the getTenant endpoint settings. */\nconst GET_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'GET')\n// Set response validator.\n.setResponseValidator(response => {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get tenant');\n  }\n});\n/** Instantiates the deleteTenant endpoint settings. */\nconst DELETE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'DELETE');\n/** Instantiates the updateTenant endpoint settings. */\nconst UPDATE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}?updateMask={updateMask}', 'PATCH')\n// Set response validator.\n.setResponseValidator(response => {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update tenant');\n  }\n});\n/** Instantiates the listTenants endpoint settings. */\nconst LIST_TENANTS = new api_request_1.ApiSettings('/tenants', 'GET')\n// Set request validator.\n.setRequestValidator(request => {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  }\n  // Validate max results.\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive non-zero number that does not exceed ' + `the allowed ${MAX_LIST_TENANT_PAGE_SIZE}.`);\n  }\n});\n/** Instantiates the createTenant endpoint settings. */\nconst CREATE_TENANT = new api_request_1.ApiSettings('/tenants', 'POST')\n// Set response validator.\n.setResponseValidator(response => {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new tenant');\n  }\n});\n/**\r\n * Utility for sending requests to Auth server that are Auth instance related. This includes user, tenant,\r\n * and project config management related APIs. This extends the BaseFirebaseAuthRequestHandler class and defines\r\n * additional tenant management related APIs.\r\n */\nclass AuthRequestHandler extends AbstractAuthRequestHandler {\n  /**\r\n   * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.\r\n   *\r\n   * @param app - The app used to fetch access tokens to sign API requests.\r\n   * @constructor\r\n   */\n  constructor(app) {\n    super(app);\n    this.authResourceUrlBuilder = new AuthResourceUrlBuilder(app, 'v2');\n  }\n  /**\r\n   * @returns A new Auth user management resource URL builder instance.\r\n   */\n  newAuthUrlBuilder() {\n    return new AuthResourceUrlBuilder(this.app, 'v1');\n  }\n  /**\r\n   * @returns A new project config resource URL builder instance.\r\n   */\n  newProjectConfigUrlBuilder() {\n    return new AuthResourceUrlBuilder(this.app, 'v2');\n  }\n  /**\r\n   * Get the current project's config\r\n   * @returns A promise that resolves with the project config information.\r\n   */\n  getProjectConfig() {\n    return this.invokeRequestHandler(this.authResourceUrlBuilder, GET_PROJECT_CONFIG, {}, {}).then(response => {\n      return response;\n    });\n  }\n  /**\r\n   * Update the current project's config.\r\n   * @returns A promise that resolves with the project config information.\r\n   */\n  updateProjectConfig(options) {\n    try {\n      const request = project_config_1.ProjectConfig.buildServerRequest(options);\n      const updateMask = utils.generateUpdateMask(request);\n      return this.invokeRequestHandler(this.authResourceUrlBuilder, UPDATE_PROJECT_CONFIG, request, {\n        updateMask: updateMask.join(',')\n      }).then(response => {\n        return response;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\r\n   * Looks up a tenant by tenant ID.\r\n   *\r\n   * @param tenantId - The tenant identifier of the tenant to lookup.\r\n   * @returns A promise that resolves with the tenant information.\r\n   */\n  getTenant(tenantId) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n    return this.invokeRequestHandler(this.authResourceUrlBuilder, GET_TENANT, {}, {\n      tenantId\n    }).then(response => {\n      return response;\n    });\n  }\n  /**\r\n   * Exports the tenants (single batch only) with a size of maxResults and starting from\r\n   * the offset as specified by pageToken.\r\n   *\r\n   * @param maxResults - The page size, 1000 if undefined. This is also the maximum\r\n   *     allowed limit.\r\n   * @param pageToken - The next page token. If not specified, returns tenants starting\r\n   *     without any offset. Tenants are returned in the order they were created from oldest to\r\n   *     newest, relative to the page token offset.\r\n   * @returns A promise that resolves with the current batch of downloaded\r\n   *     tenants and the next page token if available. For the last page, an empty list of tenants\r\n   *     and no page token are returned.\r\n   */\n  listTenants(maxResults = MAX_LIST_TENANT_PAGE_SIZE, pageToken) {\n    const request = {\n      pageSize: maxResults,\n      pageToken\n    };\n    // Remove next page token if not provided.\n    if (typeof request.pageToken === 'undefined') {\n      delete request.pageToken;\n    }\n    return this.invokeRequestHandler(this.authResourceUrlBuilder, LIST_TENANTS, request).then(response => {\n      if (!response.tenants) {\n        response.tenants = [];\n        delete response.nextPageToken;\n      }\n      return response;\n    });\n  }\n  /**\r\n   * Deletes a tenant identified by a tenantId.\r\n   *\r\n   * @param tenantId - The identifier of the tenant to delete.\r\n   * @returns A promise that resolves when the tenant is deleted.\r\n   */\n  deleteTenant(tenantId) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n    return this.invokeRequestHandler(this.authResourceUrlBuilder, DELETE_TENANT, undefined, {\n      tenantId\n    }).then(() => {\n      // Return nothing.\n    });\n  }\n  /**\r\n   * Creates a new tenant with the properties provided.\r\n   *\r\n   * @param tenantOptions - The properties to set on the new tenant to be created.\r\n   * @returns A promise that resolves with the newly created tenant object.\r\n   */\n  createTenant(tenantOptions) {\n    try {\n      // Construct backend request.\n      const request = tenant_1.Tenant.buildServerRequest(tenantOptions, true);\n      return this.invokeRequestHandler(this.authResourceUrlBuilder, CREATE_TENANT, request).then(response => {\n        return response;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\r\n   * Updates an existing tenant with the properties provided.\r\n   *\r\n   * @param tenantId - The tenant identifier of the tenant to update.\r\n   * @param tenantOptions - The properties to update on the existing tenant.\r\n   * @returns A promise that resolves with the modified tenant object.\r\n   */\n  updateTenant(tenantId, tenantOptions) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n    try {\n      // Construct backend request.\n      const request = tenant_1.Tenant.buildServerRequest(tenantOptions, false);\n      // Do not traverse deep into testPhoneNumbers. The entire content should be replaced\n      // and not just specific phone numbers.\n      const updateMask = utils.generateUpdateMask(request, ['testPhoneNumbers']);\n      return this.invokeRequestHandler(this.authResourceUrlBuilder, UPDATE_TENANT, request, {\n        tenantId,\n        updateMask: updateMask.join(',')\n      }).then(response => {\n        return response;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n}\nexports.AuthRequestHandler = AuthRequestHandler;\n/**\r\n * Utility for sending requests to Auth server that are tenant Auth instance related. This includes user\r\n * management related APIs for specified tenants.\r\n * This extends the BaseFirebaseAuthRequestHandler class.\r\n */\nclass TenantAwareAuthRequestHandler extends AbstractAuthRequestHandler {\n  /**\r\n   * The FirebaseTenantRequestHandler constructor used to initialize an instance using a\r\n   * FirebaseApp and a tenant ID.\r\n   *\r\n   * @param app - The app used to fetch access tokens to sign API requests.\r\n   * @param tenantId - The request handler's tenant ID.\r\n   * @constructor\r\n   */\n  constructor(app, tenantId) {\n    super(app);\n    this.tenantId = tenantId;\n  }\n  /**\r\n   * @returns A new Auth user management resource URL builder instance.\r\n   */\n  newAuthUrlBuilder() {\n    return new TenantAwareAuthResourceUrlBuilder(this.app, 'v1', this.tenantId);\n  }\n  /**\r\n   * @returns A new project config resource URL builder instance.\r\n   */\n  newProjectConfigUrlBuilder() {\n    return new TenantAwareAuthResourceUrlBuilder(this.app, 'v2', this.tenantId);\n  }\n  /**\r\n   * Imports the list of users provided to Firebase Auth. This is useful when\r\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\r\n   * At most, 1000 users are allowed to be imported one at a time.\r\n   * When importing a list of password users, UserImportOptions are required to be specified.\r\n   *\r\n   * Overrides the superclass methods by adding an additional check to match tenant IDs of\r\n   * imported user records if present.\r\n   *\r\n   * @param users - The list of user records to import to Firebase Auth.\r\n   * @param options - The user import options, required when the users provided\r\n   *     include password credentials.\r\n   * @returns A promise that resolves when the operation completes\r\n   *     with the result of the import. This includes the number of successful imports, the number\r\n   *     of failed uploads and their corresponding errors.\r\n   */\n  uploadAccount(users, options) {\n    // Add additional check to match tenant ID of imported user records.\n    users.forEach((user, index) => {\n      if (validator.isNonEmptyString(user.tenantId) && user.tenantId !== this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, `UserRecord of index \"${index}\" has mismatching tenant ID \"${user.tenantId}\"`);\n      }\n    });\n    return super.uploadAccount(users, options);\n  }\n}\nexports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;\nfunction emulatorHost() {\n  return process.env.FIREBASE_AUTH_EMULATOR_HOST;\n}\n/**\r\n * When true the SDK should communicate with the Auth Emulator for all API\r\n * calls and also produce unsigned tokens.\r\n */\nfunction useEmulator() {\n  return !!emulatorHost();\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TenantAwareAuthRequestHandler","AuthRequestHandler","AbstractAuthRequestHandler","FIREBASE_AUTH_SIGN_UP_NEW_USER","FIREBASE_AUTH_SET_ACCOUNT_INFO","FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS","FIREBASE_AUTH_DELETE_ACCOUNT","FIREBASE_AUTH_GET_ACCOUNTS_INFO","FIREBASE_AUTH_GET_ACCOUNT_INFO","FIREBASE_AUTH_DOWNLOAD_ACCOUNT","FIREBASE_AUTH_UPLOAD_ACCOUNT","FIREBASE_AUTH_CREATE_SESSION_COOKIE","EMAIL_ACTION_REQUEST_TYPES","RESERVED_CLAIMS","useEmulator","validator","require","deep_copy_1","error_1","api_request_1","utils","user_import_builder_1","action_code_settings_builder_1","tenant_1","identifier_1","auth_config_1","project_config_1","FIREBASE_AUTH_HEADERS","getSdkVersion","FIREBASE_AUTH_TIMEOUT","MAX_CLAIMS_PAYLOAD_SIZE","MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE","MAX_UPLOAD_ACCOUNT_BATCH_SIZE","MAX_GET_ACCOUNTS_BATCH_SIZE","MAX_DELETE_ACCOUNTS_BATCH_SIZE","MIN_SESSION_COOKIE_DURATION_SECS","MAX_SESSION_COOKIE_DURATION_SECS","MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE","FIREBASE_AUTH_BASE_URL_FORMAT","FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT","FIREBASE_AUTH_TENANT_URL_FORMAT","replace","FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT","MAX_LIST_TENANT_PAGE_SIZE","WriteOperationType","AuthResourceUrlBuilder","constructor","app","version","urlFormat","formatString","host","emulatorHost","getUrl","api","params","getProjectId","then","projectId","baseParams","baseUrl","Promise","resolve","findProjectId","isNonEmptyString","FirebaseAuthError","AuthClientErrorCode","INVALID_CREDENTIAL","TenantAwareAuthResourceUrlBuilder","tenantId","url","AuthHttpClient","AuthorizedHttpClient","getToken","validateAuthFactorInfo","request","validKeys","mfaEnrollmentId","displayName","phoneInfo","enrolledAt","key","authFactorInfoIdentifier","JSON","stringify","INVALID_UID","isString","INVALID_DISPLAY_NAME","isISODateString","INVALID_ENROLLMENT_TIME","isPhoneNumber","INVALID_PHONE_NUMBER","INVALID_ENROLLED_FACTORS","validateProviderUserInfo","rawId","providerId","email","photoUrl","INVALID_PROVIDER_ID","isEmail","INVALID_EMAIL","isURL","INVALID_PHOTO_URL","validateCreateEditRequest","writeOperationType","uploadAccountRequest","Upload","localId","password","rawPassword","emailVerified","disabled","disableUser","deleteAttribute","deleteProvider","sanityCheck","phoneNumber","customAttributes","validSince","linkProviderUserInfo","passwordHash","salt","createdAt","lastLoginAt","providerUserInfo","mfaInfo","mfa","INVALID_TENANT_ID","isUid","isPassword","INVALID_PASSWORD","INVALID_EMAIL_VERIFIED","INVALID_DISABLED_FIELD","isNumber","INVALID_TOKENS_VALID_AFTER_TIME","INVALID_CREATION_TIME","INVALID_LAST_SIGN_IN_TIME","developerClaims","parse","error","INVALID_CLAIMS","message","invalidClaims","forEach","blacklistedClaim","prototype","hasOwnProperty","call","push","length","FORBIDDEN_CLAIM","join","CLAIMS_TOO_LARGE","INVALID_PASSWORD_HASH","INVALID_PASSWORD_SALT","isArray","INVALID_PROVIDER_DATA","providerUserInfoEntry","enrollments","authFactorInfoEntry","ApiSettings","setRequestValidator","idToken","INVALID_ID_TOKEN","validDuration","INVALID_SESSION_COOKIE_DURATION","setResponseValidator","response","sessionCookie","INTERNAL_ERROR","nextPageToken","INVALID_PAGE_TOKEN","maxResults","INVALID_ARGUMENT","federatedUserId","users","USER_NOT_FOUND","localIds","force","errors","batchDeleteErrorInfo","index","Update","Create","FIREBASE_AUTH_GET_OOB_CODE","newEmail","INVALID_NEW_EMAIL","indexOf","requestType","oobLink","GET_OAUTH_IDP_CONFIG","name","DELETE_OAUTH_IDP_CONFIG","CREATE_OAUTH_IDP_CONFIG","UPDATE_OAUTH_IDP_CONFIG","LIST_OAUTH_IDP_CONFIGS","pageToken","pageSize","GET_INBOUND_SAML_CONFIG","DELETE_INBOUND_SAML_CONFIG","CREATE_INBOUND_SAML_CONFIG","UPDATE_INBOUND_SAML_CONFIG","LIST_INBOUND_SAML_CONFIGS","getErrorCode","isNonNullObject","addUidToRequest","id","uid","addEmailToRequest","addPhoneToRequest","addProviderToRequest","providerUid","INVALID_PROVIDER_UID","httpClient","createSessionCookie","expiresIn","Math","floor","invokeRequestHandler","getAuthUrlBuilder","getAccountInfoByUid","reject","getAccountInfoByEmail","getAccountInfoByPhoneNumber","getAccountInfoByFederatedUid","getAccountInfoByIdentifiers","identifiers","MAXIMUM_USER_COUNT_EXCEEDED","isUidIdentifier","isEmailIdentifier","isPhoneIdentifier","isProviderIdentifier","downloadAccount","uploadAccount","options","userImportBuilder","UserImportBuilder","userRequest","buildRequest","buildResponse","failedUploads","deleteAccount","deleteAccounts","uids","setCustomUserClaims","customUserClaims","isObject","updateExistingAccount","properties","providerToLink","providersToUnlink","deepCopy","deletableParams","photoURL","concat","multiFactor","enrolledFactors","multiFactorInfo","convertMultiFactorInfoToServerFormat","e","revokeRefreshTokens","Date","getTime","createNewAccount","isNonEmptyArray","getEmailActionLink","actionCodeSettings","returnOobLink","builder","ActionCodeSettingsBuilder","deepExtend","getOAuthIdpConfig","OIDCConfig","isProviderId","getProjectConfigUrlBuilder","listOAuthIdpConfigs","oauthIdpConfigs","deleteOAuthIdpConfig","createOAuthIdpConfig","buildServerRequest","getProviderIdFromResourceName","updateOAuthIdpConfig","updateMask","generateUpdateMask","getInboundSamlConfig","SAMLConfig","listInboundSamlConfigs","inboundSamlConfigs","deleteInboundSamlConfig","createInboundSamlConfig","updateInboundSamlConfig","urlBuilder","apiSettings","requestData","additionalResourceParams","getEndpoint","requestValidator","getRequestValidator","req","method","getHttpMethod","headers","data","timeout","send","responseValidator","getResponseValidator","catch","err","RequestResponseError","errorCode","fromServerError","undefined","authUrlBuilder","newAuthUrlBuilder","projectConfigUrlBuilder","newProjectConfigUrlBuilder","GET_PROJECT_CONFIG","UPDATE_PROJECT_CONFIG","GET_TENANT","DELETE_TENANT","UPDATE_TENANT","Tenant","getTenantIdFromResourceName","LIST_TENANTS","CREATE_TENANT","authResourceUrlBuilder","getProjectConfig","updateProjectConfig","ProjectConfig","getTenant","listTenants","tenants","deleteTenant","createTenant","tenantOptions","updateTenant","user","MISMATCHING_TENANT_ID","process","env","FIREBASE_AUTH_EMULATOR_HOST"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/firebase-admin/lib/auth/auth-api-request.js"],"sourcesContent":["/*! firebase-admin v13.0.1 */\r\n\"use strict\";\r\n/*!\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TenantAwareAuthRequestHandler = exports.AuthRequestHandler = exports.AbstractAuthRequestHandler = exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = exports.FIREBASE_AUTH_DELETE_ACCOUNT = exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = exports.EMAIL_ACTION_REQUEST_TYPES = exports.RESERVED_CLAIMS = void 0;\r\nexports.useEmulator = useEmulator;\r\nconst validator = require(\"../utils/validator\");\r\nconst deep_copy_1 = require(\"../utils/deep-copy\");\r\nconst error_1 = require(\"../utils/error\");\r\nconst api_request_1 = require(\"../utils/api-request\");\r\nconst utils = require(\"../utils/index\");\r\nconst user_import_builder_1 = require(\"./user-import-builder\");\r\nconst action_code_settings_builder_1 = require(\"./action-code-settings-builder\");\r\nconst tenant_1 = require(\"./tenant\");\r\nconst identifier_1 = require(\"./identifier\");\r\nconst auth_config_1 = require(\"./auth-config\");\r\nconst project_config_1 = require(\"./project-config\");\r\n/** Firebase Auth request header. */\r\nconst FIREBASE_AUTH_HEADERS = {\r\n    'X-Client-Version': `Node/Admin/${utils.getSdkVersion()}`,\r\n};\r\n/** Firebase Auth request timeout duration in milliseconds. */\r\nconst FIREBASE_AUTH_TIMEOUT = 25000;\r\n/** List of reserved claims which cannot be provided when creating a custom token. */\r\nexports.RESERVED_CLAIMS = [\r\n    'acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat',\r\n    'iss', 'jti', 'nbf', 'nonce', 'sub', 'firebase',\r\n];\r\n/** List of supported email action request types. */\r\nexports.EMAIL_ACTION_REQUEST_TYPES = [\r\n    'PASSWORD_RESET', 'VERIFY_EMAIL', 'EMAIL_SIGNIN', 'VERIFY_AND_CHANGE_EMAIL',\r\n];\r\n/** Maximum allowed number of characters in the custom claims payload. */\r\nconst MAX_CLAIMS_PAYLOAD_SIZE = 1000;\r\n/** Maximum allowed number of users to batch download at one time. */\r\nconst MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1000;\r\n/** Maximum allowed number of users to batch upload at one time. */\r\nconst MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1000;\r\n/** Maximum allowed number of users to batch get at one time. */\r\nconst MAX_GET_ACCOUNTS_BATCH_SIZE = 100;\r\n/** Maximum allowed number of users to batch delete at one time. */\r\nconst MAX_DELETE_ACCOUNTS_BATCH_SIZE = 1000;\r\n/** Minimum allowed session cookie duration in seconds (5 minutes). */\r\nconst MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;\r\n/** Maximum allowed session cookie duration in seconds (2 weeks). */\r\nconst MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;\r\n/** Maximum allowed number of provider configurations to batch download at one time. */\r\nconst MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;\r\n/** The Firebase Auth backend base URL format. */\r\nconst FIREBASE_AUTH_BASE_URL_FORMAT = 'https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\r\n/** Firebase Auth base URlLformat when using the auth emultor. */\r\nconst FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT = 'http://{host}/identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\r\n/** The Firebase Auth backend multi-tenancy base URL format. */\r\nconst FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\r\n/** Firebase Auth base URL format when using the auth emultor with multi-tenancy. */\r\nconst FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT = FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\r\n/** Maximum allowed number of tenants to download at one time. */\r\nconst MAX_LIST_TENANT_PAGE_SIZE = 1000;\r\n/**\r\n * Enum for the user write operation type.\r\n */\r\nvar WriteOperationType;\r\n(function (WriteOperationType) {\r\n    WriteOperationType[\"Create\"] = \"create\";\r\n    WriteOperationType[\"Update\"] = \"update\";\r\n    WriteOperationType[\"Upload\"] = \"upload\";\r\n})(WriteOperationType || (WriteOperationType = {}));\r\n/** Defines a base utility to help with resource URL construction. */\r\nclass AuthResourceUrlBuilder {\r\n    /**\r\n     * The resource URL builder constructor.\r\n     *\r\n     * @param projectId - The resource project ID.\r\n     * @param version - The endpoint API version.\r\n     * @constructor\r\n     */\r\n    constructor(app, version = 'v1') {\r\n        this.app = app;\r\n        this.version = version;\r\n        if (useEmulator()) {\r\n            this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT, {\r\n                host: emulatorHost()\r\n            });\r\n        }\r\n        else {\r\n            this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the resource URL corresponding to the provided parameters.\r\n     *\r\n     * @param api - The backend API name.\r\n     * @param params - The optional additional parameters to substitute in the\r\n     *     URL path.\r\n     * @returns The corresponding resource URL.\r\n     */\r\n    getUrl(api, params) {\r\n        return this.getProjectId()\r\n            .then((projectId) => {\r\n            const baseParams = {\r\n                version: this.version,\r\n                projectId,\r\n                api: api || '',\r\n            };\r\n            const baseUrl = utils.formatString(this.urlFormat, baseParams);\r\n            // Substitute additional api related parameters.\r\n            return utils.formatString(baseUrl, params || {});\r\n        });\r\n    }\r\n    getProjectId() {\r\n        if (this.projectId) {\r\n            return Promise.resolve(this.projectId);\r\n        }\r\n        return utils.findProjectId(this.app)\r\n            .then((projectId) => {\r\n            if (!validator.isNonEmptyString(projectId)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'Failed to determine project ID for Auth. Initialize the '\r\n                    + 'SDK with service account credentials or set project ID as an app option. '\r\n                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\r\n            }\r\n            this.projectId = projectId;\r\n            return projectId;\r\n        });\r\n    }\r\n}\r\n/** Tenant aware resource builder utility. */\r\nclass TenantAwareAuthResourceUrlBuilder extends AuthResourceUrlBuilder {\r\n    /**\r\n     * The tenant aware resource URL builder constructor.\r\n     *\r\n     * @param projectId - The resource project ID.\r\n     * @param version - The endpoint API version.\r\n     * @param tenantId - The tenant ID.\r\n     * @constructor\r\n     */\r\n    constructor(app, version, tenantId) {\r\n        super(app, version);\r\n        this.app = app;\r\n        this.version = version;\r\n        this.tenantId = tenantId;\r\n        if (useEmulator()) {\r\n            this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT, {\r\n                host: emulatorHost()\r\n            });\r\n        }\r\n        else {\r\n            this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the resource URL corresponding to the provided parameters.\r\n     *\r\n     * @param api - The backend API name.\r\n     * @param params - The optional additional parameters to substitute in the\r\n     *     URL path.\r\n     * @returns The corresponding resource URL.\r\n     */\r\n    getUrl(api, params) {\r\n        return super.getUrl(api, params)\r\n            .then((url) => {\r\n            return utils.formatString(url, { tenantId: this.tenantId });\r\n        });\r\n    }\r\n}\r\n/**\r\n * Auth-specific HTTP client which uses the special \"owner\" token\r\n * when communicating with the Auth Emulator.\r\n */\r\nclass AuthHttpClient extends api_request_1.AuthorizedHttpClient {\r\n    getToken() {\r\n        if (useEmulator()) {\r\n            return Promise.resolve('owner');\r\n        }\r\n        return super.getToken();\r\n    }\r\n}\r\n/**\r\n * Validates an AuthFactorInfo object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param request - The AuthFactorInfo request object.\r\n */\r\nfunction validateAuthFactorInfo(request) {\r\n    const validKeys = {\r\n        mfaEnrollmentId: true,\r\n        displayName: true,\r\n        phoneInfo: true,\r\n        enrolledAt: true,\r\n    };\r\n    // Remove unsupported keys from the original request.\r\n    for (const key in request) {\r\n        if (!(key in validKeys)) {\r\n            delete request[key];\r\n        }\r\n    }\r\n    // No enrollment ID is available for signupNewUser. Use another identifier.\r\n    const authFactorInfoIdentifier = request.mfaEnrollmentId || request.phoneInfo || JSON.stringify(request);\r\n    // Enrollment uid may or may not be specified for update operations.\r\n    if (typeof request.mfaEnrollmentId !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.mfaEnrollmentId)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, 'The second factor \"uid\" must be a valid non-empty string.');\r\n    }\r\n    if (typeof request.displayName !== 'undefined' &&\r\n        !validator.isString(request.displayName)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The second factor \"displayName\" for \"${authFactorInfoIdentifier}\" must be a valid string.`);\r\n    }\r\n    // enrolledAt must be a valid UTC date string.\r\n    if (typeof request.enrolledAt !== 'undefined' &&\r\n        !validator.isISODateString(request.enrolledAt)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor \"enrollmentTime\" for \"${authFactorInfoIdentifier}\" must be a valid ` +\r\n            'UTC date string.');\r\n    }\r\n    // Validate required fields depending on second factor type.\r\n    if (typeof request.phoneInfo !== 'undefined') {\r\n        // phoneNumber should be a string and a valid phone number.\r\n        if (!validator.isPhoneNumber(request.phoneInfo)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER, `The second factor \"phoneNumber\" for \"${authFactorInfoIdentifier}\" must be a non-empty ` +\r\n                'E.164 standard compliant identifier string.');\r\n        }\r\n    }\r\n    else {\r\n        // Invalid second factor. For example, a phone second factor may have been provided without\r\n        // a phone number. A TOTP based second factor may require a secret key, etc.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS, 'MFAInfo object provided is invalid.');\r\n    }\r\n}\r\n/**\r\n * Validates a providerUserInfo object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param request - The providerUserInfo request object.\r\n */\r\nfunction validateProviderUserInfo(request) {\r\n    const validKeys = {\r\n        rawId: true,\r\n        providerId: true,\r\n        email: true,\r\n        displayName: true,\r\n        photoUrl: true,\r\n    };\r\n    // Remove invalid keys from original request.\r\n    for (const key in request) {\r\n        if (!(key in validKeys)) {\r\n            delete request[key];\r\n        }\r\n    }\r\n    if (!validator.isNonEmptyString(request.providerId)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\r\n    }\r\n    if (typeof request.displayName !== 'undefined' &&\r\n        typeof request.displayName !== 'string') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The provider \"displayName\" for \"${request.providerId}\" must be a valid string.`);\r\n    }\r\n    if (!validator.isNonEmptyString(request.rawId)) {\r\n        // This is called localId on the backend but the developer specifies this as\r\n        // uid externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, `The provider \"uid\" for \"${request.providerId}\" must be a valid non-empty string.`);\r\n    }\r\n    // email should be a string and a valid email.\r\n    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, `The provider \"email\" for \"${request.providerId}\" must be a valid email string.`);\r\n    }\r\n    // photoUrl should be a URL.\r\n    if (typeof request.photoUrl !== 'undefined' &&\r\n        !validator.isURL(request.photoUrl)) {\r\n        // This is called photoUrl on the backend but the developer specifies this as\r\n        // photoURL externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, `The provider \"photoURL\" for \"${request.providerId}\" must be a valid URL string.`);\r\n    }\r\n}\r\n/**\r\n * Validates a create/edit request object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param request - The create/edit request object.\r\n * @param writeOperationType - The write operation type.\r\n */\r\nfunction validateCreateEditRequest(request, writeOperationType) {\r\n    const uploadAccountRequest = writeOperationType === WriteOperationType.Upload;\r\n    // Hash set of whitelisted parameters.\r\n    const validKeys = {\r\n        displayName: true,\r\n        localId: true,\r\n        email: true,\r\n        password: true,\r\n        rawPassword: true,\r\n        emailVerified: true,\r\n        photoUrl: true,\r\n        disabled: true,\r\n        disableUser: true,\r\n        deleteAttribute: true,\r\n        deleteProvider: true,\r\n        sanityCheck: true,\r\n        phoneNumber: true,\r\n        customAttributes: true,\r\n        validSince: true,\r\n        // Pass linkProviderUserInfo only for updates (i.e. not for uploads.)\r\n        linkProviderUserInfo: !uploadAccountRequest,\r\n        // Pass tenantId only for uploadAccount requests.\r\n        tenantId: uploadAccountRequest,\r\n        passwordHash: uploadAccountRequest,\r\n        salt: uploadAccountRequest,\r\n        createdAt: uploadAccountRequest,\r\n        lastLoginAt: uploadAccountRequest,\r\n        providerUserInfo: uploadAccountRequest,\r\n        mfaInfo: uploadAccountRequest,\r\n        // Only for non-uploadAccount requests.\r\n        mfa: !uploadAccountRequest,\r\n    };\r\n    // Remove invalid keys from original request.\r\n    for (const key in request) {\r\n        if (!(key in validKeys)) {\r\n            delete request[key];\r\n        }\r\n    }\r\n    if (typeof request.tenantId !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.tenantId)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\r\n    }\r\n    // For any invalid parameter, use the external key name in the error description.\r\n    // displayName should be a string.\r\n    if (typeof request.displayName !== 'undefined' &&\r\n        !validator.isString(request.displayName)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);\r\n    }\r\n    if ((typeof request.localId !== 'undefined' || uploadAccountRequest) &&\r\n        !validator.isUid(request.localId)) {\r\n        // This is called localId on the backend but the developer specifies this as\r\n        // uid externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\r\n    }\r\n    // email should be a string and a valid email.\r\n    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\r\n    }\r\n    // phoneNumber should be a string and a valid phone number.\r\n    if (typeof request.phoneNumber !== 'undefined' &&\r\n        !validator.isPhoneNumber(request.phoneNumber)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\r\n    }\r\n    // password should be a string and a minimum of 6 chars.\r\n    if (typeof request.password !== 'undefined' &&\r\n        !validator.isPassword(request.password)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\r\n    }\r\n    // rawPassword should be a string and a minimum of 6 chars.\r\n    if (typeof request.rawPassword !== 'undefined' &&\r\n        !validator.isPassword(request.rawPassword)) {\r\n        // This is called rawPassword on the backend but the developer specifies this as\r\n        // password externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\r\n    }\r\n    // emailVerified should be a boolean.\r\n    if (typeof request.emailVerified !== 'undefined' &&\r\n        typeof request.emailVerified !== 'boolean') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);\r\n    }\r\n    // photoUrl should be a URL.\r\n    if (typeof request.photoUrl !== 'undefined' &&\r\n        !validator.isURL(request.photoUrl)) {\r\n        // This is called photoUrl on the backend but the developer specifies this as\r\n        // photoURL externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);\r\n    }\r\n    // disabled should be a boolean.\r\n    if (typeof request.disabled !== 'undefined' &&\r\n        typeof request.disabled !== 'boolean') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\r\n    }\r\n    // validSince should be a number.\r\n    if (typeof request.validSince !== 'undefined' &&\r\n        !validator.isNumber(request.validSince)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);\r\n    }\r\n    // createdAt should be a number.\r\n    if (typeof request.createdAt !== 'undefined' &&\r\n        !validator.isNumber(request.createdAt)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);\r\n    }\r\n    // lastSignInAt should be a number.\r\n    if (typeof request.lastLoginAt !== 'undefined' &&\r\n        !validator.isNumber(request.lastLoginAt)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);\r\n    }\r\n    // disableUser should be a boolean.\r\n    if (typeof request.disableUser !== 'undefined' &&\r\n        typeof request.disableUser !== 'boolean') {\r\n        // This is called disableUser on the backend but the developer specifies this as\r\n        // disabled externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\r\n    }\r\n    // customAttributes should be stringified JSON with no blacklisted claims.\r\n    // The payload should not exceed 1KB.\r\n    if (typeof request.customAttributes !== 'undefined') {\r\n        let developerClaims;\r\n        try {\r\n            developerClaims = JSON.parse(request.customAttributes);\r\n        }\r\n        catch (error) {\r\n            // JSON parsing error. This should never happen as we stringify the claims internally.\r\n            // However, we still need to check since setAccountInfo via edit requests could pass\r\n            // this field.\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error.message);\r\n        }\r\n        const invalidClaims = [];\r\n        // Check for any invalid claims.\r\n        exports.RESERVED_CLAIMS.forEach((blacklistedClaim) => {\r\n            if (Object.prototype.hasOwnProperty.call(developerClaims, blacklistedClaim)) {\r\n                invalidClaims.push(blacklistedClaim);\r\n            }\r\n        });\r\n        // Throw an error if an invalid claim is detected.\r\n        if (invalidClaims.length > 0) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims.length > 1 ?\r\n                `Developer claims \"${invalidClaims.join('\", \"')}\" are reserved and cannot be specified.` :\r\n                `Developer claim \"${invalidClaims[0]}\" is reserved and cannot be specified.`);\r\n        }\r\n        // Check claims payload does not exceed maxmimum size.\r\n        if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, `Developer claims payload should not exceed ${MAX_CLAIMS_PAYLOAD_SIZE} characters.`);\r\n        }\r\n    }\r\n    // passwordHash has to be a base64 encoded string.\r\n    if (typeof request.passwordHash !== 'undefined' &&\r\n        !validator.isString(request.passwordHash)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\r\n    }\r\n    // salt has to be a base64 encoded string.\r\n    if (typeof request.salt !== 'undefined' &&\r\n        !validator.isString(request.salt)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\r\n    }\r\n    // providerUserInfo has to be an array of valid UserInfo requests.\r\n    if (typeof request.providerUserInfo !== 'undefined' &&\r\n        !validator.isArray(request.providerUserInfo)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);\r\n    }\r\n    else if (validator.isArray(request.providerUserInfo)) {\r\n        request.providerUserInfo.forEach((providerUserInfoEntry) => {\r\n            validateProviderUserInfo(providerUserInfoEntry);\r\n        });\r\n    }\r\n    // linkProviderUserInfo must be a (single) UserProvider value.\r\n    if (typeof request.linkProviderUserInfo !== 'undefined') {\r\n        validateProviderUserInfo(request.linkProviderUserInfo);\r\n    }\r\n    // mfaInfo is used for importUsers.\r\n    // mfa.enrollments is used for setAccountInfo.\r\n    // enrollments has to be an array of valid AuthFactorInfo requests.\r\n    let enrollments = null;\r\n    if (request.mfaInfo) {\r\n        enrollments = request.mfaInfo;\r\n    }\r\n    else if (request.mfa && request.mfa.enrollments) {\r\n        enrollments = request.mfa.enrollments;\r\n    }\r\n    if (enrollments) {\r\n        if (!validator.isArray(enrollments)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS);\r\n        }\r\n        enrollments.forEach((authFactorInfoEntry) => {\r\n            validateAuthFactorInfo(authFactorInfoEntry);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Instantiates the createSessionCookie endpoint settings.\r\n *\r\n * @internal\r\n */\r\nexports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(':createSessionCookie', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    // Validate the ID token is a non-empty string.\r\n    if (!validator.isNonEmptyString(request.idToken)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);\r\n    }\r\n    // Validate the custom session cookie duration.\r\n    if (!validator.isNumber(request.validDuration) ||\r\n        request.validDuration < MIN_SESSION_COOKIE_DURATION_SECS ||\r\n        request.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);\r\n    }\r\n})\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain the session cookie.\r\n    if (!validator.isNonEmptyString(response.sessionCookie)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);\r\n    }\r\n});\r\n/**\r\n * Instantiates the uploadAccount endpoint settings.\r\n *\r\n * @internal\r\n */\r\nexports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchCreate', 'POST');\r\n/**\r\n * Instantiates the downloadAccount endpoint settings.\r\n *\r\n * @internal\r\n */\r\nexports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchGet', 'GET')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    // Validate next page token.\r\n    if (typeof request.nextPageToken !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.nextPageToken)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\r\n    }\r\n    // Validate max results.\r\n    if (!validator.isNumber(request.maxResults) ||\r\n        request.maxResults <= 0 ||\r\n        request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' +\r\n            `${MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE}.`);\r\n    }\r\n});\r\n/**\r\n * Instantiates the getAccountInfo endpoint settings.\r\n *\r\n * @internal\r\n */\r\nexports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\r\n    }\r\n})\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    if (!response.users || !response.users.length) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\r\n    }\r\n});\r\n/**\r\n * Instantiates the getAccountInfo endpoint settings for use when fetching info\r\n * for multiple accounts.\r\n *\r\n * @internal\r\n */\r\nexports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\r\n    }\r\n});\r\n/**\r\n * Instantiates the deleteAccount endpoint settings.\r\n *\r\n * @internal\r\n */\r\nexports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings('/accounts:delete', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    if (!request.localId) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\r\n    }\r\n});\r\n/**\r\n * @internal\r\n */\r\nexports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = new api_request_1.ApiSettings('/accounts:batchDelete', 'POST')\r\n    .setRequestValidator((request) => {\r\n    if (!request.localIds) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifiers');\r\n    }\r\n    if (typeof request.force === 'undefined' || request.force !== true) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing force=true field');\r\n    }\r\n})\r\n    .setResponseValidator((response) => {\r\n    const errors = response.errors || [];\r\n    errors.forEach((batchDeleteErrorInfo) => {\r\n        if (typeof batchDeleteErrorInfo.index === 'undefined') {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.index field');\r\n        }\r\n        if (!batchDeleteErrorInfo.localId) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.localId field');\r\n        }\r\n        // Allow the (error) message to be missing/undef.\r\n    });\r\n});\r\n/**\r\n * Instantiates the setAccountInfo endpoint settings for updating existing accounts.\r\n *\r\n * @internal\r\n */\r\nexports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:update', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    // localId is a required parameter.\r\n    if (typeof request.localId === 'undefined') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\r\n    }\r\n    // Throw error when tenantId is passed in POST body.\r\n    if (typeof request.tenantId !== 'undefined') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"UpdateRequest\" property.');\r\n    }\r\n    validateCreateEditRequest(request, WriteOperationType.Update);\r\n})\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // If the localId is not returned, then the request failed.\r\n    if (!response.localId) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\r\n    }\r\n});\r\n/**\r\n * Instantiates the signupNewUser endpoint settings for creating a new user with or without\r\n * uid being specified. The backend will create a new one if not provided and return it.\r\n *\r\n * @internal\r\n */\r\nexports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings('/accounts', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    // signupNewUser does not support customAttributes.\r\n    if (typeof request.customAttributes !== 'undefined') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"customAttributes\" cannot be set when creating a new user.');\r\n    }\r\n    // signupNewUser does not support validSince.\r\n    if (typeof request.validSince !== 'undefined') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"validSince\" cannot be set when creating a new user.');\r\n    }\r\n    // Throw error when tenantId is passed in POST body.\r\n    if (typeof request.tenantId !== 'undefined') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"CreateRequest\" property.');\r\n    }\r\n    validateCreateEditRequest(request, WriteOperationType.Create);\r\n})\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // If the localId is not returned, then the request failed.\r\n    if (!response.localId) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new user');\r\n    }\r\n});\r\nconst FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings('/accounts:sendOobCode', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    if (!validator.isEmail(request.email)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\r\n    }\r\n    if (typeof request.newEmail !== 'undefined' && !validator.isEmail(request.newEmail)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_NEW_EMAIL);\r\n    }\r\n    if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request.requestType) === -1) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `\"${request.requestType}\" is not a supported email action request type.`);\r\n    }\r\n})\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // If the oobLink is not returned, then the request failed.\r\n    if (!response.oobLink) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create the email action link');\r\n    }\r\n});\r\n/**\r\n * Instantiates the retrieve OIDC configuration endpoint settings.\r\n *\r\n * @internal\r\n */\r\nconst GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'GET')\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain the OIDC provider resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get OIDC configuration');\r\n    }\r\n});\r\n/**\r\n * Instantiates the delete OIDC configuration endpoint settings.\r\n *\r\n * @internal\r\n */\r\nconst DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'DELETE');\r\n/**\r\n * Instantiates the create OIDC configuration endpoint settings.\r\n *\r\n * @internal\r\n */\r\nconst CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs?oauthIdpConfigId={providerId}', 'POST')\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain the OIDC provider resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC configuration');\r\n    }\r\n});\r\n/**\r\n * Instantiates the update OIDC configuration endpoint settings.\r\n *\r\n * @internal\r\n */\r\nconst UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}?updateMask={updateMask}', 'PATCH')\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain the configuration resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC configuration');\r\n    }\r\n});\r\n/**\r\n * Instantiates the list OIDC configuration endpoint settings.\r\n *\r\n * @internal\r\n */\r\nconst LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings('/oauthIdpConfigs', 'GET')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    // Validate next page token.\r\n    if (typeof request.pageToken !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.pageToken)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\r\n    }\r\n    // Validate max results.\r\n    if (!validator.isNumber(request.pageSize) ||\r\n        request.pageSize <= 0 ||\r\n        request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' +\r\n            `${MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE}.`);\r\n    }\r\n});\r\n/**\r\n * Instantiates the retrieve SAML configuration endpoint settings.\r\n *\r\n * @internal\r\n */\r\nconst GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'GET')\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain the SAML provider resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get SAML configuration');\r\n    }\r\n});\r\n/**\r\n * Instantiates the delete SAML configuration endpoint settings.\r\n *\r\n * @internal\r\n */\r\nconst DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'DELETE');\r\n/**\r\n * Instantiates the create SAML configuration endpoint settings.\r\n *\r\n * @internal\r\n */\r\nconst CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs?inboundSamlConfigId={providerId}', 'POST')\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain the SAML provider resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML configuration');\r\n    }\r\n});\r\n/**\r\n * Instantiates the update SAML configuration endpoint settings.\r\n *\r\n * @internal\r\n */\r\nconst UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}?updateMask={updateMask}', 'PATCH')\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain the configuration resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML configuration');\r\n    }\r\n});\r\n/**\r\n * Instantiates the list SAML configuration endpoint settings.\r\n *\r\n * @internal\r\n */\r\nconst LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings('/inboundSamlConfigs', 'GET')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    // Validate next page token.\r\n    if (typeof request.pageToken !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.pageToken)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\r\n    }\r\n    // Validate max results.\r\n    if (!validator.isNumber(request.pageSize) ||\r\n        request.pageSize <= 0 ||\r\n        request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' +\r\n            `${MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE}.`);\r\n    }\r\n});\r\n/**\r\n * Class that provides the mechanism to send requests to the Firebase Auth backend endpoints.\r\n *\r\n * @internal\r\n */\r\nclass AbstractAuthRequestHandler {\r\n    /**\r\n     * @param response - The response to check for errors.\r\n     * @returns The error code if present; null otherwise.\r\n     */\r\n    static getErrorCode(response) {\r\n        return (validator.isNonNullObject(response) && response.error && response.error.message) || null;\r\n    }\r\n    static addUidToRequest(id, request) {\r\n        if (!validator.isUid(id.uid)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\r\n        }\r\n        request.localId ? request.localId.push(id.uid) : request.localId = [id.uid];\r\n        return request;\r\n    }\r\n    static addEmailToRequest(id, request) {\r\n        if (!validator.isEmail(id.email)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\r\n        }\r\n        request.email ? request.email.push(id.email) : request.email = [id.email];\r\n        return request;\r\n    }\r\n    static addPhoneToRequest(id, request) {\r\n        if (!validator.isPhoneNumber(id.phoneNumber)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\r\n        }\r\n        request.phoneNumber ? request.phoneNumber.push(id.phoneNumber) : request.phoneNumber = [id.phoneNumber];\r\n        return request;\r\n    }\r\n    static addProviderToRequest(id, request) {\r\n        if (!validator.isNonEmptyString(id.providerId)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\r\n        }\r\n        if (!validator.isNonEmptyString(id.providerUid)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_UID);\r\n        }\r\n        const federatedUserId = {\r\n            providerId: id.providerId,\r\n            rawId: id.providerUid,\r\n        };\r\n        request.federatedUserId\r\n            ? request.federatedUserId.push(federatedUserId)\r\n            : request.federatedUserId = [federatedUserId];\r\n        return request;\r\n    }\r\n    /**\r\n     * @param app - The app used to fetch access tokens to sign API requests.\r\n     * @constructor\r\n     */\r\n    constructor(app) {\r\n        this.app = app;\r\n        if (typeof app !== 'object' || app === null || !('options' in app)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');\r\n        }\r\n        this.httpClient = new AuthHttpClient(app);\r\n    }\r\n    /**\r\n     * Creates a new Firebase session cookie with the specified duration that can be used for\r\n     * session management (set as a server side session cookie with custom cookie policy).\r\n     * The session cookie JWT will have the same payload claims as the provided ID token.\r\n     *\r\n     * @param idToken - The Firebase ID token to exchange for a session cookie.\r\n     * @param expiresIn - The session cookie duration in milliseconds.\r\n     *\r\n     * @returns A promise that resolves on success with the created session cookie.\r\n     */\r\n    createSessionCookie(idToken, expiresIn) {\r\n        const request = {\r\n            idToken,\r\n            // Convert to seconds.\r\n            validDuration: Math.floor(expiresIn / 1000),\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request)\r\n            .then((response) => response.sessionCookie);\r\n    }\r\n    /**\r\n     * Looks up a user by uid.\r\n     *\r\n     * @param uid - The uid of the user to lookup.\r\n     * @returns A promise that resolves with the user information.\r\n     */\r\n    getAccountInfoByUid(uid) {\r\n        if (!validator.isUid(uid)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\r\n        }\r\n        const request = {\r\n            localId: [uid],\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\r\n    }\r\n    /**\r\n     * Looks up a user by email.\r\n     *\r\n     * @param email - The email of the user to lookup.\r\n     * @returns A promise that resolves with the user information.\r\n     */\r\n    getAccountInfoByEmail(email) {\r\n        if (!validator.isEmail(email)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));\r\n        }\r\n        const request = {\r\n            email: [email],\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\r\n    }\r\n    /**\r\n     * Looks up a user by phone number.\r\n     *\r\n     * @param phoneNumber - The phone number of the user to lookup.\r\n     * @returns A promise that resolves with the user information.\r\n     */\r\n    getAccountInfoByPhoneNumber(phoneNumber) {\r\n        if (!validator.isPhoneNumber(phoneNumber)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));\r\n        }\r\n        const request = {\r\n            phoneNumber: [phoneNumber],\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\r\n    }\r\n    getAccountInfoByFederatedUid(providerId, rawId) {\r\n        if (!validator.isNonEmptyString(providerId) || !validator.isNonEmptyString(rawId)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\r\n        }\r\n        const request = {\r\n            federatedUserId: [{\r\n                    providerId,\r\n                    rawId,\r\n                }],\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\r\n    }\r\n    /**\r\n     * Looks up multiple users by their identifiers (uid, email, etc).\r\n     *\r\n     * @param identifiers - The identifiers indicating the users\r\n     *     to be looked up. Must have <= 100 entries.\r\n     * @param A - promise that resolves with the set of successfully\r\n     *     looked up users. Possibly empty if no users were looked up.\r\n     */\r\n    getAccountInfoByIdentifiers(identifiers) {\r\n        if (identifiers.length === 0) {\r\n            return Promise.resolve({ users: [] });\r\n        }\r\n        else if (identifiers.length > MAX_GET_ACCOUNTS_BATCH_SIZE) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`identifiers` parameter must have <= ' + MAX_GET_ACCOUNTS_BATCH_SIZE + ' entries.');\r\n        }\r\n        let request = {};\r\n        for (const id of identifiers) {\r\n            if ((0, identifier_1.isUidIdentifier)(id)) {\r\n                request = AbstractAuthRequestHandler.addUidToRequest(id, request);\r\n            }\r\n            else if ((0, identifier_1.isEmailIdentifier)(id)) {\r\n                request = AbstractAuthRequestHandler.addEmailToRequest(id, request);\r\n            }\r\n            else if ((0, identifier_1.isPhoneIdentifier)(id)) {\r\n                request = AbstractAuthRequestHandler.addPhoneToRequest(id, request);\r\n            }\r\n            else if ((0, identifier_1.isProviderIdentifier)(id)) {\r\n                request = AbstractAuthRequestHandler.addProviderToRequest(id, request);\r\n            }\r\n            else {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Unrecognized identifier: ' + id);\r\n            }\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO, request);\r\n    }\r\n    /**\r\n     * Exports the users (single batch only) with a size of maxResults and starting from\r\n     * the offset as specified by pageToken.\r\n     *\r\n     * @param maxResults - The page size, 1000 if undefined. This is also the maximum\r\n     *     allowed limit.\r\n     * @param pageToken - The next page token. If not specified, returns users starting\r\n     *     without any offset. Users are returned in the order they were created from oldest to\r\n     *     newest, relative to the page token offset.\r\n     * @returns A promise that resolves with the current batch of downloaded\r\n     *     users and the next page token if available. For the last page, an empty list of users\r\n     *     and no page token are returned.\r\n     */\r\n    downloadAccount(maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE, pageToken) {\r\n        // Construct request.\r\n        const request = {\r\n            maxResults,\r\n            nextPageToken: pageToken,\r\n        };\r\n        // Remove next page token if not provided.\r\n        if (typeof request.nextPageToken === 'undefined') {\r\n            delete request.nextPageToken;\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request)\r\n            .then((response) => {\r\n            // No more users available.\r\n            if (!response.users) {\r\n                response.users = [];\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n    /**\r\n     * Imports the list of users provided to Firebase Auth. This is useful when\r\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\r\n     * At most, 1000 users are allowed to be imported one at a time.\r\n     * When importing a list of password users, UserImportOptions are required to be specified.\r\n     *\r\n     * @param users - The list of user records to import to Firebase Auth.\r\n     * @param options - The user import options, required when the users provided\r\n     *     include password credentials.\r\n     * @returns A promise that resolves when the operation completes\r\n     *     with the result of the import. This includes the number of successful imports, the number\r\n     *     of failed uploads and their corresponding errors.\r\n     */\r\n    uploadAccount(users, options) {\r\n        // This will throw if any error is detected in the hash options.\r\n        // For errors in the list of users, this will not throw and will report the errors and the\r\n        // corresponding user index in the user import generated response below.\r\n        // No need to validate raw request or raw response as this is done in UserImportBuilder.\r\n        const userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, (userRequest) => {\r\n            // Pass true to validate the uploadAccount specific fields.\r\n            validateCreateEditRequest(userRequest, WriteOperationType.Upload);\r\n        });\r\n        const request = userImportBuilder.buildRequest();\r\n        // Fail quickly if more users than allowed are to be imported.\r\n        if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, `A maximum of ${MAX_UPLOAD_ACCOUNT_BATCH_SIZE} users can be imported at once.`);\r\n        }\r\n        // If no remaining user in request after client side processing, there is no need\r\n        // to send the request to the server.\r\n        if (!request.users || request.users.length === 0) {\r\n            return Promise.resolve(userImportBuilder.buildResponse([]));\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request)\r\n            .then((response) => {\r\n            // No error object is returned if no error encountered.\r\n            const failedUploads = (response.error || []);\r\n            // Rewrite response as UserImportResult and re-insert client previously detected errors.\r\n            return userImportBuilder.buildResponse(failedUploads);\r\n        });\r\n    }\r\n    /**\r\n     * Deletes an account identified by a uid.\r\n     *\r\n     * @param uid - The uid of the user to delete.\r\n     * @returns A promise that resolves when the user is deleted.\r\n     */\r\n    deleteAccount(uid) {\r\n        if (!validator.isUid(uid)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\r\n        }\r\n        const request = {\r\n            localId: uid,\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);\r\n    }\r\n    deleteAccounts(uids, force) {\r\n        if (uids.length === 0) {\r\n            return Promise.resolve({});\r\n        }\r\n        else if (uids.length > MAX_DELETE_ACCOUNTS_BATCH_SIZE) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`uids` parameter must have <= ' + MAX_DELETE_ACCOUNTS_BATCH_SIZE + ' entries.');\r\n        }\r\n        const request = {\r\n            localIds: [],\r\n            force,\r\n        };\r\n        uids.forEach((uid) => {\r\n            if (!validator.isUid(uid)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\r\n            }\r\n            request.localIds.push(uid);\r\n        });\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS, request);\r\n    }\r\n    /**\r\n     * Sets additional developer claims on an existing user identified by provided UID.\r\n     *\r\n     * @param uid - The user to edit.\r\n     * @param customUserClaims - The developer claims to set.\r\n     * @returns A promise that resolves when the operation completes\r\n     *     with the user id that was edited.\r\n     */\r\n    setCustomUserClaims(uid, customUserClaims) {\r\n        // Validate user UID.\r\n        if (!validator.isUid(uid)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\r\n        }\r\n        else if (!validator.isObject(customUserClaims)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'CustomUserClaims argument must be an object or null.'));\r\n        }\r\n        // Delete operation. Replace null with an empty object.\r\n        if (customUserClaims === null) {\r\n            customUserClaims = {};\r\n        }\r\n        // Construct custom user attribute editting request.\r\n        const request = {\r\n            localId: uid,\r\n            customAttributes: JSON.stringify(customUserClaims),\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\r\n            .then((response) => {\r\n            return response.localId;\r\n        });\r\n    }\r\n    /**\r\n     * Edits an existing user.\r\n     *\r\n     * @param uid - The user to edit.\r\n     * @param properties - The properties to set on the user.\r\n     * @returns A promise that resolves when the operation completes\r\n     *     with the user id that was edited.\r\n     */\r\n    updateExistingAccount(uid, properties) {\r\n        if (!validator.isUid(uid)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\r\n        }\r\n        else if (!validator.isNonNullObject(properties)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\r\n        }\r\n        else if (validator.isNonNullObject(properties.providerToLink)) {\r\n            // TODO(rsgowman): These checks overlap somewhat with\r\n            // validateProviderUserInfo. It may be possible to refactor a bit.\r\n            if (!validator.isNonEmptyString(properties.providerToLink.providerId)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.providerId of properties argument must be a non-empty string.');\r\n            }\r\n            if (!validator.isNonEmptyString(properties.providerToLink.uid)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.uid of properties argument must be a non-empty string.');\r\n            }\r\n        }\r\n        else if (typeof properties.providersToUnlink !== 'undefined') {\r\n            if (!validator.isArray(properties.providersToUnlink)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');\r\n            }\r\n            properties.providersToUnlink.forEach((providerId) => {\r\n                if (!validator.isNonEmptyString(providerId)) {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');\r\n                }\r\n            });\r\n        }\r\n        // Build the setAccountInfo request.\r\n        const request = (0, deep_copy_1.deepCopy)(properties);\r\n        request.localId = uid;\r\n        // For deleting displayName or photoURL, these values must be passed as null.\r\n        // They will be removed from the backend request and an additional parameter\r\n        // deleteAttribute: ['PHOTO_URL', 'DISPLAY_NAME']\r\n        // with an array of the parameter names to delete will be passed.\r\n        // Parameters that are deletable and their deleteAttribute names.\r\n        // Use client facing names, photoURL instead of photoUrl.\r\n        const deletableParams = {\r\n            displayName: 'DISPLAY_NAME',\r\n            photoURL: 'PHOTO_URL',\r\n        };\r\n        // Properties to delete if available.\r\n        request.deleteAttribute = [];\r\n        for (const key in deletableParams) {\r\n            if (request[key] === null) {\r\n                // Add property identifier to list of attributes to delete.\r\n                request.deleteAttribute.push(deletableParams[key]);\r\n                // Remove property from request.\r\n                delete request[key];\r\n            }\r\n        }\r\n        if (request.deleteAttribute.length === 0) {\r\n            delete request.deleteAttribute;\r\n        }\r\n        // For deleting phoneNumber, this value must be passed as null.\r\n        // It will be removed from the backend request and an additional parameter\r\n        // deleteProvider: ['phone'] with an array of providerIds (phone in this case),\r\n        // will be passed.\r\n        if (request.phoneNumber === null) {\r\n            request.deleteProvider ? request.deleteProvider.push('phone') : request.deleteProvider = ['phone'];\r\n            delete request.phoneNumber;\r\n        }\r\n        if (typeof (request.providerToLink) !== 'undefined') {\r\n            request.linkProviderUserInfo = (0, deep_copy_1.deepCopy)(request.providerToLink);\r\n            delete request.providerToLink;\r\n            request.linkProviderUserInfo.rawId = request.linkProviderUserInfo.uid;\r\n            delete request.linkProviderUserInfo.uid;\r\n        }\r\n        if (typeof (request.providersToUnlink) !== 'undefined') {\r\n            if (!validator.isArray(request.deleteProvider)) {\r\n                request.deleteProvider = [];\r\n            }\r\n            request.deleteProvider = request.deleteProvider.concat(request.providersToUnlink);\r\n            delete request.providersToUnlink;\r\n        }\r\n        // Rewrite photoURL to photoUrl.\r\n        if (typeof request.photoURL !== 'undefined') {\r\n            request.photoUrl = request.photoURL;\r\n            delete request.photoURL;\r\n        }\r\n        // Rewrite disabled to disableUser.\r\n        if (typeof request.disabled !== 'undefined') {\r\n            request.disableUser = request.disabled;\r\n            delete request.disabled;\r\n        }\r\n        // Construct mfa related user data.\r\n        if (validator.isNonNullObject(request.multiFactor)) {\r\n            if (request.multiFactor.enrolledFactors === null) {\r\n                // Remove all second factors.\r\n                request.mfa = {};\r\n            }\r\n            else if (validator.isArray(request.multiFactor.enrolledFactors)) {\r\n                request.mfa = {\r\n                    enrollments: [],\r\n                };\r\n                try {\r\n                    request.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {\r\n                        request.mfa.enrollments.push((0, user_import_builder_1.convertMultiFactorInfoToServerFormat)(multiFactorInfo));\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    return Promise.reject(e);\r\n                }\r\n                if (request.mfa.enrollments.length === 0) {\r\n                    delete request.mfa.enrollments;\r\n                }\r\n            }\r\n            delete request.multiFactor;\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\r\n            .then((response) => {\r\n            return response.localId;\r\n        });\r\n    }\r\n    /**\r\n     * Revokes all refresh tokens for the specified user identified by the uid provided.\r\n     * In addition to revoking all refresh tokens for a user, all ID tokens issued\r\n     * before revocation will also be revoked on the Auth backend. Any request with an\r\n     * ID token generated before revocation will be rejected with a token expired error.\r\n     * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in\r\n     * the same second as the revocation will still be valid. If there is a chance that a token\r\n     * was minted in the last second, delay for 1 second before revoking.\r\n     *\r\n     * @param uid - The user whose tokens are to be revoked.\r\n     * @returns A promise that resolves when the operation completes\r\n     *     successfully with the user id of the corresponding user.\r\n     */\r\n    revokeRefreshTokens(uid) {\r\n        // Validate user UID.\r\n        if (!validator.isUid(uid)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\r\n        }\r\n        const request = {\r\n            localId: uid,\r\n            // validSince is in UTC seconds.\r\n            validSince: Math.floor(new Date().getTime() / 1000),\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\r\n            .then((response) => {\r\n            return response.localId;\r\n        });\r\n    }\r\n    /**\r\n     * Create a new user with the properties supplied.\r\n     *\r\n     * @param properties - The properties to set on the user.\r\n     * @returns A promise that resolves when the operation completes\r\n     *     with the user id that was created.\r\n     */\r\n    createNewAccount(properties) {\r\n        if (!validator.isNonNullObject(properties)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\r\n        }\r\n        const request = (0, deep_copy_1.deepCopy)(properties);\r\n        // Rewrite photoURL to photoUrl.\r\n        if (typeof request.photoURL !== 'undefined') {\r\n            request.photoUrl = request.photoURL;\r\n            delete request.photoURL;\r\n        }\r\n        // Rewrite uid to localId if it exists.\r\n        if (typeof request.uid !== 'undefined') {\r\n            request.localId = request.uid;\r\n            delete request.uid;\r\n        }\r\n        // Construct mfa related user data.\r\n        if (validator.isNonNullObject(request.multiFactor)) {\r\n            if (validator.isNonEmptyArray(request.multiFactor.enrolledFactors)) {\r\n                const mfaInfo = [];\r\n                try {\r\n                    request.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {\r\n                        // Enrollment time and uid are not allowed for signupNewUser endpoint.\r\n                        // They will automatically be provisioned server side.\r\n                        if ('enrollmentTime' in multiFactorInfo) {\r\n                            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"enrollmentTime\" is not supported when adding second factors via \"createUser()\"');\r\n                        }\r\n                        else if ('uid' in multiFactorInfo) {\r\n                            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"uid\" is not supported when adding second factors via \"createUser()\"');\r\n                        }\r\n                        mfaInfo.push((0, user_import_builder_1.convertMultiFactorInfoToServerFormat)(multiFactorInfo));\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    return Promise.reject(e);\r\n                }\r\n                request.mfaInfo = mfaInfo;\r\n            }\r\n            delete request.multiFactor;\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request)\r\n            .then((response) => {\r\n            // Return the user id.\r\n            return response.localId;\r\n        });\r\n    }\r\n    /**\r\n     * Generates the out of band email action link for the email specified using the action code settings provided.\r\n     * Returns a promise that resolves with the generated link.\r\n     *\r\n     * @param requestType - The request type. This could be either used for password reset,\r\n     *     email verification, email link sign-in.\r\n     * @param email - The email of the user the link is being sent to.\r\n     * @param actionCodeSettings - The optional action code setings which defines whether\r\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\r\n     *     deep link, etc. Required when requestType === 'EMAIL_SIGNIN'\r\n     * @param newEmail - The email address the account is being updated to.\r\n     *     Required only for VERIFY_AND_CHANGE_EMAIL requests.\r\n     * @returns A promise that resolves with the email action link.\r\n     */\r\n    getEmailActionLink(requestType, email, actionCodeSettings, newEmail) {\r\n        let request = {\r\n            requestType,\r\n            email,\r\n            returnOobLink: true,\r\n            ...(typeof newEmail !== 'undefined') && { newEmail },\r\n        };\r\n        // ActionCodeSettings required for email link sign-in to determine the url where the sign-in will\r\n        // be completed.\r\n        if (typeof actionCodeSettings === 'undefined' && requestType === 'EMAIL_SIGNIN') {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"`actionCodeSettings` is required when `requestType` === 'EMAIL_SIGNIN'\"));\r\n        }\r\n        if (typeof actionCodeSettings !== 'undefined' || requestType === 'EMAIL_SIGNIN') {\r\n            try {\r\n                const builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);\r\n                request = (0, deep_copy_1.deepExtend)(request, builder.buildRequest());\r\n            }\r\n            catch (e) {\r\n                return Promise.reject(e);\r\n            }\r\n        }\r\n        if (requestType === 'VERIFY_AND_CHANGE_EMAIL' && typeof newEmail === 'undefined') {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"`newEmail` is required when `requestType` === 'VERIFY_AND_CHANGE_EMAIL'\"));\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request)\r\n            .then((response) => {\r\n            // Return the link.\r\n            return response.oobLink;\r\n        });\r\n    }\r\n    /**\r\n     * Looks up an OIDC provider configuration by provider ID.\r\n     *\r\n     * @param providerId - The provider identifier of the configuration to lookup.\r\n     * @returns A promise that resolves with the provider configuration information.\r\n     */\r\n    getOAuthIdpConfig(providerId) {\r\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, { providerId });\r\n    }\r\n    /**\r\n     * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from\r\n     * the offset as specified by pageToken.\r\n     *\r\n     * @param maxResults - The page size, 100 if undefined. This is also the maximum\r\n     *     allowed limit.\r\n     * @param pageToken - The next page token. If not specified, returns OIDC configurations\r\n     *     without any offset. Configurations are returned in the order they were created from oldest to\r\n     *     newest, relative to the page token offset.\r\n     * @returns A promise that resolves with the current batch of downloaded\r\n     *     OIDC configurations and the next page token if available. For the last page, an empty list of provider\r\n     *     configuration and no page token are returned.\r\n     */\r\n    listOAuthIdpConfigs(maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE, pageToken) {\r\n        const request = {\r\n            pageSize: maxResults,\r\n        };\r\n        // Add next page token if provided.\r\n        if (typeof pageToken !== 'undefined') {\r\n            request.pageToken = pageToken;\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request)\r\n            .then((response) => {\r\n            if (!response.oauthIdpConfigs) {\r\n                response.oauthIdpConfigs = [];\r\n                delete response.nextPageToken;\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n    /**\r\n     * Deletes an OIDC configuration identified by a providerId.\r\n     *\r\n     * @param providerId - The identifier of the OIDC configuration to delete.\r\n     * @returns A promise that resolves when the OIDC provider is deleted.\r\n     */\r\n    deleteOAuthIdpConfig(providerId) {\r\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, { providerId })\r\n            .then(() => {\r\n            // Return nothing.\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new OIDC provider configuration with the properties provided.\r\n     *\r\n     * @param options - The properties to set on the new OIDC provider configuration to be created.\r\n     * @returns A promise that resolves with the newly created OIDC\r\n     *     configuration.\r\n     */\r\n    createOAuthIdpConfig(options) {\r\n        // Construct backend request.\r\n        let request;\r\n        try {\r\n            request = auth_config_1.OIDCConfig.buildServerRequest(options) || {};\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n        const providerId = options.providerId;\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request, { providerId })\r\n            .then((response) => {\r\n            if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration');\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n    /**\r\n     * Updates an existing OIDC provider configuration with the properties provided.\r\n     *\r\n     * @param providerId - The provider identifier of the OIDC configuration to update.\r\n     * @param options - The properties to update on the existing configuration.\r\n     * @returns A promise that resolves with the modified provider\r\n     *     configuration.\r\n     */\r\n    updateOAuthIdpConfig(providerId, options) {\r\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        // Construct backend request.\r\n        let request;\r\n        try {\r\n            request = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n        const updateMask = utils.generateUpdateMask(request);\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request, { providerId, updateMask: updateMask.join(',') })\r\n            .then((response) => {\r\n            if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration');\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n    /**\r\n     * Looks up an SAML provider configuration by provider ID.\r\n     *\r\n     * @param providerId - The provider identifier of the configuration to lookup.\r\n     * @returns A promise that resolves with the provider configuration information.\r\n     */\r\n    getInboundSamlConfig(providerId) {\r\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, { providerId });\r\n    }\r\n    /**\r\n     * Lists the SAML configurations (single batch only) with a size of maxResults and starting from\r\n     * the offset as specified by pageToken.\r\n     *\r\n     * @param maxResults - The page size, 100 if undefined. This is also the maximum\r\n     *     allowed limit.\r\n     * @param pageToken - The next page token. If not specified, returns SAML configurations starting\r\n     *     without any offset. Configurations are returned in the order they were created from oldest to\r\n     *     newest, relative to the page token offset.\r\n     * @returns A promise that resolves with the current batch of downloaded\r\n     *     SAML configurations and the next page token if available. For the last page, an empty list of provider\r\n     *     configuration and no page token are returned.\r\n     */\r\n    listInboundSamlConfigs(maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE, pageToken) {\r\n        const request = {\r\n            pageSize: maxResults,\r\n        };\r\n        // Add next page token if provided.\r\n        if (typeof pageToken !== 'undefined') {\r\n            request.pageToken = pageToken;\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request)\r\n            .then((response) => {\r\n            if (!response.inboundSamlConfigs) {\r\n                response.inboundSamlConfigs = [];\r\n                delete response.nextPageToken;\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n    /**\r\n     * Deletes a SAML configuration identified by a providerId.\r\n     *\r\n     * @param providerId - The identifier of the SAML configuration to delete.\r\n     * @returns A promise that resolves when the SAML provider is deleted.\r\n     */\r\n    deleteInboundSamlConfig(providerId) {\r\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, { providerId })\r\n            .then(() => {\r\n            // Return nothing.\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new SAML provider configuration with the properties provided.\r\n     *\r\n     * @param options - The properties to set on the new SAML provider configuration to be created.\r\n     * @returns A promise that resolves with the newly created SAML\r\n     *     configuration.\r\n     */\r\n    createInboundSamlConfig(options) {\r\n        // Construct backend request.\r\n        let request;\r\n        try {\r\n            request = auth_config_1.SAMLConfig.buildServerRequest(options) || {};\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n        const providerId = options.providerId;\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request, { providerId })\r\n            .then((response) => {\r\n            if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration');\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n    /**\r\n     * Updates an existing SAML provider configuration with the properties provided.\r\n     *\r\n     * @param providerId - The provider identifier of the SAML configuration to update.\r\n     * @param options - The properties to update on the existing configuration.\r\n     * @returns A promise that resolves with the modified provider\r\n     *     configuration.\r\n     */\r\n    updateInboundSamlConfig(providerId, options) {\r\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        // Construct backend request.\r\n        let request;\r\n        try {\r\n            request = auth_config_1.SAMLConfig.buildServerRequest(options, true) || {};\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n        const updateMask = utils.generateUpdateMask(request);\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request, { providerId, updateMask: updateMask.join(',') })\r\n            .then((response) => {\r\n            if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML provider configuration');\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n    /**\r\n     * Invokes the request handler based on the API settings object passed.\r\n     *\r\n     * @param urlBuilder - The URL builder for Auth endpoints.\r\n     * @param apiSettings - The API endpoint settings to apply to request and response.\r\n     * @param requestData - The request data.\r\n     * @param additionalResourceParams - Additional resource related params if needed.\r\n     * @returns A promise that resolves with the response.\r\n     */\r\n    invokeRequestHandler(urlBuilder, apiSettings, requestData, additionalResourceParams) {\r\n        return urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams)\r\n            .then((url) => {\r\n            // Validate request.\r\n            if (requestData) {\r\n                const requestValidator = apiSettings.getRequestValidator();\r\n                requestValidator(requestData);\r\n            }\r\n            // Process request.\r\n            const req = {\r\n                method: apiSettings.getHttpMethod(),\r\n                url,\r\n                headers: FIREBASE_AUTH_HEADERS,\r\n                data: requestData,\r\n                timeout: FIREBASE_AUTH_TIMEOUT,\r\n            };\r\n            return this.httpClient.send(req);\r\n        })\r\n            .then((response) => {\r\n            // Validate response.\r\n            const responseValidator = apiSettings.getResponseValidator();\r\n            responseValidator(response.data);\r\n            // Return entire response.\r\n            return response.data;\r\n        })\r\n            .catch((err) => {\r\n            if (err instanceof api_request_1.RequestResponseError) {\r\n                const error = err.response.data;\r\n                const errorCode = AbstractAuthRequestHandler.getErrorCode(error);\r\n                if (!errorCode) {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + error + '. Additionally, an ' +\r\n                        'internal error occurred while attempting to extract the ' +\r\n                        'errorcode from the error.');\r\n                }\r\n                throw error_1.FirebaseAuthError.fromServerError(errorCode, /* message */ undefined, error);\r\n            }\r\n            throw err;\r\n        });\r\n    }\r\n    /**\r\n     * @returns The current Auth user management resource URL builder.\r\n     */\r\n    getAuthUrlBuilder() {\r\n        if (!this.authUrlBuilder) {\r\n            this.authUrlBuilder = this.newAuthUrlBuilder();\r\n        }\r\n        return this.authUrlBuilder;\r\n    }\r\n    /**\r\n     * @returns The current project config resource URL builder.\r\n     */\r\n    getProjectConfigUrlBuilder() {\r\n        if (!this.projectConfigUrlBuilder) {\r\n            this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();\r\n        }\r\n        return this.projectConfigUrlBuilder;\r\n    }\r\n}\r\nexports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;\r\n/** Instantiates the getConfig endpoint settings. */\r\nconst GET_PROJECT_CONFIG = new api_request_1.ApiSettings('/config', 'GET')\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain at least the config name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get project config');\r\n    }\r\n});\r\n/** Instantiates the updateConfig endpoint settings. */\r\nconst UPDATE_PROJECT_CONFIG = new api_request_1.ApiSettings('/config?updateMask={updateMask}', 'PATCH')\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain at least the config name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update project config');\r\n    }\r\n});\r\n/** Instantiates the getTenant endpoint settings. */\r\nconst GET_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'GET')\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain at least the tenant name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get tenant');\r\n    }\r\n});\r\n/** Instantiates the deleteTenant endpoint settings. */\r\nconst DELETE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'DELETE');\r\n/** Instantiates the updateTenant endpoint settings. */\r\nconst UPDATE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}?updateMask={updateMask}', 'PATCH')\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain at least the tenant name.\r\n    if (!validator.isNonEmptyString(response.name) ||\r\n        !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update tenant');\r\n    }\r\n});\r\n/** Instantiates the listTenants endpoint settings. */\r\nconst LIST_TENANTS = new api_request_1.ApiSettings('/tenants', 'GET')\r\n    // Set request validator.\r\n    .setRequestValidator((request) => {\r\n    // Validate next page token.\r\n    if (typeof request.pageToken !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.pageToken)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\r\n    }\r\n    // Validate max results.\r\n    if (!validator.isNumber(request.pageSize) ||\r\n        request.pageSize <= 0 ||\r\n        request.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive non-zero number that does not exceed ' +\r\n            `the allowed ${MAX_LIST_TENANT_PAGE_SIZE}.`);\r\n    }\r\n});\r\n/** Instantiates the createTenant endpoint settings. */\r\nconst CREATE_TENANT = new api_request_1.ApiSettings('/tenants', 'POST')\r\n    // Set response validator.\r\n    .setResponseValidator((response) => {\r\n    // Response should always contain at least the tenant name.\r\n    if (!validator.isNonEmptyString(response.name) ||\r\n        !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new tenant');\r\n    }\r\n});\r\n/**\r\n * Utility for sending requests to Auth server that are Auth instance related. This includes user, tenant,\r\n * and project config management related APIs. This extends the BaseFirebaseAuthRequestHandler class and defines\r\n * additional tenant management related APIs.\r\n */\r\nclass AuthRequestHandler extends AbstractAuthRequestHandler {\r\n    /**\r\n     * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.\r\n     *\r\n     * @param app - The app used to fetch access tokens to sign API requests.\r\n     * @constructor\r\n     */\r\n    constructor(app) {\r\n        super(app);\r\n        this.authResourceUrlBuilder = new AuthResourceUrlBuilder(app, 'v2');\r\n    }\r\n    /**\r\n     * @returns A new Auth user management resource URL builder instance.\r\n     */\r\n    newAuthUrlBuilder() {\r\n        return new AuthResourceUrlBuilder(this.app, 'v1');\r\n    }\r\n    /**\r\n     * @returns A new project config resource URL builder instance.\r\n     */\r\n    newProjectConfigUrlBuilder() {\r\n        return new AuthResourceUrlBuilder(this.app, 'v2');\r\n    }\r\n    /**\r\n     * Get the current project's config\r\n     * @returns A promise that resolves with the project config information.\r\n     */\r\n    getProjectConfig() {\r\n        return this.invokeRequestHandler(this.authResourceUrlBuilder, GET_PROJECT_CONFIG, {}, {})\r\n            .then((response) => {\r\n            return response;\r\n        });\r\n    }\r\n    /**\r\n     * Update the current project's config.\r\n     * @returns A promise that resolves with the project config information.\r\n     */\r\n    updateProjectConfig(options) {\r\n        try {\r\n            const request = project_config_1.ProjectConfig.buildServerRequest(options);\r\n            const updateMask = utils.generateUpdateMask(request);\r\n            return this.invokeRequestHandler(this.authResourceUrlBuilder, UPDATE_PROJECT_CONFIG, request, { updateMask: updateMask.join(',') })\r\n                .then((response) => {\r\n                return response;\r\n            });\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    /**\r\n     * Looks up a tenant by tenant ID.\r\n     *\r\n     * @param tenantId - The tenant identifier of the tenant to lookup.\r\n     * @returns A promise that resolves with the tenant information.\r\n     */\r\n    getTenant(tenantId) {\r\n        if (!validator.isNonEmptyString(tenantId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.authResourceUrlBuilder, GET_TENANT, {}, { tenantId })\r\n            .then((response) => {\r\n            return response;\r\n        });\r\n    }\r\n    /**\r\n     * Exports the tenants (single batch only) with a size of maxResults and starting from\r\n     * the offset as specified by pageToken.\r\n     *\r\n     * @param maxResults - The page size, 1000 if undefined. This is also the maximum\r\n     *     allowed limit.\r\n     * @param pageToken - The next page token. If not specified, returns tenants starting\r\n     *     without any offset. Tenants are returned in the order they were created from oldest to\r\n     *     newest, relative to the page token offset.\r\n     * @returns A promise that resolves with the current batch of downloaded\r\n     *     tenants and the next page token if available. For the last page, an empty list of tenants\r\n     *     and no page token are returned.\r\n     */\r\n    listTenants(maxResults = MAX_LIST_TENANT_PAGE_SIZE, pageToken) {\r\n        const request = {\r\n            pageSize: maxResults,\r\n            pageToken,\r\n        };\r\n        // Remove next page token if not provided.\r\n        if (typeof request.pageToken === 'undefined') {\r\n            delete request.pageToken;\r\n        }\r\n        return this.invokeRequestHandler(this.authResourceUrlBuilder, LIST_TENANTS, request)\r\n            .then((response) => {\r\n            if (!response.tenants) {\r\n                response.tenants = [];\r\n                delete response.nextPageToken;\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n    /**\r\n     * Deletes a tenant identified by a tenantId.\r\n     *\r\n     * @param tenantId - The identifier of the tenant to delete.\r\n     * @returns A promise that resolves when the tenant is deleted.\r\n     */\r\n    deleteTenant(tenantId) {\r\n        if (!validator.isNonEmptyString(tenantId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.authResourceUrlBuilder, DELETE_TENANT, undefined, { tenantId })\r\n            .then(() => {\r\n            // Return nothing.\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new tenant with the properties provided.\r\n     *\r\n     * @param tenantOptions - The properties to set on the new tenant to be created.\r\n     * @returns A promise that resolves with the newly created tenant object.\r\n     */\r\n    createTenant(tenantOptions) {\r\n        try {\r\n            // Construct backend request.\r\n            const request = tenant_1.Tenant.buildServerRequest(tenantOptions, true);\r\n            return this.invokeRequestHandler(this.authResourceUrlBuilder, CREATE_TENANT, request)\r\n                .then((response) => {\r\n                return response;\r\n            });\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    /**\r\n     * Updates an existing tenant with the properties provided.\r\n     *\r\n     * @param tenantId - The tenant identifier of the tenant to update.\r\n     * @param tenantOptions - The properties to update on the existing tenant.\r\n     * @returns A promise that resolves with the modified tenant object.\r\n     */\r\n    updateTenant(tenantId, tenantOptions) {\r\n        if (!validator.isNonEmptyString(tenantId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\r\n        }\r\n        try {\r\n            // Construct backend request.\r\n            const request = tenant_1.Tenant.buildServerRequest(tenantOptions, false);\r\n            // Do not traverse deep into testPhoneNumbers. The entire content should be replaced\r\n            // and not just specific phone numbers.\r\n            const updateMask = utils.generateUpdateMask(request, ['testPhoneNumbers']);\r\n            return this.invokeRequestHandler(this.authResourceUrlBuilder, UPDATE_TENANT, request, { tenantId, updateMask: updateMask.join(',') })\r\n                .then((response) => {\r\n                return response;\r\n            });\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n}\r\nexports.AuthRequestHandler = AuthRequestHandler;\r\n/**\r\n * Utility for sending requests to Auth server that are tenant Auth instance related. This includes user\r\n * management related APIs for specified tenants.\r\n * This extends the BaseFirebaseAuthRequestHandler class.\r\n */\r\nclass TenantAwareAuthRequestHandler extends AbstractAuthRequestHandler {\r\n    /**\r\n     * The FirebaseTenantRequestHandler constructor used to initialize an instance using a\r\n     * FirebaseApp and a tenant ID.\r\n     *\r\n     * @param app - The app used to fetch access tokens to sign API requests.\r\n     * @param tenantId - The request handler's tenant ID.\r\n     * @constructor\r\n     */\r\n    constructor(app, tenantId) {\r\n        super(app);\r\n        this.tenantId = tenantId;\r\n    }\r\n    /**\r\n     * @returns A new Auth user management resource URL builder instance.\r\n     */\r\n    newAuthUrlBuilder() {\r\n        return new TenantAwareAuthResourceUrlBuilder(this.app, 'v1', this.tenantId);\r\n    }\r\n    /**\r\n     * @returns A new project config resource URL builder instance.\r\n     */\r\n    newProjectConfigUrlBuilder() {\r\n        return new TenantAwareAuthResourceUrlBuilder(this.app, 'v2', this.tenantId);\r\n    }\r\n    /**\r\n     * Imports the list of users provided to Firebase Auth. This is useful when\r\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\r\n     * At most, 1000 users are allowed to be imported one at a time.\r\n     * When importing a list of password users, UserImportOptions are required to be specified.\r\n     *\r\n     * Overrides the superclass methods by adding an additional check to match tenant IDs of\r\n     * imported user records if present.\r\n     *\r\n     * @param users - The list of user records to import to Firebase Auth.\r\n     * @param options - The user import options, required when the users provided\r\n     *     include password credentials.\r\n     * @returns A promise that resolves when the operation completes\r\n     *     with the result of the import. This includes the number of successful imports, the number\r\n     *     of failed uploads and their corresponding errors.\r\n     */\r\n    uploadAccount(users, options) {\r\n        // Add additional check to match tenant ID of imported user records.\r\n        users.forEach((user, index) => {\r\n            if (validator.isNonEmptyString(user.tenantId) &&\r\n                user.tenantId !== this.tenantId) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, `UserRecord of index \"${index}\" has mismatching tenant ID \"${user.tenantId}\"`);\r\n            }\r\n        });\r\n        return super.uploadAccount(users, options);\r\n    }\r\n}\r\nexports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;\r\nfunction emulatorHost() {\r\n    return process.env.FIREBASE_AUTH_EMULATOR_HOST;\r\n}\r\n/**\r\n * When true the SDK should communicate with the Auth Emulator for all API\r\n * calls and also produce unsigned tokens.\r\n */\r\nfunction useEmulator() {\r\n    return !!emulatorHost();\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}