{"ast":null,"code":"\"use strict\";\n\n/*\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *       http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryPartition = void 0;\nconst field_order_1 = require(\"./reference/field-order\");\nconst query_1 = require(\"./reference/query\");\nconst query_options_1 = require(\"./reference/query-options\");\nconst path_1 = require(\"./path\");\nconst serializer_1 = require(\"./serializer\");\n/**\r\n * A split point that can be used in a query as a starting and/or end point for\r\n * the query results. The cursors returned by {@link #startAt} and {@link\r\n * #endBefore} can only be used in a query that matches the constraint of query\r\n * that produced this partition.\r\n *\r\n * @class QueryPartition\r\n */\nclass QueryPartition {\n  /** @private */\n  constructor(_firestore, _collectionId, _converter, _startAt, _endBefore) {\n    this._firestore = _firestore;\n    this._collectionId = _collectionId;\n    this._converter = _converter;\n    this._startAt = _startAt;\n    this._endBefore = _endBefore;\n    this._serializer = new serializer_1.Serializer(_firestore);\n  }\n  /**\r\n   * The cursor that defines the first result for this partition or `undefined`\r\n   * if this is the first partition. The cursor value must be\r\n   * destructured when passed to `startAt()` (for example with\r\n   * `query.startAt(...queryPartition.startAt)`).\r\n   *\r\n   * @example\r\n   * ```\r\n   * const query = firestore.collectionGroup('collectionId');\r\n   * for await (const partition of query.getPartitions(42)) {\r\n   *   let partitionedQuery = query.orderBy(FieldPath.documentId());\r\n   *   if (partition.startAt) {\r\n   *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\r\n   *   }\r\n   *   if (partition.endBefore) {\r\n   *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\r\n   *   }\r\n   *   const querySnapshot = await partitionedQuery.get();\r\n   *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n   * }\r\n   *\r\n   * ```\r\n   * @type {Array<*>}\r\n   * @return {Array<*>} A cursor value that can be used with {@link\r\n   * Query#startAt} or `undefined` if this is the first partition.\r\n   */\n  get startAt() {\n    if (this._startAt && !this._memoizedStartAt) {\n      this._memoizedStartAt = this._startAt.map(v => this._serializer.decodeValue(v));\n    }\n    return this._memoizedStartAt;\n  }\n  /**\r\n   * The cursor that defines the first result after this partition or\r\n   * `undefined` if this is the last partition.  The cursor value must be\r\n   * destructured when passed to `endBefore()` (for example with\r\n   * `query.endBefore(...queryPartition.endBefore)`).\r\n   *\r\n   * @example\r\n   * ```\r\n   * const query = firestore.collectionGroup('collectionId');\r\n   * for await (const partition of query.getPartitions(42)) {\r\n   *   let partitionedQuery = query.orderBy(FieldPath.documentId());\r\n   *   if (partition.startAt) {\r\n   *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\r\n   *   }\r\n   *   if (partition.endBefore) {\r\n   *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\r\n   *   }\r\n   *   const querySnapshot = await partitionedQuery.get();\r\n   *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n   * }\r\n   *\r\n   * ```\r\n   * @type {Array<*>}\r\n   * @return {Array<*>} A cursor value that can be used with {@link\r\n   * Query#endBefore} or `undefined` if this is the last partition.\r\n   */\n  get endBefore() {\n    if (this._endBefore && !this._memoizedEndBefore) {\n      this._memoizedEndBefore = this._endBefore.map(v => this._serializer.decodeValue(v));\n    }\n    return this._memoizedEndBefore;\n  }\n  /**\r\n   * Returns a query that only encapsulates the documents for this partition.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const query = firestore.collectionGroup('collectionId');\r\n   * for await (const partition of query.getPartitions(42)) {\r\n   *   const partitionedQuery = partition.toQuery();\r\n   *   const querySnapshot = await partitionedQuery.get();\r\n   *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n   * }\r\n   *\r\n   * ```\r\n   * @return {Query<T>} A query partitioned by a {@link Query#startAt} and\r\n   * {@link Query#endBefore} cursor.\r\n   */\n  toQuery() {\n    // Since the api.Value to JavaScript type conversion can be lossy (unless\n    // `useBigInt` is used), we pass the original protobuf representation to the\n    // created query.\n    let queryOptions = query_options_1.QueryOptions.forCollectionGroupQuery(this._collectionId, this._converter);\n    queryOptions = queryOptions.with({\n      fieldOrders: [new field_order_1.FieldOrder(path_1.FieldPath.documentId())]\n    });\n    if (this._startAt !== undefined) {\n      queryOptions = queryOptions.with({\n        startAt: {\n          before: true,\n          values: this._startAt\n        }\n      });\n    }\n    if (this._endBefore !== undefined) {\n      queryOptions = queryOptions.with({\n        endAt: {\n          before: true,\n          values: this._endBefore\n        }\n      });\n    }\n    return new query_1.Query(this._firestore, queryOptions);\n  }\n}\nexports.QueryPartition = QueryPartition;","map":{"version":3,"names":["Object","defineProperty","exports","value","QueryPartition","field_order_1","require","query_1","query_options_1","path_1","serializer_1","constructor","_firestore","_collectionId","_converter","_startAt","_endBefore","_serializer","Serializer","startAt","_memoizedStartAt","map","v","decodeValue","endBefore","_memoizedEndBefore","toQuery","queryOptions","QueryOptions","forCollectionGroupQuery","with","fieldOrders","FieldOrder","FieldPath","documentId","undefined","before","values","endAt","Query"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@google-cloud/firestore/build/src/query-partition.js"],"sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *       http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.QueryPartition = void 0;\r\nconst field_order_1 = require(\"./reference/field-order\");\r\nconst query_1 = require(\"./reference/query\");\r\nconst query_options_1 = require(\"./reference/query-options\");\r\nconst path_1 = require(\"./path\");\r\nconst serializer_1 = require(\"./serializer\");\r\n/**\r\n * A split point that can be used in a query as a starting and/or end point for\r\n * the query results. The cursors returned by {@link #startAt} and {@link\r\n * #endBefore} can only be used in a query that matches the constraint of query\r\n * that produced this partition.\r\n *\r\n * @class QueryPartition\r\n */\r\nclass QueryPartition {\r\n    /** @private */\r\n    constructor(_firestore, _collectionId, _converter, _startAt, _endBefore) {\r\n        this._firestore = _firestore;\r\n        this._collectionId = _collectionId;\r\n        this._converter = _converter;\r\n        this._startAt = _startAt;\r\n        this._endBefore = _endBefore;\r\n        this._serializer = new serializer_1.Serializer(_firestore);\r\n    }\r\n    /**\r\n     * The cursor that defines the first result for this partition or `undefined`\r\n     * if this is the first partition. The cursor value must be\r\n     * destructured when passed to `startAt()` (for example with\r\n     * `query.startAt(...queryPartition.startAt)`).\r\n     *\r\n     * @example\r\n     * ```\r\n     * const query = firestore.collectionGroup('collectionId');\r\n     * for await (const partition of query.getPartitions(42)) {\r\n     *   let partitionedQuery = query.orderBy(FieldPath.documentId());\r\n     *   if (partition.startAt) {\r\n     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\r\n     *   }\r\n     *   if (partition.endBefore) {\r\n     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\r\n     *   }\r\n     *   const querySnapshot = await partitionedQuery.get();\r\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n     * }\r\n     *\r\n     * ```\r\n     * @type {Array<*>}\r\n     * @return {Array<*>} A cursor value that can be used with {@link\r\n     * Query#startAt} or `undefined` if this is the first partition.\r\n     */\r\n    get startAt() {\r\n        if (this._startAt && !this._memoizedStartAt) {\r\n            this._memoizedStartAt = this._startAt.map(v => this._serializer.decodeValue(v));\r\n        }\r\n        return this._memoizedStartAt;\r\n    }\r\n    /**\r\n     * The cursor that defines the first result after this partition or\r\n     * `undefined` if this is the last partition.  The cursor value must be\r\n     * destructured when passed to `endBefore()` (for example with\r\n     * `query.endBefore(...queryPartition.endBefore)`).\r\n     *\r\n     * @example\r\n     * ```\r\n     * const query = firestore.collectionGroup('collectionId');\r\n     * for await (const partition of query.getPartitions(42)) {\r\n     *   let partitionedQuery = query.orderBy(FieldPath.documentId());\r\n     *   if (partition.startAt) {\r\n     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\r\n     *   }\r\n     *   if (partition.endBefore) {\r\n     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\r\n     *   }\r\n     *   const querySnapshot = await partitionedQuery.get();\r\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n     * }\r\n     *\r\n     * ```\r\n     * @type {Array<*>}\r\n     * @return {Array<*>} A cursor value that can be used with {@link\r\n     * Query#endBefore} or `undefined` if this is the last partition.\r\n     */\r\n    get endBefore() {\r\n        if (this._endBefore && !this._memoizedEndBefore) {\r\n            this._memoizedEndBefore = this._endBefore.map(v => this._serializer.decodeValue(v));\r\n        }\r\n        return this._memoizedEndBefore;\r\n    }\r\n    /**\r\n     * Returns a query that only encapsulates the documents for this partition.\r\n     *\r\n     * @example\r\n     * ```\r\n     * const query = firestore.collectionGroup('collectionId');\r\n     * for await (const partition of query.getPartitions(42)) {\r\n     *   const partitionedQuery = partition.toQuery();\r\n     *   const querySnapshot = await partitionedQuery.get();\r\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n     * }\r\n     *\r\n     * ```\r\n     * @return {Query<T>} A query partitioned by a {@link Query#startAt} and\r\n     * {@link Query#endBefore} cursor.\r\n     */\r\n    toQuery() {\r\n        // Since the api.Value to JavaScript type conversion can be lossy (unless\r\n        // `useBigInt` is used), we pass the original protobuf representation to the\r\n        // created query.\r\n        let queryOptions = query_options_1.QueryOptions.forCollectionGroupQuery(this._collectionId, this._converter);\r\n        queryOptions = queryOptions.with({\r\n            fieldOrders: [new field_order_1.FieldOrder(path_1.FieldPath.documentId())],\r\n        });\r\n        if (this._startAt !== undefined) {\r\n            queryOptions = queryOptions.with({\r\n                startAt: { before: true, values: this._startAt },\r\n            });\r\n        }\r\n        if (this._endBefore !== undefined) {\r\n            queryOptions = queryOptions.with({\r\n                endAt: { before: true, values: this._endBefore },\r\n            });\r\n        }\r\n        return new query_1.Query(this._firestore, queryOptions);\r\n    }\r\n}\r\nexports.QueryPartition = QueryPartition;\r\n//# sourceMappingURL=query-partition.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}