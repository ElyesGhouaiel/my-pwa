{"ast":null,"code":"import crypto, { isCryptoKey } from './webcrypto.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { encodeBase64, decodeBase64 } from './base64url.js';\nimport formatPEM from '../lib/format_pem.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { types } from './is_key_like.js';\nconst genericExport = async (keyType, keyFormat, key) => {\n  if (!isCryptoKey(key)) {\n    throw new TypeError(invalidKeyInput(key, ...types));\n  }\n  if (!key.extractable) {\n    throw new TypeError('CryptoKey is not extractable');\n  }\n  if (key.type !== keyType) {\n    throw new TypeError(`key is not a ${keyType} key`);\n  }\n  return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nexport const toSPKI = key => {\n  return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = key => {\n  return genericExport('private', 'pkcs8', key);\n};\nconst findOid = (keyData, oid, from = 0) => {\n  if (from === 0) {\n    oid.unshift(oid.length);\n    oid.unshift(0x06);\n  }\n  let i = keyData.indexOf(oid[0], from);\n  if (i === -1) return false;\n  const sub = keyData.subarray(i, i + oid.length);\n  if (sub.length !== oid.length) return false;\n  return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);\n};\nconst getNamedCurve = keyData => {\n  switch (true) {\n    case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):\n      return 'P-256';\n    case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):\n      return 'P-384';\n    case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):\n      return 'P-521';\n    case findOid(keyData, [0x2b, 0x65, 0x6e]):\n      return 'X25519';\n    case findOid(keyData, [0x2b, 0x65, 0x6f]):\n      return 'X448';\n    case findOid(keyData, [0x2b, 0x65, 0x70]):\n      return 'Ed25519';\n    case findOid(keyData, [0x2b, 0x65, 0x71]):\n      return 'Ed448';\n    default:\n      throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');\n  }\n};\nconst genericImport = async (replace, keyFormat, pem, alg, options) => {\n  var _a;\n  let algorithm;\n  let keyUsages;\n  const keyData = new Uint8Array(atob(pem.replace(replace, '')).split('').map(c => c.charCodeAt(0)));\n  const isPublic = keyFormat === 'spki';\n  switch (alg) {\n    case 'PS256':\n    case 'PS384':\n    case 'PS512':\n      algorithm = {\n        name: 'RSA-PSS',\n        hash: `SHA-${alg.slice(-3)}`\n      };\n      keyUsages = isPublic ? ['verify'] : ['sign'];\n      break;\n    case 'RS256':\n    case 'RS384':\n    case 'RS512':\n      algorithm = {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: `SHA-${alg.slice(-3)}`\n      };\n      keyUsages = isPublic ? ['verify'] : ['sign'];\n      break;\n    case 'RSA-OAEP':\n    case 'RSA-OAEP-256':\n    case 'RSA-OAEP-384':\n    case 'RSA-OAEP-512':\n      algorithm = {\n        name: 'RSA-OAEP',\n        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`\n      };\n      keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n      break;\n    case 'ES256':\n      algorithm = {\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      };\n      keyUsages = isPublic ? ['verify'] : ['sign'];\n      break;\n    case 'ES384':\n      algorithm = {\n        name: 'ECDSA',\n        namedCurve: 'P-384'\n      };\n      keyUsages = isPublic ? ['verify'] : ['sign'];\n      break;\n    case 'ES512':\n      algorithm = {\n        name: 'ECDSA',\n        namedCurve: 'P-521'\n      };\n      keyUsages = isPublic ? ['verify'] : ['sign'];\n      break;\n    case 'ECDH-ES':\n    case 'ECDH-ES+A128KW':\n    case 'ECDH-ES+A192KW':\n    case 'ECDH-ES+A256KW':\n      {\n        const namedCurve = getNamedCurve(keyData);\n        algorithm = namedCurve.startsWith('P-') ? {\n          name: 'ECDH',\n          namedCurve\n        } : {\n          name: namedCurve\n        };\n        keyUsages = isPublic ? [] : ['deriveBits'];\n        break;\n      }\n    case 'EdDSA':\n      algorithm = {\n        name: getNamedCurve(keyData)\n      };\n      keyUsages = isPublic ? ['verify'] : ['sign'];\n      break;\n    default:\n      throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n  }\n  return crypto.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);\n};\nexport const fromPKCS8 = (pem, alg, options) => {\n  return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, 'pkcs8', pem, alg, options);\n};\nexport const fromSPKI = (pem, alg, options) => {\n  return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, 'spki', pem, alg, options);\n};\nfunction getElement(seq) {\n  let result = [];\n  let next = 0;\n  while (next < seq.length) {\n    let nextPart = parseElement(seq.subarray(next));\n    result.push(nextPart);\n    next += nextPart.byteLength;\n  }\n  return result;\n}\nfunction parseElement(bytes) {\n  let position = 0;\n  let tag = bytes[0] & 0x1f;\n  position++;\n  if (tag === 0x1f) {\n    tag = 0;\n    while (bytes[position] >= 0x80) {\n      tag = tag * 128 + bytes[position] - 0x80;\n      position++;\n    }\n    tag = tag * 128 + bytes[position] - 0x80;\n    position++;\n  }\n  let length = 0;\n  if (bytes[position] < 0x80) {\n    length = bytes[position];\n    position++;\n  } else if (length === 0x80) {\n    length = 0;\n    while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n      if (length > bytes.byteLength) {\n        throw new TypeError('invalid indefinite form length');\n      }\n      length++;\n    }\n    const byteLength = position + length + 2;\n    return {\n      byteLength,\n      contents: bytes.subarray(position, position + length),\n      raw: bytes.subarray(0, byteLength)\n    };\n  } else {\n    let numberOfDigits = bytes[position] & 0x7f;\n    position++;\n    length = 0;\n    for (let i = 0; i < numberOfDigits; i++) {\n      length = length * 256 + bytes[position];\n      position++;\n    }\n  }\n  const byteLength = position + length;\n  return {\n    byteLength,\n    contents: bytes.subarray(position, byteLength),\n    raw: bytes.subarray(0, byteLength)\n  };\n}\nfunction spkiFromX509(buf) {\n  const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n  return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\nfunction getSPKI(x509) {\n  const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n  const raw = decodeBase64(pem);\n  return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');\n}\nexport const fromX509 = (pem, alg, options) => {\n  let spki;\n  try {\n    spki = getSPKI(pem);\n  } catch (cause) {\n    throw new TypeError('Failed to parse the X.509 certificate', {\n      cause\n    });\n  }\n  return fromSPKI(spki, alg, options);\n};","map":{"version":3,"names":["crypto","isCryptoKey","invalidKeyInput","encodeBase64","decodeBase64","formatPEM","JOSENotSupported","types","genericExport","keyType","keyFormat","key","TypeError","extractable","type","Uint8Array","subtle","exportKey","toUpperCase","toSPKI","toPKCS8","findOid","keyData","oid","from","unshift","length","i","indexOf","sub","subarray","every","value","index","getNamedCurve","genericImport","replace","pem","alg","options","_a","algorithm","keyUsages","atob","split","map","c","charCodeAt","isPublic","name","hash","slice","parseInt","namedCurve","startsWith","importKey","fromPKCS8","fromSPKI","getElement","seq","result","next","nextPart","parseElement","push","byteLength","bytes","position","tag","contents","raw","numberOfDigits","spkiFromX509","buf","tbsCertificate","getSPKI","x509","fromX509","spki","cause"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/jose/dist/browser/runtime/asn1.js"],"sourcesContent":["import crypto, { isCryptoKey } from './webcrypto.js';\r\nimport invalidKeyInput from '../lib/invalid_key_input.js';\r\nimport { encodeBase64, decodeBase64 } from './base64url.js';\r\nimport formatPEM from '../lib/format_pem.js';\r\nimport { JOSENotSupported } from '../util/errors.js';\r\nimport { types } from './is_key_like.js';\r\nconst genericExport = async (keyType, keyFormat, key) => {\r\n    if (!isCryptoKey(key)) {\r\n        throw new TypeError(invalidKeyInput(key, ...types));\r\n    }\r\n    if (!key.extractable) {\r\n        throw new TypeError('CryptoKey is not extractable');\r\n    }\r\n    if (key.type !== keyType) {\r\n        throw new TypeError(`key is not a ${keyType} key`);\r\n    }\r\n    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\r\n};\r\nexport const toSPKI = (key) => {\r\n    return genericExport('public', 'spki', key);\r\n};\r\nexport const toPKCS8 = (key) => {\r\n    return genericExport('private', 'pkcs8', key);\r\n};\r\nconst findOid = (keyData, oid, from = 0) => {\r\n    if (from === 0) {\r\n        oid.unshift(oid.length);\r\n        oid.unshift(0x06);\r\n    }\r\n    let i = keyData.indexOf(oid[0], from);\r\n    if (i === -1)\r\n        return false;\r\n    const sub = keyData.subarray(i, i + oid.length);\r\n    if (sub.length !== oid.length)\r\n        return false;\r\n    return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);\r\n};\r\nconst getNamedCurve = (keyData) => {\r\n    switch (true) {\r\n        case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):\r\n            return 'P-256';\r\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):\r\n            return 'P-384';\r\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):\r\n            return 'P-521';\r\n        case findOid(keyData, [0x2b, 0x65, 0x6e]):\r\n            return 'X25519';\r\n        case findOid(keyData, [0x2b, 0x65, 0x6f]):\r\n            return 'X448';\r\n        case findOid(keyData, [0x2b, 0x65, 0x70]):\r\n            return 'Ed25519';\r\n        case findOid(keyData, [0x2b, 0x65, 0x71]):\r\n            return 'Ed448';\r\n        default:\r\n            throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');\r\n    }\r\n};\r\nconst genericImport = async (replace, keyFormat, pem, alg, options) => {\r\n    var _a;\r\n    let algorithm;\r\n    let keyUsages;\r\n    const keyData = new Uint8Array(atob(pem.replace(replace, ''))\r\n        .split('')\r\n        .map((c) => c.charCodeAt(0)));\r\n    const isPublic = keyFormat === 'spki';\r\n    switch (alg) {\r\n        case 'PS256':\r\n        case 'PS384':\r\n        case 'PS512':\r\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\r\n            keyUsages = isPublic ? ['verify'] : ['sign'];\r\n            break;\r\n        case 'RS256':\r\n        case 'RS384':\r\n        case 'RS512':\r\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\r\n            keyUsages = isPublic ? ['verify'] : ['sign'];\r\n            break;\r\n        case 'RSA-OAEP':\r\n        case 'RSA-OAEP-256':\r\n        case 'RSA-OAEP-384':\r\n        case 'RSA-OAEP-512':\r\n            algorithm = {\r\n                name: 'RSA-OAEP',\r\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\r\n            };\r\n            keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\r\n            break;\r\n        case 'ES256':\r\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\r\n            keyUsages = isPublic ? ['verify'] : ['sign'];\r\n            break;\r\n        case 'ES384':\r\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\r\n            keyUsages = isPublic ? ['verify'] : ['sign'];\r\n            break;\r\n        case 'ES512':\r\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\r\n            keyUsages = isPublic ? ['verify'] : ['sign'];\r\n            break;\r\n        case 'ECDH-ES':\r\n        case 'ECDH-ES+A128KW':\r\n        case 'ECDH-ES+A192KW':\r\n        case 'ECDH-ES+A256KW': {\r\n            const namedCurve = getNamedCurve(keyData);\r\n            algorithm = namedCurve.startsWith('P-') ? { name: 'ECDH', namedCurve } : { name: namedCurve };\r\n            keyUsages = isPublic ? [] : ['deriveBits'];\r\n            break;\r\n        }\r\n        case 'EdDSA':\r\n            algorithm = { name: getNamedCurve(keyData) };\r\n            keyUsages = isPublic ? ['verify'] : ['sign'];\r\n            break;\r\n        default:\r\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\r\n    }\r\n    return crypto.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);\r\n};\r\nexport const fromPKCS8 = (pem, alg, options) => {\r\n    return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, 'pkcs8', pem, alg, options);\r\n};\r\nexport const fromSPKI = (pem, alg, options) => {\r\n    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, 'spki', pem, alg, options);\r\n};\r\nfunction getElement(seq) {\r\n    let result = [];\r\n    let next = 0;\r\n    while (next < seq.length) {\r\n        let nextPart = parseElement(seq.subarray(next));\r\n        result.push(nextPart);\r\n        next += nextPart.byteLength;\r\n    }\r\n    return result;\r\n}\r\nfunction parseElement(bytes) {\r\n    let position = 0;\r\n    let tag = bytes[0] & 0x1f;\r\n    position++;\r\n    if (tag === 0x1f) {\r\n        tag = 0;\r\n        while (bytes[position] >= 0x80) {\r\n            tag = tag * 128 + bytes[position] - 0x80;\r\n            position++;\r\n        }\r\n        tag = tag * 128 + bytes[position] - 0x80;\r\n        position++;\r\n    }\r\n    let length = 0;\r\n    if (bytes[position] < 0x80) {\r\n        length = bytes[position];\r\n        position++;\r\n    }\r\n    else if (length === 0x80) {\r\n        length = 0;\r\n        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\r\n            if (length > bytes.byteLength) {\r\n                throw new TypeError('invalid indefinite form length');\r\n            }\r\n            length++;\r\n        }\r\n        const byteLength = position + length + 2;\r\n        return {\r\n            byteLength,\r\n            contents: bytes.subarray(position, position + length),\r\n            raw: bytes.subarray(0, byteLength),\r\n        };\r\n    }\r\n    else {\r\n        let numberOfDigits = bytes[position] & 0x7f;\r\n        position++;\r\n        length = 0;\r\n        for (let i = 0; i < numberOfDigits; i++) {\r\n            length = length * 256 + bytes[position];\r\n            position++;\r\n        }\r\n    }\r\n    const byteLength = position + length;\r\n    return {\r\n        byteLength,\r\n        contents: bytes.subarray(position, byteLength),\r\n        raw: bytes.subarray(0, byteLength),\r\n    };\r\n}\r\nfunction spkiFromX509(buf) {\r\n    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\r\n    return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\r\n}\r\nfunction getSPKI(x509) {\r\n    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\r\n    const raw = decodeBase64(pem);\r\n    return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');\r\n}\r\nexport const fromX509 = (pem, alg, options) => {\r\n    let spki;\r\n    try {\r\n        spki = getSPKI(pem);\r\n    }\r\n    catch (cause) {\r\n        throw new TypeError('Failed to parse the X.509 certificate', { cause });\r\n    }\r\n    return fromSPKI(spki, alg, options);\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}