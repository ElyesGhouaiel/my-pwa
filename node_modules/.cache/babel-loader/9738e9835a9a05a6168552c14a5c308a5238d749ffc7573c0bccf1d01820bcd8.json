{"ast":null,"code":"\"use strict\";\n\n/**\r\n * Copyright 2023 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregateField = exports.Aggregate = void 0;\nconst path_1 = require(\"./path\");\nconst assert = require(\"assert\");\n/**\r\n * Concrete implementation of the Aggregate type.\r\n */\nclass Aggregate {\n  constructor(alias, aggregateType, fieldPath) {\n    this.alias = alias;\n    this.aggregateType = aggregateType;\n    this.fieldPath = fieldPath;\n  }\n  /**\r\n   * Converts this object to the proto representation of an Aggregate.\r\n   * @internal\r\n   */\n  toProto() {\n    const proto = {};\n    if (this.aggregateType === 'count') {\n      proto.count = {};\n    } else if (this.aggregateType === 'sum') {\n      assert(this.fieldPath !== undefined, 'Missing field path for sum aggregation.');\n      proto.sum = {\n        field: {\n          fieldPath: path_1.FieldPath.fromArgument(this.fieldPath).formattedName\n        }\n      };\n    } else if (this.aggregateType === 'avg') {\n      assert(this.fieldPath !== undefined, 'Missing field path for average aggregation.');\n      proto.avg = {\n        field: {\n          fieldPath: path_1.FieldPath.fromArgument(this.fieldPath).formattedName\n        }\n      };\n    } else {\n      throw new Error(`Aggregate type ${this.aggregateType} unimplemented.`);\n    }\n    proto.alias = this.alias;\n    return proto;\n  }\n}\nexports.Aggregate = Aggregate;\n/**\r\n * Represents an aggregation that can be performed by Firestore.\r\n */\nclass AggregateField {\n  /**\r\n   * Create a new AggregateField<T>\r\n   * @param aggregateType Specifies the type of aggregation operation to perform.\r\n   * @param field Optionally specifies the field that is aggregated.\r\n   * @internal\r\n   */\n  constructor(aggregateType, field) {\n    this.aggregateType = aggregateType;\n    /** A type string to uniquely identify instances of this class. */\n    this.type = 'AggregateField';\n    this._field = field;\n  }\n  /**\r\n   * Compares this object with the given object for equality.\r\n   *\r\n   * This object is considered \"equal\" to the other object if and only if\r\n   * `other` performs the same kind of aggregation on the same field (if any).\r\n   *\r\n   * @param other The object to compare to this object for equality.\r\n   * @return `true` if this object is \"equal\" to the given object, as\r\n   * defined above, or `false` otherwise.\r\n   */\n  isEqual(other) {\n    return other instanceof AggregateField && this.aggregateType === other.aggregateType && (this._field === undefined && other._field === undefined || this._field !== undefined && other._field !== undefined && path_1.FieldPath.fromArgument(this._field).isEqual(path_1.FieldPath.fromArgument(other._field)));\n  }\n  /**\r\n   * Create an AggregateField object that can be used to compute the count of\r\n   * documents in the result set of a query.\r\n   */\n  static count() {\n    return new AggregateField('count');\n  }\n  /**\r\n   * Create an AggregateField object that can be used to compute the average of\r\n   * a specified field over a range of documents in the result set of a query.\r\n   * @param field Specifies the field to average across the result set.\r\n   */\n  static average(field) {\n    return new AggregateField('avg', field);\n  }\n  /**\r\n   * Create an AggregateField object that can be used to compute the sum of\r\n   * a specified field over a range of documents in the result set of a query.\r\n   * @param field Specifies the field to sum across the result set.\r\n   */\n  static sum(field) {\n    return new AggregateField('sum', field);\n  }\n}\nexports.AggregateField = AggregateField;","map":{"version":3,"names":["Object","defineProperty","exports","value","AggregateField","Aggregate","path_1","require","assert","constructor","alias","aggregateType","fieldPath","toProto","proto","count","undefined","sum","field","FieldPath","fromArgument","formattedName","avg","Error","type","_field","isEqual","other","average"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@google-cloud/firestore/build/src/aggregate.js"],"sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2023 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AggregateField = exports.Aggregate = void 0;\r\nconst path_1 = require(\"./path\");\r\nconst assert = require(\"assert\");\r\n/**\r\n * Concrete implementation of the Aggregate type.\r\n */\r\nclass Aggregate {\r\n    constructor(alias, aggregateType, fieldPath) {\r\n        this.alias = alias;\r\n        this.aggregateType = aggregateType;\r\n        this.fieldPath = fieldPath;\r\n    }\r\n    /**\r\n     * Converts this object to the proto representation of an Aggregate.\r\n     * @internal\r\n     */\r\n    toProto() {\r\n        const proto = {};\r\n        if (this.aggregateType === 'count') {\r\n            proto.count = {};\r\n        }\r\n        else if (this.aggregateType === 'sum') {\r\n            assert(this.fieldPath !== undefined, 'Missing field path for sum aggregation.');\r\n            proto.sum = {\r\n                field: {\r\n                    fieldPath: path_1.FieldPath.fromArgument(this.fieldPath).formattedName,\r\n                },\r\n            };\r\n        }\r\n        else if (this.aggregateType === 'avg') {\r\n            assert(this.fieldPath !== undefined, 'Missing field path for average aggregation.');\r\n            proto.avg = {\r\n                field: {\r\n                    fieldPath: path_1.FieldPath.fromArgument(this.fieldPath).formattedName,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            throw new Error(`Aggregate type ${this.aggregateType} unimplemented.`);\r\n        }\r\n        proto.alias = this.alias;\r\n        return proto;\r\n    }\r\n}\r\nexports.Aggregate = Aggregate;\r\n/**\r\n * Represents an aggregation that can be performed by Firestore.\r\n */\r\nclass AggregateField {\r\n    /**\r\n     * Create a new AggregateField<T>\r\n     * @param aggregateType Specifies the type of aggregation operation to perform.\r\n     * @param field Optionally specifies the field that is aggregated.\r\n     * @internal\r\n     */\r\n    constructor(aggregateType, field) {\r\n        this.aggregateType = aggregateType;\r\n        /** A type string to uniquely identify instances of this class. */\r\n        this.type = 'AggregateField';\r\n        this._field = field;\r\n    }\r\n    /**\r\n     * Compares this object with the given object for equality.\r\n     *\r\n     * This object is considered \"equal\" to the other object if and only if\r\n     * `other` performs the same kind of aggregation on the same field (if any).\r\n     *\r\n     * @param other The object to compare to this object for equality.\r\n     * @return `true` if this object is \"equal\" to the given object, as\r\n     * defined above, or `false` otherwise.\r\n     */\r\n    isEqual(other) {\r\n        return (other instanceof AggregateField &&\r\n            this.aggregateType === other.aggregateType &&\r\n            ((this._field === undefined && other._field === undefined) ||\r\n                (this._field !== undefined &&\r\n                    other._field !== undefined &&\r\n                    path_1.FieldPath.fromArgument(this._field).isEqual(path_1.FieldPath.fromArgument(other._field)))));\r\n    }\r\n    /**\r\n     * Create an AggregateField object that can be used to compute the count of\r\n     * documents in the result set of a query.\r\n     */\r\n    static count() {\r\n        return new AggregateField('count');\r\n    }\r\n    /**\r\n     * Create an AggregateField object that can be used to compute the average of\r\n     * a specified field over a range of documents in the result set of a query.\r\n     * @param field Specifies the field to average across the result set.\r\n     */\r\n    static average(field) {\r\n        return new AggregateField('avg', field);\r\n    }\r\n    /**\r\n     * Create an AggregateField object that can be used to compute the sum of\r\n     * a specified field over a range of documents in the result set of a query.\r\n     * @param field Specifies the field to sum across the result set.\r\n     */\r\n    static sum(field) {\r\n        return new AggregateField('sum', field);\r\n    }\r\n}\r\nexports.AggregateField = AggregateField;\r\n//# sourceMappingURL=aggregate.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}