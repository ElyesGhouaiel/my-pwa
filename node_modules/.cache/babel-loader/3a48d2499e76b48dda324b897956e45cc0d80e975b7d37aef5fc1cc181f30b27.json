{"ast":null,"code":"\"use strict\";\n\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _GoogleAuth_instances, _GoogleAuth_pendingAuthClient, _GoogleAuth_prepareAndCacheClient, _GoogleAuth_determineClient;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GoogleAuth = exports.GoogleAuthExceptionMessages = exports.CLOUD_SDK_CLIENT_ID = void 0;\nconst child_process_1 = require(\"child_process\");\nconst fs = require(\"fs\");\nconst gcpMetadata = require(\"gcp-metadata\");\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst transporters_1 = require(\"../transporters\");\nconst computeclient_1 = require(\"./computeclient\");\nconst idtokenclient_1 = require(\"./idtokenclient\");\nconst envDetect_1 = require(\"./envDetect\");\nconst jwtclient_1 = require(\"./jwtclient\");\nconst refreshclient_1 = require(\"./refreshclient\");\nconst impersonated_1 = require(\"./impersonated\");\nconst externalclient_1 = require(\"./externalclient\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\nconst authclient_1 = require(\"./authclient\");\nconst externalAccountAuthorizedUserClient_1 = require(\"./externalAccountAuthorizedUserClient\");\nconst util_1 = require(\"../util\");\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\nexports.GoogleAuthExceptionMessages = {\n  API_KEY_WITH_CREDENTIALS: 'API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.',\n  NO_PROJECT_ID_FOUND: 'Unable to detect a Project Id in the current environment. \\n' + 'To learn more about authentication and Google APIs, visit: \\n' + 'https://cloud.google.com/docs/authentication/getting-started',\n  NO_CREDENTIALS_FOUND: 'Unable to find credentials in current environment. \\n' + 'To learn more about authentication and Google APIs, visit: \\n' + 'https://cloud.google.com/docs/authentication/getting-started',\n  NO_ADC_FOUND: 'Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.',\n  NO_UNIVERSE_DOMAIN_FOUND: 'Unable to detect a Universe Domain in the current environment.\\n' + 'To learn more about Universe Domain retrieval, visit: \\n' + 'https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys'\n};\nclass GoogleAuth {\n  // Note:  this properly is only public to satisfy unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n  /**\r\n   * Configuration is resolved in the following order of precedence:\r\n   * - {@link GoogleAuthOptions.credentials `credentials`}\r\n   * - {@link GoogleAuthOptions.keyFilename `keyFilename`}\r\n   * - {@link GoogleAuthOptions.keyFile `keyFile`}\r\n   *\r\n   * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the\r\n   * {@link AuthClient `AuthClient`s}.\r\n   *\r\n   * @param opts\r\n   */\n  constructor(opts = {}) {\n    _GoogleAuth_instances.add(this);\n    /**\r\n     * Caches a value indicating whether the auth layer is running on Google\r\n     * Compute Engine.\r\n     * @private\r\n     */\n    this.checkIsGCE = undefined;\n    // To save the contents of the JSON credential file\n    this.jsonContent = null;\n    this.cachedCredential = null;\n    /**\r\n     * A pending {@link AuthClient}. Used for concurrent {@link GoogleAuth.getClient} calls.\r\n     */\n    _GoogleAuth_pendingAuthClient.set(this, null);\n    this.clientOptions = {};\n    this._cachedProjectId = opts.projectId || null;\n    this.cachedCredential = opts.authClient || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.clientOptions = opts.clientOptions || {};\n    this.jsonContent = opts.credentials || null;\n    this.apiKey = opts.apiKey || this.clientOptions.apiKey || null;\n    // Cannot use both API Key + Credentials\n    if (this.apiKey && (this.jsonContent || this.clientOptions.credentials)) {\n      throw new RangeError(exports.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);\n    }\n    if (opts.universeDomain) {\n      this.clientOptions.universeDomain = opts.universeDomain;\n    }\n  }\n  // GAPIC client libraries should always use self-signed JWTs. The following\n  // variables are set on the JWT client in order to indicate the type of library,\n  // and sign the JWT with the correct audience and scopes (if not supplied).\n  setGapicJWTValues(client) {\n    client.defaultServicePath = this.defaultServicePath;\n    client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n    client.defaultScopes = this.defaultScopes;\n  }\n  getProjectId(callback) {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n  /**\r\n   * A temporary method for internal `getProjectId` usages where `null` is\r\n   * acceptable. In a future major release, `getProjectId` should return `null`\r\n   * (as the `Promise<string | null>` base signature describes) and this private\r\n   * method should be removed.\r\n   *\r\n   * @returns Promise that resolves with project id (or `null`)\r\n   */\n  async getProjectIdOptional() {\n    try {\n      return await this.getProjectId();\n    } catch (e) {\n      if (e instanceof Error && e.message === exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\n        return null;\n      } else {\n        throw e;\n      }\n    }\n  }\n  /**\r\n   * A private method for finding and caching a projectId.\r\n   *\r\n   * Supports environments in order of precedence:\r\n   * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\r\n   * - GOOGLE_APPLICATION_CREDENTIALS JSON file\r\n   * - Cloud SDK: `gcloud config config-helper --format json`\r\n   * - GCE project ID from metadata server\r\n   *\r\n   * @returns projectId\r\n   */\n  async findAndCacheProjectId() {\n    let projectId = null;\n    projectId || (projectId = await this.getProductionProjectId());\n    projectId || (projectId = await this.getFileProjectId());\n    projectId || (projectId = await this.getDefaultServiceProjectId());\n    projectId || (projectId = await this.getGCEProjectId());\n    projectId || (projectId = await this.getExternalAccountClientProjectId());\n    if (projectId) {\n      this._cachedProjectId = projectId;\n      return projectId;\n    } else {\n      throw new Error(exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\n    }\n  }\n  async getProjectIdAsync() {\n    if (this._cachedProjectId) {\n      return this._cachedProjectId;\n    }\n    if (!this._findProjectIdPromise) {\n      this._findProjectIdPromise = this.findAndCacheProjectId();\n    }\n    return this._findProjectIdPromise;\n  }\n  /**\r\n   * Retrieves a universe domain from the metadata server via\r\n   * {@link gcpMetadata.universe}.\r\n   *\r\n   * @returns a universe domain\r\n   */\n  async getUniverseDomainFromMetadataServer() {\n    var _a;\n    let universeDomain;\n    try {\n      universeDomain = await gcpMetadata.universe('universe-domain');\n      universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);\n    } catch (e) {\n      if (e && ((_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {\n        universeDomain = authclient_1.DEFAULT_UNIVERSE;\n      } else {\n        throw e;\n      }\n    }\n    return universeDomain;\n  }\n  /**\r\n   * Retrieves, caches, and returns the universe domain in the following order\r\n   * of precedence:\r\n   * - The universe domain in {@link GoogleAuth.clientOptions}\r\n   * - An existing or ADC {@link AuthClient}'s universe domain\r\n   * - {@link gcpMetadata.universe}, if {@link Compute} client\r\n   *\r\n   * @returns The universe domain\r\n   */\n  async getUniverseDomain() {\n    let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get('universe_domain');\n    try {\n      universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = (await this.getClient()).universeDomain;\n    } catch (_a) {\n      // client or ADC is not available\n      universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = authclient_1.DEFAULT_UNIVERSE;\n    }\n    return universeDomain;\n  }\n  /**\r\n   * @returns Any scopes (user-specified or default scopes specified by the\r\n   *   client library) that need to be set on the current Auth client.\r\n   */\n  getAnyScopes() {\n    return this.scopes || this.defaultScopes;\n  }\n  getApplicationDefault(optionsOrCallback = {}, callback) {\n    let options;\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n  async getApplicationDefaultAsync(options = {}) {\n    // If we've already got a cached credential, return it.\n    // This will also preserve one's configured quota project, in case they\n    // set one directly on the credential previously.\n    if (this.cachedCredential) {\n      // cache, while preserving existing quota project preferences\n      return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, this.cachedCredential, null);\n    }\n    let credential;\n    // Check for the existence of a local environment variable pointing to the\n    // location of the credential file. This is typically used in local\n    // developer scenarios.\n    credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n    if (credential) {\n      if (credential instanceof jwtclient_1.JWT) {\n        credential.scopes = this.scopes;\n      } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n        credential.scopes = this.getAnyScopes();\n      }\n      return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, credential);\n    }\n    // Look in the well-known credential file location.\n    credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n    if (credential) {\n      if (credential instanceof jwtclient_1.JWT) {\n        credential.scopes = this.scopes;\n      } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n        credential.scopes = this.getAnyScopes();\n      }\n      return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, credential);\n    }\n    // Determine if we're running on GCE.\n    if (await this._checkIsGCE()) {\n      options.scopes = this.getAnyScopes();\n      return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, new computeclient_1.Compute(options));\n    }\n    throw new Error(exports.GoogleAuthExceptionMessages.NO_ADC_FOUND);\n  }\n  /**\r\n   * Determines whether the auth layer is running on Google Compute Engine.\r\n   * Checks for GCP Residency, then fallback to checking if metadata server\r\n   * is available.\r\n   *\r\n   * @returns A promise that resolves with the boolean.\r\n   * @api private\r\n   */\n  async _checkIsGCE() {\n    if (this.checkIsGCE === undefined) {\n      this.checkIsGCE = gcpMetadata.getGCPResidency() || (await gcpMetadata.isAvailable());\n    }\n    return this.checkIsGCE;\n  }\n  /**\r\n   * Attempts to load default credentials from the environment variable path..\r\n   * @returns Promise that resolves with the OAuth2Client or null.\r\n   * @api private\r\n   */\n  async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n    const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] || process.env['google_application_credentials'];\n    if (!credentialsPath || credentialsPath.length === 0) {\n      return null;\n    }\n    try {\n      return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n    } catch (e) {\n      if (e instanceof Error) {\n        e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n      }\n      throw e;\n    }\n  }\n  /**\r\n   * Attempts to load default credentials from a well-known file location\r\n   * @return Promise that resolves with the OAuth2Client or null.\r\n   * @api private\r\n   */\n  async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n    // First, figure out the location of the file, depending upon the OS type.\n    let location = null;\n    if (this._isWindows()) {\n      // Windows\n      location = process.env['APPDATA'];\n    } else {\n      // Linux or Mac\n      const home = process.env['HOME'];\n      if (home) {\n        location = path.join(home, '.config');\n      }\n    }\n    // If we found the root path, expand it.\n    if (location) {\n      location = path.join(location, 'gcloud', 'application_default_credentials.json');\n      if (!fs.existsSync(location)) {\n        location = null;\n      }\n    }\n    // The file does not exist.\n    if (!location) {\n      return null;\n    }\n    // The file seems to exist. Try to use it.\n    const client = await this._getApplicationCredentialsFromFilePath(location, options);\n    return client;\n  }\n  /**\r\n   * Attempts to load default credentials from a file at the given path..\r\n   * @param filePath The path to the file to read.\r\n   * @returns Promise that resolves with the OAuth2Client\r\n   * @api private\r\n   */\n  async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n    // Make sure the path looks like a string.\n    if (!filePath || filePath.length === 0) {\n      throw new Error('The file path is invalid.');\n    }\n    // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = fs.realpathSync(filePath);\n      if (!fs.lstatSync(filePath).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n      }\n      throw err;\n    }\n    // Now open a read stream on the file, and parse it.\n    const readStream = fs.createReadStream(filePath);\n    return this.fromStream(readStream, options);\n  }\n  /**\r\n   * Create a credentials instance using a given impersonated input options.\r\n   * @param json The impersonated input object.\r\n   * @returns JWT or UserRefresh Client with data\r\n   */\n  fromImpersonatedJSON(json) {\n    var _a, _b, _c, _d;\n    if (!json) {\n      throw new Error('Must pass in a JSON object containing an  impersonated refresh token');\n    }\n    if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n      throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\n    }\n    if (!json.source_credentials) {\n      throw new Error('The incoming JSON object does not contain a source_credentials field');\n    }\n    if (!json.service_account_impersonation_url) {\n      throw new Error('The incoming JSON object does not contain a service_account_impersonation_url field');\n    }\n    const sourceClient = this.fromJSON(json.source_credentials);\n    if (((_a = json.service_account_impersonation_url) === null || _a === void 0 ? void 0 : _a.length) > 256) {\n      /**\r\n       * Prevents DOS attacks.\r\n       * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/85}\r\n       **/\n      throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);\n    }\n    // Extract service account from service_account_impersonation_url\n    const targetPrincipal = (_c = (_b = /(?<target>[^/]+):(generateAccessToken|generateIdToken)$/.exec(json.service_account_impersonation_url)) === null || _b === void 0 ? void 0 : _b.groups) === null || _c === void 0 ? void 0 : _c.target;\n    if (!targetPrincipal) {\n      throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\n    }\n    const targetScopes = (_d = this.getAnyScopes()) !== null && _d !== void 0 ? _d : [];\n    return new impersonated_1.Impersonated({\n      ...json,\n      sourceClient,\n      targetPrincipal,\n      targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes]\n    });\n  }\n  /**\r\n   * Create a credentials instance using the given input options.\r\n   * This client is not cached.\r\n   *\r\n   * @param json The input object.\r\n   * @param options The JWT or UserRefresh options for the client\r\n   * @returns JWT or UserRefresh Client with data\r\n   */\n  fromJSON(json, options = {}) {\n    let client;\n    // user's preferred universe domain\n    const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get('universe_domain');\n    if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\n      client = new refreshclient_1.UserRefreshClient(options);\n      client.fromJSON(json);\n    } else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n      client = this.fromImpersonatedJSON(json);\n    } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n      client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n      client.scopes = this.getAnyScopes();\n    } else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\n      client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\n    } else {\n      options.scopes = this.scopes;\n      client = new jwtclient_1.JWT(options);\n      this.setGapicJWTValues(client);\n      client.fromJSON(json);\n    }\n    if (preferredUniverseDomain) {\n      client.universeDomain = preferredUniverseDomain;\n    }\n    return client;\n  }\n  /**\r\n   * Return a JWT or UserRefreshClient from JavaScript object, caching both the\r\n   * object used to instantiate and the client.\r\n   * @param json The input object.\r\n   * @param options The JWT or UserRefresh options for the client\r\n   * @returns JWT or UserRefresh Client with data\r\n   */\n  _cacheClientFromJSON(json, options) {\n    const client = this.fromJSON(json, options);\n    // cache both raw data used to instantiate client and client itself.\n    this.jsonContent = json;\n    this.cachedCredential = client;\n    return client;\n  }\n  fromStream(inputStream, optionsOrCallback = {}, callback) {\n    let options = {};\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n  fromStreamAsync(inputStream, options) {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error('Must pass in a stream containing the Google auth settings.');\n      }\n      const chunks = [];\n      inputStream.setEncoding('utf8').on('error', reject).on('data', chunk => chunks.push(chunk)).on('end', () => {\n        try {\n          try {\n            const data = JSON.parse(chunks.join(''));\n            const r = this._cacheClientFromJSON(data, options);\n            return resolve(r);\n          } catch (err) {\n            // If we failed parsing this.keyFileName, assume that it\n            // is a PEM or p12 certificate:\n            if (!this.keyFilename) throw err;\n            const client = new jwtclient_1.JWT({\n              ...this.clientOptions,\n              keyFile: this.keyFilename\n            });\n            this.cachedCredential = client;\n            this.setGapicJWTValues(client);\n            return resolve(client);\n          }\n        } catch (err) {\n          return reject(err);\n        }\n      });\n    });\n  }\n  /**\r\n   * Create a credentials instance using the given API key string.\r\n   * The created client is not cached. In order to create and cache it use the {@link GoogleAuth.getClient `getClient`} method after first providing an {@link GoogleAuth.apiKey `apiKey`}.\r\n   *\r\n   * @param apiKey The API key string\r\n   * @param options An optional options object.\r\n   * @returns A JWT loaded from the key\r\n   */\n  fromAPIKey(apiKey, options = {}) {\n    return new jwtclient_1.JWT({\n      ...options,\n      apiKey\n    });\n  }\n  /**\r\n   * Determines whether the current operating system is Windows.\r\n   * @api private\r\n   */\n  _isWindows() {\n    const sys = os.platform();\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\r\n   * Run the Google Cloud SDK command that prints the default project ID\r\n   */\n  async getDefaultServiceProjectId() {\n    return new Promise(resolve => {\n      (0, child_process_1.exec)('gcloud config config-helper --format json', (err, stdout) => {\n        if (!err && stdout) {\n          try {\n            const projectId = JSON.parse(stdout).configuration.properties.core.project;\n            resolve(projectId);\n            return;\n          } catch (e) {\n            // ignore errors\n          }\n        }\n        resolve(null);\n      });\n    });\n  }\n  /**\r\n   * Loads the project id from environment variables.\r\n   * @api private\r\n   */\n  getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'] || process.env['gcloud_project'] || process.env['google_cloud_project'];\n  }\n  /**\r\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\r\n   * @api private\r\n   */\n  async getFileProjectId() {\n    if (this.cachedCredential) {\n      // Try to read the project ID from the cached credentials file\n      return this.cachedCredential.projectId;\n    }\n    // Ensure the projectId is loaded from the keyFile if available.\n    if (this.keyFilename) {\n      const creds = await this.getClient();\n      if (creds && creds.projectId) {\n        return creds.projectId;\n      }\n    }\n    // Try to load a credentials file and read its project ID\n    const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n    if (r) {\n      return r.projectId;\n    } else {\n      return null;\n    }\n  }\n  /**\r\n   * Gets the project ID from external account client if available.\r\n   */\n  async getExternalAccountClientProjectId() {\n    if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n      return null;\n    }\n    const creds = await this.getClient();\n    // Do not suppress the underlying error, as the error could contain helpful\n    // information for debugging and fixing. This is especially true for\n    // external account creds as in order to get the project ID, the following\n    // operations have to succeed:\n    // 1. Valid credentials file should be supplied.\n    // 2. Ability to retrieve access tokens from STS token exchange API.\n    // 3. Ability to exchange for service account impersonated credentials (if\n    //    enabled).\n    // 4. Ability to get project info using the access token from step 2 or 3.\n    // Without surfacing the error, it is harder for developers to determine\n    // which step went wrong.\n    return await creds.getProjectId();\n  }\n  /**\r\n   * Gets the Compute Engine project ID if it can be inferred.\r\n   */\n  async getGCEProjectId() {\n    try {\n      const r = await gcpMetadata.project('project-id');\n      return r;\n    } catch (e) {\n      // Ignore any errors\n      return null;\n    }\n  }\n  getCredentials(callback) {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n  async getCredentialsAsync() {\n    const client = await this.getClient();\n    if (client instanceof impersonated_1.Impersonated) {\n      return {\n        client_email: client.getTargetPrincipal()\n      };\n    }\n    if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\n      const serviceAccountEmail = client.getServiceAccountEmail();\n      if (serviceAccountEmail) {\n        return {\n          client_email: serviceAccountEmail,\n          universe_domain: client.universeDomain\n        };\n      }\n    }\n    if (this.jsonContent) {\n      return {\n        client_email: this.jsonContent.client_email,\n        private_key: this.jsonContent.private_key,\n        universe_domain: this.jsonContent.universe_domain\n      };\n    }\n    if (await this._checkIsGCE()) {\n      const [client_email, universe_domain] = await Promise.all([gcpMetadata.instance('service-accounts/default/email'), this.getUniverseDomain()]);\n      return {\n        client_email,\n        universe_domain\n      };\n    }\n    throw new Error(exports.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);\n  }\n  /**\r\n   * Automatically obtain an {@link AuthClient `AuthClient`} based on the\r\n   * provided configuration. If no options were passed, use Application\r\n   * Default Credentials.\r\n   */\n  async getClient() {\n    if (this.cachedCredential) {\n      return this.cachedCredential;\n    }\n    // Use an existing auth client request, or cache a new one\n    __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, \"f\") || __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_determineClient).call(this), \"f\");\n    try {\n      return await __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, \"f\");\n    } finally {\n      // reset the pending auth client in case it is changed later\n      __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, null, \"f\");\n    }\n  }\n  /**\r\n   * Creates a client which will fetch an ID token for authorization.\r\n   * @param targetAudience the audience for the fetched ID token.\r\n   * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\r\n   */\n  async getIdTokenClient(targetAudience) {\n    const client = await this.getClient();\n    if (!('fetchIdToken' in client)) {\n      throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\n    }\n    return new idtokenclient_1.IdTokenClient({\n      targetAudience,\n      idTokenProvider: client\n    });\n  }\n  /**\r\n   * Automatically obtain application default credentials, and return\r\n   * an access token for making requests.\r\n   */\n  async getAccessToken() {\n    const client = await this.getClient();\n    return (await client.getAccessToken()).token;\n  }\n  /**\r\n   * Obtain the HTTP headers that will provide authorization for a given\r\n   * request.\r\n   */\n  async getRequestHeaders(url) {\n    const client = await this.getClient();\n    return client.getRequestHeaders(url);\n  }\n  /**\r\n   * Obtain credentials for a request, then attach the appropriate headers to\r\n   * the request options.\r\n   * @param opts Axios or Request options on which to attach the headers\r\n   */\n  async authorizeRequest(opts) {\n    opts = opts || {};\n    const url = opts.url || opts.uri;\n    const client = await this.getClient();\n    const headers = await client.getRequestHeaders(url);\n    opts.headers = Object.assign(opts.headers || {}, headers);\n    return opts;\n  }\n  /**\r\n   * Automatically obtain application default credentials, and make an\r\n   * HTTP request using the given options.\r\n   * @param opts Axios request options for the HTTP request.\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async request(opts) {\n    const client = await this.getClient();\n    return client.request(opts);\n  }\n  /**\r\n   * Determine the compute environment in which the code is running.\r\n   */\n  getEnv() {\n    return (0, envDetect_1.getEnv)();\n  }\n  /**\r\n   * Sign the given data with the current private key, or go out\r\n   * to the IAM API to sign it.\r\n   * @param data The data to be signed.\r\n   * @param endpoint A custom endpoint to use.\r\n   *\r\n   * @example\r\n   * ```\r\n   * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');\r\n   * ```\r\n   */\n  async sign(data, endpoint) {\n    const client = await this.getClient();\n    const universe = await this.getUniverseDomain();\n    endpoint = endpoint || `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;\n    if (client instanceof impersonated_1.Impersonated) {\n      const signed = await client.sign(data);\n      return signed.signedBlob;\n    }\n    const crypto = (0, crypto_1.createCrypto)();\n    if (client instanceof jwtclient_1.JWT && client.key) {\n      const sign = await crypto.sign(client.key, data);\n      return sign;\n    }\n    const creds = await this.getCredentials();\n    if (!creds.client_email) {\n      throw new Error('Cannot sign data without `client_email`.');\n    }\n    return this.signBlob(crypto, creds.client_email, data, endpoint);\n  }\n  async signBlob(crypto, emailOrUniqueId, data, endpoint) {\n    const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);\n    const res = await this.request({\n      method: 'POST',\n      url: url.href,\n      data: {\n        payload: crypto.encodeBase64StringUtf8(data)\n      },\n      retry: true,\n      retryConfig: {\n        httpMethodsToRetry: ['POST']\n      }\n    });\n    return res.data.signedBlob;\n  }\n}\nexports.GoogleAuth = GoogleAuth;\n_GoogleAuth_pendingAuthClient = new WeakMap(), _GoogleAuth_instances = new WeakSet(), _GoogleAuth_prepareAndCacheClient = async function _GoogleAuth_prepareAndCacheClient(credential, quotaProjectIdOverride = process.env['GOOGLE_CLOUD_QUOTA_PROJECT'] || null) {\n  const projectId = await this.getProjectIdOptional();\n  if (quotaProjectIdOverride) {\n    credential.quotaProjectId = quotaProjectIdOverride;\n  }\n  this.cachedCredential = credential;\n  return {\n    credential,\n    projectId\n  };\n}, _GoogleAuth_determineClient = async function _GoogleAuth_determineClient() {\n  if (this.jsonContent) {\n    return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n  } else if (this.keyFilename) {\n    const filePath = path.resolve(this.keyFilename);\n    const stream = fs.createReadStream(filePath);\n    return await this.fromStreamAsync(stream, this.clientOptions);\n  } else if (this.apiKey) {\n    const client = await this.fromAPIKey(this.apiKey, this.clientOptions);\n    client.scopes = this.scopes;\n    const {\n      credential\n    } = await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, client);\n    return credential;\n  } else {\n    const {\n      credential\n    } = await this.getApplicationDefaultAsync(this.clientOptions);\n    return credential;\n  }\n};\n/**\r\n * Export DefaultTransporter as a static property of the class.\r\n */\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;","map":{"version":3,"names":["__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","value","get","__classPrivateFieldSet","set","_GoogleAuth_instances","_GoogleAuth_pendingAuthClient","_GoogleAuth_prepareAndCacheClient","_GoogleAuth_determineClient","Object","defineProperty","exports","GoogleAuth","GoogleAuthExceptionMessages","CLOUD_SDK_CLIENT_ID","child_process_1","require","fs","gcpMetadata","os","path","crypto_1","transporters_1","computeclient_1","idtokenclient_1","envDetect_1","jwtclient_1","refreshclient_1","impersonated_1","externalclient_1","baseexternalclient_1","authclient_1","externalAccountAuthorizedUserClient_1","util_1","API_KEY_WITH_CREDENTIALS","NO_PROJECT_ID_FOUND","NO_CREDENTIALS_FOUND","NO_ADC_FOUND","NO_UNIVERSE_DOMAIN_FOUND","isGCE","checkIsGCE","constructor","opts","add","undefined","jsonContent","cachedCredential","clientOptions","_cachedProjectId","projectId","authClient","keyFilename","keyFile","scopes","credentials","apiKey","RangeError","universeDomain","setGapicJWTValues","client","defaultServicePath","useJWTAccessWithScope","defaultScopes","getProjectId","callback","getProjectIdAsync","then","r","getProjectIdOptional","e","Error","message","findAndCacheProjectId","getProductionProjectId","getFileProjectId","getDefaultServiceProjectId","getGCEProjectId","getExternalAccountClientProjectId","_findProjectIdPromise","getUniverseDomainFromMetadataServer","_a","universe","DEFAULT_UNIVERSE","response","status","getUniverseDomain","originalOrCamelOptions","getClient","getAnyScopes","getApplicationDefault","optionsOrCallback","options","getApplicationDefaultAsync","credential","_tryGetApplicationCredentialsFromEnvironmentVariable","JWT","BaseExternalAccountClient","_tryGetApplicationCredentialsFromWellKnownFile","_checkIsGCE","Compute","getGCPResidency","isAvailable","credentialsPath","process","env","length","_getApplicationCredentialsFromFilePath","location","_isWindows","home","join","existsSync","filePath","realpathSync","lstatSync","isFile","err","readStream","createReadStream","fromStream","fromImpersonatedJSON","json","_b","_c","_d","type","IMPERSONATED_ACCOUNT_TYPE","source_credentials","service_account_impersonation_url","sourceClient","fromJSON","targetPrincipal","exec","groups","target","targetScopes","Impersonated","Array","isArray","preferredUniverseDomain","USER_REFRESH_ACCOUNT_TYPE","UserRefreshClient","EXTERNAL_ACCOUNT_TYPE","ExternalAccountClient","EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE","ExternalAccountAuthorizedUserClient","_cacheClientFromJSON","inputStream","fromStreamAsync","Promise","resolve","reject","chunks","setEncoding","on","chunk","push","data","JSON","parse","fromAPIKey","sys","platform","substring","toLowerCase","stdout","configuration","properties","core","project","creds","getCredentials","getCredentialsAsync","client_email","getTargetPrincipal","serviceAccountEmail","getServiceAccountEmail","universe_domain","private_key","all","instance","getIdTokenClient","targetAudience","IdTokenClient","idTokenProvider","getAccessToken","token","getRequestHeaders","url","authorizeRequest","uri","headers","assign","request","getEnv","sign","endpoint","signed","signedBlob","crypto","createCrypto","key","signBlob","emailOrUniqueId","URL","res","method","href","payload","encodeBase64StringUtf8","retry","retryConfig","httpMethodsToRetry","WeakMap","WeakSet","quotaProjectIdOverride","quotaProjectId","stream","DefaultTransporter"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/google-auth-library/build/src/auth/googleauth.js"],"sourcesContent":["\"use strict\";\r\n// Copyright 2019 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar _GoogleAuth_instances, _GoogleAuth_pendingAuthClient, _GoogleAuth_prepareAndCacheClient, _GoogleAuth_determineClient;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GoogleAuth = exports.GoogleAuthExceptionMessages = exports.CLOUD_SDK_CLIENT_ID = void 0;\r\nconst child_process_1 = require(\"child_process\");\r\nconst fs = require(\"fs\");\r\nconst gcpMetadata = require(\"gcp-metadata\");\r\nconst os = require(\"os\");\r\nconst path = require(\"path\");\r\nconst crypto_1 = require(\"../crypto/crypto\");\r\nconst transporters_1 = require(\"../transporters\");\r\nconst computeclient_1 = require(\"./computeclient\");\r\nconst idtokenclient_1 = require(\"./idtokenclient\");\r\nconst envDetect_1 = require(\"./envDetect\");\r\nconst jwtclient_1 = require(\"./jwtclient\");\r\nconst refreshclient_1 = require(\"./refreshclient\");\r\nconst impersonated_1 = require(\"./impersonated\");\r\nconst externalclient_1 = require(\"./externalclient\");\r\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\r\nconst authclient_1 = require(\"./authclient\");\r\nconst externalAccountAuthorizedUserClient_1 = require(\"./externalAccountAuthorizedUserClient\");\r\nconst util_1 = require(\"../util\");\r\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\r\nexports.GoogleAuthExceptionMessages = {\r\n    API_KEY_WITH_CREDENTIALS: 'API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.',\r\n    NO_PROJECT_ID_FOUND: 'Unable to detect a Project Id in the current environment. \\n' +\r\n        'To learn more about authentication and Google APIs, visit: \\n' +\r\n        'https://cloud.google.com/docs/authentication/getting-started',\r\n    NO_CREDENTIALS_FOUND: 'Unable to find credentials in current environment. \\n' +\r\n        'To learn more about authentication and Google APIs, visit: \\n' +\r\n        'https://cloud.google.com/docs/authentication/getting-started',\r\n    NO_ADC_FOUND: 'Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.',\r\n    NO_UNIVERSE_DOMAIN_FOUND: 'Unable to detect a Universe Domain in the current environment.\\n' +\r\n        'To learn more about Universe Domain retrieval, visit: \\n' +\r\n        'https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys',\r\n};\r\nclass GoogleAuth {\r\n    // Note:  this properly is only public to satisfy unit tests.\r\n    // https://github.com/Microsoft/TypeScript/issues/5228\r\n    get isGCE() {\r\n        return this.checkIsGCE;\r\n    }\r\n    /**\r\n     * Configuration is resolved in the following order of precedence:\r\n     * - {@link GoogleAuthOptions.credentials `credentials`}\r\n     * - {@link GoogleAuthOptions.keyFilename `keyFilename`}\r\n     * - {@link GoogleAuthOptions.keyFile `keyFile`}\r\n     *\r\n     * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the\r\n     * {@link AuthClient `AuthClient`s}.\r\n     *\r\n     * @param opts\r\n     */\r\n    constructor(opts = {}) {\r\n        _GoogleAuth_instances.add(this);\r\n        /**\r\n         * Caches a value indicating whether the auth layer is running on Google\r\n         * Compute Engine.\r\n         * @private\r\n         */\r\n        this.checkIsGCE = undefined;\r\n        // To save the contents of the JSON credential file\r\n        this.jsonContent = null;\r\n        this.cachedCredential = null;\r\n        /**\r\n         * A pending {@link AuthClient}. Used for concurrent {@link GoogleAuth.getClient} calls.\r\n         */\r\n        _GoogleAuth_pendingAuthClient.set(this, null);\r\n        this.clientOptions = {};\r\n        this._cachedProjectId = opts.projectId || null;\r\n        this.cachedCredential = opts.authClient || null;\r\n        this.keyFilename = opts.keyFilename || opts.keyFile;\r\n        this.scopes = opts.scopes;\r\n        this.clientOptions = opts.clientOptions || {};\r\n        this.jsonContent = opts.credentials || null;\r\n        this.apiKey = opts.apiKey || this.clientOptions.apiKey || null;\r\n        // Cannot use both API Key + Credentials\r\n        if (this.apiKey && (this.jsonContent || this.clientOptions.credentials)) {\r\n            throw new RangeError(exports.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);\r\n        }\r\n        if (opts.universeDomain) {\r\n            this.clientOptions.universeDomain = opts.universeDomain;\r\n        }\r\n    }\r\n    // GAPIC client libraries should always use self-signed JWTs. The following\r\n    // variables are set on the JWT client in order to indicate the type of library,\r\n    // and sign the JWT with the correct audience and scopes (if not supplied).\r\n    setGapicJWTValues(client) {\r\n        client.defaultServicePath = this.defaultServicePath;\r\n        client.useJWTAccessWithScope = this.useJWTAccessWithScope;\r\n        client.defaultScopes = this.defaultScopes;\r\n    }\r\n    getProjectId(callback) {\r\n        if (callback) {\r\n            this.getProjectIdAsync().then(r => callback(null, r), callback);\r\n        }\r\n        else {\r\n            return this.getProjectIdAsync();\r\n        }\r\n    }\r\n    /**\r\n     * A temporary method for internal `getProjectId` usages where `null` is\r\n     * acceptable. In a future major release, `getProjectId` should return `null`\r\n     * (as the `Promise<string | null>` base signature describes) and this private\r\n     * method should be removed.\r\n     *\r\n     * @returns Promise that resolves with project id (or `null`)\r\n     */\r\n    async getProjectIdOptional() {\r\n        try {\r\n            return await this.getProjectId();\r\n        }\r\n        catch (e) {\r\n            if (e instanceof Error &&\r\n                e.message === exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * A private method for finding and caching a projectId.\r\n     *\r\n     * Supports environments in order of precedence:\r\n     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\r\n     * - GOOGLE_APPLICATION_CREDENTIALS JSON file\r\n     * - Cloud SDK: `gcloud config config-helper --format json`\r\n     * - GCE project ID from metadata server\r\n     *\r\n     * @returns projectId\r\n     */\r\n    async findAndCacheProjectId() {\r\n        let projectId = null;\r\n        projectId || (projectId = await this.getProductionProjectId());\r\n        projectId || (projectId = await this.getFileProjectId());\r\n        projectId || (projectId = await this.getDefaultServiceProjectId());\r\n        projectId || (projectId = await this.getGCEProjectId());\r\n        projectId || (projectId = await this.getExternalAccountClientProjectId());\r\n        if (projectId) {\r\n            this._cachedProjectId = projectId;\r\n            return projectId;\r\n        }\r\n        else {\r\n            throw new Error(exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\r\n        }\r\n    }\r\n    async getProjectIdAsync() {\r\n        if (this._cachedProjectId) {\r\n            return this._cachedProjectId;\r\n        }\r\n        if (!this._findProjectIdPromise) {\r\n            this._findProjectIdPromise = this.findAndCacheProjectId();\r\n        }\r\n        return this._findProjectIdPromise;\r\n    }\r\n    /**\r\n     * Retrieves a universe domain from the metadata server via\r\n     * {@link gcpMetadata.universe}.\r\n     *\r\n     * @returns a universe domain\r\n     */\r\n    async getUniverseDomainFromMetadataServer() {\r\n        var _a;\r\n        let universeDomain;\r\n        try {\r\n            universeDomain = await gcpMetadata.universe('universe-domain');\r\n            universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);\r\n        }\r\n        catch (e) {\r\n            if (e && ((_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {\r\n                universeDomain = authclient_1.DEFAULT_UNIVERSE;\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        return universeDomain;\r\n    }\r\n    /**\r\n     * Retrieves, caches, and returns the universe domain in the following order\r\n     * of precedence:\r\n     * - The universe domain in {@link GoogleAuth.clientOptions}\r\n     * - An existing or ADC {@link AuthClient}'s universe domain\r\n     * - {@link gcpMetadata.universe}, if {@link Compute} client\r\n     *\r\n     * @returns The universe domain\r\n     */\r\n    async getUniverseDomain() {\r\n        let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get('universe_domain');\r\n        try {\r\n            universeDomain !== null && universeDomain !== void 0 ? universeDomain : (universeDomain = (await this.getClient()).universeDomain);\r\n        }\r\n        catch (_a) {\r\n            // client or ADC is not available\r\n            universeDomain !== null && universeDomain !== void 0 ? universeDomain : (universeDomain = authclient_1.DEFAULT_UNIVERSE);\r\n        }\r\n        return universeDomain;\r\n    }\r\n    /**\r\n     * @returns Any scopes (user-specified or default scopes specified by the\r\n     *   client library) that need to be set on the current Auth client.\r\n     */\r\n    getAnyScopes() {\r\n        return this.scopes || this.defaultScopes;\r\n    }\r\n    getApplicationDefault(optionsOrCallback = {}, callback) {\r\n        let options;\r\n        if (typeof optionsOrCallback === 'function') {\r\n            callback = optionsOrCallback;\r\n        }\r\n        else {\r\n            options = optionsOrCallback;\r\n        }\r\n        if (callback) {\r\n            this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\r\n        }\r\n        else {\r\n            return this.getApplicationDefaultAsync(options);\r\n        }\r\n    }\r\n    async getApplicationDefaultAsync(options = {}) {\r\n        // If we've already got a cached credential, return it.\r\n        // This will also preserve one's configured quota project, in case they\r\n        // set one directly on the credential previously.\r\n        if (this.cachedCredential) {\r\n            // cache, while preserving existing quota project preferences\r\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, this.cachedCredential, null);\r\n        }\r\n        let credential;\r\n        // Check for the existence of a local environment variable pointing to the\r\n        // location of the credential file. This is typically used in local\r\n        // developer scenarios.\r\n        credential =\r\n            await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\r\n        if (credential) {\r\n            if (credential instanceof jwtclient_1.JWT) {\r\n                credential.scopes = this.scopes;\r\n            }\r\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\r\n                credential.scopes = this.getAnyScopes();\r\n            }\r\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, credential);\r\n        }\r\n        // Look in the well-known credential file location.\r\n        credential =\r\n            await this._tryGetApplicationCredentialsFromWellKnownFile(options);\r\n        if (credential) {\r\n            if (credential instanceof jwtclient_1.JWT) {\r\n                credential.scopes = this.scopes;\r\n            }\r\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\r\n                credential.scopes = this.getAnyScopes();\r\n            }\r\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, credential);\r\n        }\r\n        // Determine if we're running on GCE.\r\n        if (await this._checkIsGCE()) {\r\n            options.scopes = this.getAnyScopes();\r\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, new computeclient_1.Compute(options));\r\n        }\r\n        throw new Error(exports.GoogleAuthExceptionMessages.NO_ADC_FOUND);\r\n    }\r\n    /**\r\n     * Determines whether the auth layer is running on Google Compute Engine.\r\n     * Checks for GCP Residency, then fallback to checking if metadata server\r\n     * is available.\r\n     *\r\n     * @returns A promise that resolves with the boolean.\r\n     * @api private\r\n     */\r\n    async _checkIsGCE() {\r\n        if (this.checkIsGCE === undefined) {\r\n            this.checkIsGCE =\r\n                gcpMetadata.getGCPResidency() || (await gcpMetadata.isAvailable());\r\n        }\r\n        return this.checkIsGCE;\r\n    }\r\n    /**\r\n     * Attempts to load default credentials from the environment variable path..\r\n     * @returns Promise that resolves with the OAuth2Client or null.\r\n     * @api private\r\n     */\r\n    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\r\n        const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] ||\r\n            process.env['google_application_credentials'];\r\n        if (!credentialsPath || credentialsPath.length === 0) {\r\n            return null;\r\n        }\r\n        try {\r\n            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof Error) {\r\n                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Attempts to load default credentials from a well-known file location\r\n     * @return Promise that resolves with the OAuth2Client or null.\r\n     * @api private\r\n     */\r\n    async _tryGetApplicationCredentialsFromWellKnownFile(options) {\r\n        // First, figure out the location of the file, depending upon the OS type.\r\n        let location = null;\r\n        if (this._isWindows()) {\r\n            // Windows\r\n            location = process.env['APPDATA'];\r\n        }\r\n        else {\r\n            // Linux or Mac\r\n            const home = process.env['HOME'];\r\n            if (home) {\r\n                location = path.join(home, '.config');\r\n            }\r\n        }\r\n        // If we found the root path, expand it.\r\n        if (location) {\r\n            location = path.join(location, 'gcloud', 'application_default_credentials.json');\r\n            if (!fs.existsSync(location)) {\r\n                location = null;\r\n            }\r\n        }\r\n        // The file does not exist.\r\n        if (!location) {\r\n            return null;\r\n        }\r\n        // The file seems to exist. Try to use it.\r\n        const client = await this._getApplicationCredentialsFromFilePath(location, options);\r\n        return client;\r\n    }\r\n    /**\r\n     * Attempts to load default credentials from a file at the given path..\r\n     * @param filePath The path to the file to read.\r\n     * @returns Promise that resolves with the OAuth2Client\r\n     * @api private\r\n     */\r\n    async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\r\n        // Make sure the path looks like a string.\r\n        if (!filePath || filePath.length === 0) {\r\n            throw new Error('The file path is invalid.');\r\n        }\r\n        // Make sure there is a file at the path. lstatSync will throw if there is\r\n        // nothing there.\r\n        try {\r\n            // Resolve path to actual file in case of symlink. Expect a thrown error\r\n            // if not resolvable.\r\n            filePath = fs.realpathSync(filePath);\r\n            if (!fs.lstatSync(filePath).isFile()) {\r\n                throw new Error();\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof Error) {\r\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\r\n            }\r\n            throw err;\r\n        }\r\n        // Now open a read stream on the file, and parse it.\r\n        const readStream = fs.createReadStream(filePath);\r\n        return this.fromStream(readStream, options);\r\n    }\r\n    /**\r\n     * Create a credentials instance using a given impersonated input options.\r\n     * @param json The impersonated input object.\r\n     * @returns JWT or UserRefresh Client with data\r\n     */\r\n    fromImpersonatedJSON(json) {\r\n        var _a, _b, _c, _d;\r\n        if (!json) {\r\n            throw new Error('Must pass in a JSON object containing an  impersonated refresh token');\r\n        }\r\n        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\r\n            throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\r\n        }\r\n        if (!json.source_credentials) {\r\n            throw new Error('The incoming JSON object does not contain a source_credentials field');\r\n        }\r\n        if (!json.service_account_impersonation_url) {\r\n            throw new Error('The incoming JSON object does not contain a service_account_impersonation_url field');\r\n        }\r\n        const sourceClient = this.fromJSON(json.source_credentials);\r\n        if (((_a = json.service_account_impersonation_url) === null || _a === void 0 ? void 0 : _a.length) > 256) {\r\n            /**\r\n             * Prevents DOS attacks.\r\n             * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/85}\r\n             **/\r\n            throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);\r\n        }\r\n        // Extract service account from service_account_impersonation_url\r\n        const targetPrincipal = (_c = (_b = /(?<target>[^/]+):(generateAccessToken|generateIdToken)$/.exec(json.service_account_impersonation_url)) === null || _b === void 0 ? void 0 : _b.groups) === null || _c === void 0 ? void 0 : _c.target;\r\n        if (!targetPrincipal) {\r\n            throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\r\n        }\r\n        const targetScopes = (_d = this.getAnyScopes()) !== null && _d !== void 0 ? _d : [];\r\n        return new impersonated_1.Impersonated({\r\n            ...json,\r\n            sourceClient,\r\n            targetPrincipal,\r\n            targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes],\r\n        });\r\n    }\r\n    /**\r\n     * Create a credentials instance using the given input options.\r\n     * This client is not cached.\r\n     *\r\n     * @param json The input object.\r\n     * @param options The JWT or UserRefresh options for the client\r\n     * @returns JWT or UserRefresh Client with data\r\n     */\r\n    fromJSON(json, options = {}) {\r\n        let client;\r\n        // user's preferred universe domain\r\n        const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get('universe_domain');\r\n        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\r\n            client = new refreshclient_1.UserRefreshClient(options);\r\n            client.fromJSON(json);\r\n        }\r\n        else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\r\n            client = this.fromImpersonatedJSON(json);\r\n        }\r\n        else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\r\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\r\n            client.scopes = this.getAnyScopes();\r\n        }\r\n        else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\r\n            client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\r\n        }\r\n        else {\r\n            options.scopes = this.scopes;\r\n            client = new jwtclient_1.JWT(options);\r\n            this.setGapicJWTValues(client);\r\n            client.fromJSON(json);\r\n        }\r\n        if (preferredUniverseDomain) {\r\n            client.universeDomain = preferredUniverseDomain;\r\n        }\r\n        return client;\r\n    }\r\n    /**\r\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\r\n     * object used to instantiate and the client.\r\n     * @param json The input object.\r\n     * @param options The JWT or UserRefresh options for the client\r\n     * @returns JWT or UserRefresh Client with data\r\n     */\r\n    _cacheClientFromJSON(json, options) {\r\n        const client = this.fromJSON(json, options);\r\n        // cache both raw data used to instantiate client and client itself.\r\n        this.jsonContent = json;\r\n        this.cachedCredential = client;\r\n        return client;\r\n    }\r\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\r\n        let options = {};\r\n        if (typeof optionsOrCallback === 'function') {\r\n            callback = optionsOrCallback;\r\n        }\r\n        else {\r\n            options = optionsOrCallback;\r\n        }\r\n        if (callback) {\r\n            this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\r\n        }\r\n        else {\r\n            return this.fromStreamAsync(inputStream, options);\r\n        }\r\n    }\r\n    fromStreamAsync(inputStream, options) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!inputStream) {\r\n                throw new Error('Must pass in a stream containing the Google auth settings.');\r\n            }\r\n            const chunks = [];\r\n            inputStream\r\n                .setEncoding('utf8')\r\n                .on('error', reject)\r\n                .on('data', chunk => chunks.push(chunk))\r\n                .on('end', () => {\r\n                try {\r\n                    try {\r\n                        const data = JSON.parse(chunks.join(''));\r\n                        const r = this._cacheClientFromJSON(data, options);\r\n                        return resolve(r);\r\n                    }\r\n                    catch (err) {\r\n                        // If we failed parsing this.keyFileName, assume that it\r\n                        // is a PEM or p12 certificate:\r\n                        if (!this.keyFilename)\r\n                            throw err;\r\n                        const client = new jwtclient_1.JWT({\r\n                            ...this.clientOptions,\r\n                            keyFile: this.keyFilename,\r\n                        });\r\n                        this.cachedCredential = client;\r\n                        this.setGapicJWTValues(client);\r\n                        return resolve(client);\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    return reject(err);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Create a credentials instance using the given API key string.\r\n     * The created client is not cached. In order to create and cache it use the {@link GoogleAuth.getClient `getClient`} method after first providing an {@link GoogleAuth.apiKey `apiKey`}.\r\n     *\r\n     * @param apiKey The API key string\r\n     * @param options An optional options object.\r\n     * @returns A JWT loaded from the key\r\n     */\r\n    fromAPIKey(apiKey, options = {}) {\r\n        return new jwtclient_1.JWT({ ...options, apiKey });\r\n    }\r\n    /**\r\n     * Determines whether the current operating system is Windows.\r\n     * @api private\r\n     */\r\n    _isWindows() {\r\n        const sys = os.platform();\r\n        if (sys && sys.length >= 3) {\r\n            if (sys.substring(0, 3).toLowerCase() === 'win') {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Run the Google Cloud SDK command that prints the default project ID\r\n     */\r\n    async getDefaultServiceProjectId() {\r\n        return new Promise(resolve => {\r\n            (0, child_process_1.exec)('gcloud config config-helper --format json', (err, stdout) => {\r\n                if (!err && stdout) {\r\n                    try {\r\n                        const projectId = JSON.parse(stdout).configuration.properties.core.project;\r\n                        resolve(projectId);\r\n                        return;\r\n                    }\r\n                    catch (e) {\r\n                        // ignore errors\r\n                    }\r\n                }\r\n                resolve(null);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Loads the project id from environment variables.\r\n     * @api private\r\n     */\r\n    getProductionProjectId() {\r\n        return (process.env['GCLOUD_PROJECT'] ||\r\n            process.env['GOOGLE_CLOUD_PROJECT'] ||\r\n            process.env['gcloud_project'] ||\r\n            process.env['google_cloud_project']);\r\n    }\r\n    /**\r\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\r\n     * @api private\r\n     */\r\n    async getFileProjectId() {\r\n        if (this.cachedCredential) {\r\n            // Try to read the project ID from the cached credentials file\r\n            return this.cachedCredential.projectId;\r\n        }\r\n        // Ensure the projectId is loaded from the keyFile if available.\r\n        if (this.keyFilename) {\r\n            const creds = await this.getClient();\r\n            if (creds && creds.projectId) {\r\n                return creds.projectId;\r\n            }\r\n        }\r\n        // Try to load a credentials file and read its project ID\r\n        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\r\n        if (r) {\r\n            return r.projectId;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Gets the project ID from external account client if available.\r\n     */\r\n    async getExternalAccountClientProjectId() {\r\n        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\r\n            return null;\r\n        }\r\n        const creds = await this.getClient();\r\n        // Do not suppress the underlying error, as the error could contain helpful\r\n        // information for debugging and fixing. This is especially true for\r\n        // external account creds as in order to get the project ID, the following\r\n        // operations have to succeed:\r\n        // 1. Valid credentials file should be supplied.\r\n        // 2. Ability to retrieve access tokens from STS token exchange API.\r\n        // 3. Ability to exchange for service account impersonated credentials (if\r\n        //    enabled).\r\n        // 4. Ability to get project info using the access token from step 2 or 3.\r\n        // Without surfacing the error, it is harder for developers to determine\r\n        // which step went wrong.\r\n        return await creds.getProjectId();\r\n    }\r\n    /**\r\n     * Gets the Compute Engine project ID if it can be inferred.\r\n     */\r\n    async getGCEProjectId() {\r\n        try {\r\n            const r = await gcpMetadata.project('project-id');\r\n            return r;\r\n        }\r\n        catch (e) {\r\n            // Ignore any errors\r\n            return null;\r\n        }\r\n    }\r\n    getCredentials(callback) {\r\n        if (callback) {\r\n            this.getCredentialsAsync().then(r => callback(null, r), callback);\r\n        }\r\n        else {\r\n            return this.getCredentialsAsync();\r\n        }\r\n    }\r\n    async getCredentialsAsync() {\r\n        const client = await this.getClient();\r\n        if (client instanceof impersonated_1.Impersonated) {\r\n            return { client_email: client.getTargetPrincipal() };\r\n        }\r\n        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\r\n            const serviceAccountEmail = client.getServiceAccountEmail();\r\n            if (serviceAccountEmail) {\r\n                return {\r\n                    client_email: serviceAccountEmail,\r\n                    universe_domain: client.universeDomain,\r\n                };\r\n            }\r\n        }\r\n        if (this.jsonContent) {\r\n            return {\r\n                client_email: this.jsonContent.client_email,\r\n                private_key: this.jsonContent.private_key,\r\n                universe_domain: this.jsonContent.universe_domain,\r\n            };\r\n        }\r\n        if (await this._checkIsGCE()) {\r\n            const [client_email, universe_domain] = await Promise.all([\r\n                gcpMetadata.instance('service-accounts/default/email'),\r\n                this.getUniverseDomain(),\r\n            ]);\r\n            return { client_email, universe_domain };\r\n        }\r\n        throw new Error(exports.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);\r\n    }\r\n    /**\r\n     * Automatically obtain an {@link AuthClient `AuthClient`} based on the\r\n     * provided configuration. If no options were passed, use Application\r\n     * Default Credentials.\r\n     */\r\n    async getClient() {\r\n        if (this.cachedCredential) {\r\n            return this.cachedCredential;\r\n        }\r\n        // Use an existing auth client request, or cache a new one\r\n        __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, \"f\") || __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_determineClient).call(this), \"f\");\r\n        try {\r\n            return await __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, \"f\");\r\n        }\r\n        finally {\r\n            // reset the pending auth client in case it is changed later\r\n            __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, null, \"f\");\r\n        }\r\n    }\r\n    /**\r\n     * Creates a client which will fetch an ID token for authorization.\r\n     * @param targetAudience the audience for the fetched ID token.\r\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\r\n     */\r\n    async getIdTokenClient(targetAudience) {\r\n        const client = await this.getClient();\r\n        if (!('fetchIdToken' in client)) {\r\n            throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\r\n        }\r\n        return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });\r\n    }\r\n    /**\r\n     * Automatically obtain application default credentials, and return\r\n     * an access token for making requests.\r\n     */\r\n    async getAccessToken() {\r\n        const client = await this.getClient();\r\n        return (await client.getAccessToken()).token;\r\n    }\r\n    /**\r\n     * Obtain the HTTP headers that will provide authorization for a given\r\n     * request.\r\n     */\r\n    async getRequestHeaders(url) {\r\n        const client = await this.getClient();\r\n        return client.getRequestHeaders(url);\r\n    }\r\n    /**\r\n     * Obtain credentials for a request, then attach the appropriate headers to\r\n     * the request options.\r\n     * @param opts Axios or Request options on which to attach the headers\r\n     */\r\n    async authorizeRequest(opts) {\r\n        opts = opts || {};\r\n        const url = opts.url || opts.uri;\r\n        const client = await this.getClient();\r\n        const headers = await client.getRequestHeaders(url);\r\n        opts.headers = Object.assign(opts.headers || {}, headers);\r\n        return opts;\r\n    }\r\n    /**\r\n     * Automatically obtain application default credentials, and make an\r\n     * HTTP request using the given options.\r\n     * @param opts Axios request options for the HTTP request.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    async request(opts) {\r\n        const client = await this.getClient();\r\n        return client.request(opts);\r\n    }\r\n    /**\r\n     * Determine the compute environment in which the code is running.\r\n     */\r\n    getEnv() {\r\n        return (0, envDetect_1.getEnv)();\r\n    }\r\n    /**\r\n     * Sign the given data with the current private key, or go out\r\n     * to the IAM API to sign it.\r\n     * @param data The data to be signed.\r\n     * @param endpoint A custom endpoint to use.\r\n     *\r\n     * @example\r\n     * ```\r\n     * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');\r\n     * ```\r\n     */\r\n    async sign(data, endpoint) {\r\n        const client = await this.getClient();\r\n        const universe = await this.getUniverseDomain();\r\n        endpoint =\r\n            endpoint ||\r\n                `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;\r\n        if (client instanceof impersonated_1.Impersonated) {\r\n            const signed = await client.sign(data);\r\n            return signed.signedBlob;\r\n        }\r\n        const crypto = (0, crypto_1.createCrypto)();\r\n        if (client instanceof jwtclient_1.JWT && client.key) {\r\n            const sign = await crypto.sign(client.key, data);\r\n            return sign;\r\n        }\r\n        const creds = await this.getCredentials();\r\n        if (!creds.client_email) {\r\n            throw new Error('Cannot sign data without `client_email`.');\r\n        }\r\n        return this.signBlob(crypto, creds.client_email, data, endpoint);\r\n    }\r\n    async signBlob(crypto, emailOrUniqueId, data, endpoint) {\r\n        const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);\r\n        const res = await this.request({\r\n            method: 'POST',\r\n            url: url.href,\r\n            data: {\r\n                payload: crypto.encodeBase64StringUtf8(data),\r\n            },\r\n            retry: true,\r\n            retryConfig: {\r\n                httpMethodsToRetry: ['POST'],\r\n            },\r\n        });\r\n        return res.data.signedBlob;\r\n    }\r\n}\r\nexports.GoogleAuth = GoogleAuth;\r\n_GoogleAuth_pendingAuthClient = new WeakMap(), _GoogleAuth_instances = new WeakSet(), _GoogleAuth_prepareAndCacheClient = async function _GoogleAuth_prepareAndCacheClient(credential, quotaProjectIdOverride = process.env['GOOGLE_CLOUD_QUOTA_PROJECT'] || null) {\r\n    const projectId = await this.getProjectIdOptional();\r\n    if (quotaProjectIdOverride) {\r\n        credential.quotaProjectId = quotaProjectIdOverride;\r\n    }\r\n    this.cachedCredential = credential;\r\n    return { credential, projectId };\r\n}, _GoogleAuth_determineClient = async function _GoogleAuth_determineClient() {\r\n    if (this.jsonContent) {\r\n        return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\r\n    }\r\n    else if (this.keyFilename) {\r\n        const filePath = path.resolve(this.keyFilename);\r\n        const stream = fs.createReadStream(filePath);\r\n        return await this.fromStreamAsync(stream, this.clientOptions);\r\n    }\r\n    else if (this.apiKey) {\r\n        const client = await this.fromAPIKey(this.apiKey, this.clientOptions);\r\n        client.scopes = this.scopes;\r\n        const { credential } = await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, client);\r\n        return credential;\r\n    }\r\n    else {\r\n        const { credential } = await this.getApplicationDefaultAsync(this.clientOptions);\r\n        return credential;\r\n    }\r\n};\r\n/**\r\n * Export DefaultTransporter as a static property of the class.\r\n */\r\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}