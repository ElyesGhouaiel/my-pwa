{"ast":null,"code":"\"use strict\";\n\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryable = retryable;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst timeout_1 = require(\"./timeout\");\n/**\r\n * Creates a function equivalent to func, but that retries on certain\r\n * exceptions.\r\n *\r\n * @private\r\n *\r\n * @param {GRPCCall} func - A function.\r\n * @param {RetryOptions} retry - Configures the exceptions upon which the\r\n *   function eshould retry, and the parameters to the exponential backoff retry\r\n *   algorithm.\r\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\r\n * @return {SimpleCallbackFunction} A function that will retry.\r\n */\nfunction retryable(func, retry, otherArgs, apiName) {\n  const delayMult = retry.backoffSettings.retryDelayMultiplier;\n  const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n  const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n  const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n  let delay = retry.backoffSettings.initialRetryDelayMillis;\n  let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n  /**\r\n   * Equivalent to ``func``, but retries upon transient failure.\r\n   *\r\n   * Retrying is done through an exponential backoff algorithm configured\r\n   * by the options in ``retry``.\r\n   * @param {RequestType} argument The request object.\r\n   * @param {APICallback} callback The callback.\r\n   * @return {GRPCCall}\r\n   */\n  return (argument, callback) => {\n    let canceller;\n    let timeoutId;\n    let now = new Date();\n    let deadline;\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n    let retries = 0;\n    const maxRetries = retry.backoffSettings.maxRetries;\n    // TODO: define A/B testing values for retry behaviors.\n    /** Repeat the API call as long as necessary. */\n    function repeat(err) {\n      timeoutId = null;\n      if (deadline && now.getTime() >= deadline) {\n        const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds ${err ? `retrying error ${err} ` : ''} before any response was received.`);\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n      if (retries && retries >= maxRetries) {\n        const error = new googleError_1.GoogleError('Exceeded maximum number of retries ' + (err ? `retrying error ${err} ` : '') + 'before any response was received');\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n      retries++;\n      let lastError = err;\n      const toCall = (0, timeout_1.addTimeoutArg)(func, timeout, otherArgs);\n      canceller = toCall(argument, (err, response, next, rawResponse) => {\n        // Save only the error before deadline exceeded\n        if (err && err.code !== 4) {\n          lastError = err;\n        }\n        if (!err) {\n          callback(null, response, next, rawResponse);\n          return;\n        }\n        canceller = null;\n        if (retry.retryCodes.length > 0 && retry.retryCodes.indexOf(err.code) < 0) {\n          err.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          callback(err);\n        } else {\n          const toSleep = Math.random() * delay;\n          timeoutId = setTimeout(() => {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n            const rpcTimeout = maxTimeout ? maxTimeout : 0;\n            const newDeadline = deadline ? deadline - now.getTime() : 0;\n            timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n            repeat(lastError);\n          }, toSleep);\n        }\n      });\n      if (canceller instanceof Promise) {\n        canceller.catch(err => {\n          callback(new googleError_1.GoogleError(err));\n        });\n      }\n    }\n    if (maxRetries && deadline) {\n      const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n    } else {\n      repeat();\n    }\n    return {\n      cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (canceller) {\n          canceller.cancel();\n        } else {\n          const error = new googleError_1.GoogleError('cancelled');\n          error.code = status_1.Status.CANCELLED;\n          callback(error);\n        }\n      }\n    };\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","retryable","status_1","require","googleError_1","timeout_1","func","retry","otherArgs","apiName","delayMult","backoffSettings","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","timeoutMult","rpcTimeoutMultiplier","maxTimeout","maxRpcTimeoutMillis","delay","initialRetryDelayMillis","timeout","initialRpcTimeoutMillis","argument","callback","canceller","timeoutId","now","Date","deadline","totalTimeoutMillis","getTime","retries","maxRetries","repeat","err","error","GoogleError","code","Status","DEADLINE_EXCEEDED","lastError","toCall","addTimeoutArg","response","next","rawResponse","retryCodes","length","indexOf","note","toSleep","Math","random","setTimeout","min","timeoutCal","rpcTimeout","newDeadline","Promise","catch","INVALID_ARGUMENT","cancel","clearTimeout","CANCELLED"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/google-gax/build/src/normalCalls/retries.js"],"sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.retryable = retryable;\r\nconst status_1 = require(\"../status\");\r\nconst googleError_1 = require(\"../googleError\");\r\nconst timeout_1 = require(\"./timeout\");\r\n/**\r\n * Creates a function equivalent to func, but that retries on certain\r\n * exceptions.\r\n *\r\n * @private\r\n *\r\n * @param {GRPCCall} func - A function.\r\n * @param {RetryOptions} retry - Configures the exceptions upon which the\r\n *   function eshould retry, and the parameters to the exponential backoff retry\r\n *   algorithm.\r\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\r\n * @return {SimpleCallbackFunction} A function that will retry.\r\n */\r\nfunction retryable(func, retry, otherArgs, apiName) {\r\n    const delayMult = retry.backoffSettings.retryDelayMultiplier;\r\n    const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\r\n    const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\r\n    const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\r\n    let delay = retry.backoffSettings.initialRetryDelayMillis;\r\n    let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\r\n    /**\r\n     * Equivalent to ``func``, but retries upon transient failure.\r\n     *\r\n     * Retrying is done through an exponential backoff algorithm configured\r\n     * by the options in ``retry``.\r\n     * @param {RequestType} argument The request object.\r\n     * @param {APICallback} callback The callback.\r\n     * @return {GRPCCall}\r\n     */\r\n    return (argument, callback) => {\r\n        let canceller;\r\n        let timeoutId;\r\n        let now = new Date();\r\n        let deadline;\r\n        if (retry.backoffSettings.totalTimeoutMillis) {\r\n            deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\r\n        }\r\n        let retries = 0;\r\n        const maxRetries = retry.backoffSettings.maxRetries;\r\n        // TODO: define A/B testing values for retry behaviors.\r\n        /** Repeat the API call as long as necessary. */\r\n        function repeat(err) {\r\n            timeoutId = null;\r\n            if (deadline && now.getTime() >= deadline) {\r\n                const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds ${err ? `retrying error ${err} ` : ''} before any response was received.`);\r\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\r\n                callback(error);\r\n                return;\r\n            }\r\n            if (retries && retries >= maxRetries) {\r\n                const error = new googleError_1.GoogleError('Exceeded maximum number of retries ' +\r\n                    (err ? `retrying error ${err} ` : '') +\r\n                    'before any response was received');\r\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\r\n                callback(error);\r\n                return;\r\n            }\r\n            retries++;\r\n            let lastError = err;\r\n            const toCall = (0, timeout_1.addTimeoutArg)(func, timeout, otherArgs);\r\n            canceller = toCall(argument, (err, response, next, rawResponse) => {\r\n                // Save only the error before deadline exceeded\r\n                if (err && err.code !== 4) {\r\n                    lastError = err;\r\n                }\r\n                if (!err) {\r\n                    callback(null, response, next, rawResponse);\r\n                    return;\r\n                }\r\n                canceller = null;\r\n                if (retry.retryCodes.length > 0 &&\r\n                    retry.retryCodes.indexOf(err.code) < 0) {\r\n                    err.note =\r\n                        'Exception occurred in retry method that was ' +\r\n                            'not classified as transient';\r\n                    callback(err);\r\n                }\r\n                else {\r\n                    const toSleep = Math.random() * delay;\r\n                    timeoutId = setTimeout(() => {\r\n                        now = new Date();\r\n                        delay = Math.min(delay * delayMult, maxDelay);\r\n                        const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\r\n                        const rpcTimeout = maxTimeout ? maxTimeout : 0;\r\n                        const newDeadline = deadline ? deadline - now.getTime() : 0;\r\n                        timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\r\n                        repeat(lastError);\r\n                    }, toSleep);\r\n                }\r\n            });\r\n            if (canceller instanceof Promise) {\r\n                canceller.catch(err => {\r\n                    callback(new googleError_1.GoogleError(err));\r\n                });\r\n            }\r\n        }\r\n        if (maxRetries && deadline) {\r\n            const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' +\r\n                'in backoffSettings.');\r\n            error.code = status_1.Status.INVALID_ARGUMENT;\r\n            callback(error);\r\n        }\r\n        else {\r\n            repeat();\r\n        }\r\n        return {\r\n            cancel() {\r\n                if (timeoutId) {\r\n                    clearTimeout(timeoutId);\r\n                }\r\n                if (canceller) {\r\n                    canceller.cancel();\r\n                }\r\n                else {\r\n                    const error = new googleError_1.GoogleError('cancelled');\r\n                    error.code = status_1.Status.CANCELLED;\r\n                    callback(error);\r\n                }\r\n            },\r\n        };\r\n    };\r\n}\r\n//# sourceMappingURL=retries.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}