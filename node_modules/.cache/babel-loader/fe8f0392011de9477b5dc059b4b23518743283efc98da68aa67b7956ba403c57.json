{"ast":null,"code":"\"use strict\";\n\n/**\r\n * Copyright 2024 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DocumentReference = void 0;\nconst index_1 = require(\"../index\");\nconst path_1 = require(\"../path\");\nconst types_1 = require(\"../types\");\nconst collection_reference_1 = require(\"./collection-reference\");\nconst util_1 = require(\"../util\");\nconst validate_1 = require(\"../validate\");\nconst document_1 = require(\"../document\");\nconst trace_util_1 = require(\"../telemetry/trace-util\");\n/**\r\n * A DocumentReference refers to a document location in a Firestore database\r\n * and can be used to write, read, or listen to the location. The document at\r\n * the referenced location may or may not exist. A DocumentReference can\r\n * also be used to create a\r\n * [CollectionReference]{@link CollectionReference} to a\r\n * subcollection.\r\n *\r\n * @class DocumentReference\r\n */\nclass DocumentReference {\n  /**\r\n   * @private\r\n   * @internal\r\n   * @param _firestore The Firestore Database client.\r\n   * @param _path The Path of this reference.\r\n   * @param _converter The converter to use when serializing data.\r\n   */\n  constructor(_firestore,\n  /**\r\n   * @private\r\n   * @internal\r\n   **/\n  _path,\n  /**\r\n   * @internal\r\n   * @private\r\n   **/\n  _converter = (0, types_1.defaultConverter)()) {\n    this._firestore = _firestore;\n    this._path = _path;\n    this._converter = _converter;\n  }\n  /**\r\n   * The string representation of the DocumentReference's location.\r\n   * @private\r\n   * @internal\r\n   * @type {string}\r\n   * @name DocumentReference#formattedName\r\n   */\n  get formattedName() {\n    const projectId = this.firestore.projectId;\n    const databaseId = this.firestore.databaseId;\n    return this._path.toQualifiedResourcePath(projectId, databaseId).formattedName;\n  }\n  /**\r\n   * The [Firestore]{@link Firestore} instance for the Firestore\r\n   * database (useful for performing transactions, etc.).\r\n   *\r\n   * @type {Firestore}\r\n   * @name DocumentReference#firestore\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * ```\r\n   * let collectionRef = firestore.collection('col');\r\n   *\r\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\r\n   *   let firestore = documentReference.firestore;\r\n   *   console.log(`Root location for document is ${firestore.formattedName}`);\r\n   * });\r\n   * ```\r\n   */\n  get firestore() {\n    return this._firestore;\n  }\n  /**\r\n   * A string representing the path of the referenced document (relative\r\n   * to the root of the database).\r\n   *\r\n   * @type {string}\r\n   * @name DocumentReference#path\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * ```\r\n   * let collectionRef = firestore.collection('col');\r\n   *\r\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\r\n   *   console.log(`Added document at '${documentReference.path}'`);\r\n   * });\r\n   * ```\r\n   */\n  get path() {\n    return this._path.relativeName;\n  }\n  /**\r\n   * The last path element of the referenced document.\r\n   *\r\n   * @type {string}\r\n   * @name DocumentReference#id\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * ```\r\n   * let collectionRef = firestore.collection('col');\r\n   *\r\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\r\n   *   console.log(`Added document with name '${documentReference.id}'`);\r\n   * });\r\n   * ```\r\n   */\n  get id() {\n    return this._path.id;\n  }\n  /**\r\n   * Returns a resource path for this document.\r\n   * @private\r\n   * @internal\r\n   */\n  get _resourcePath() {\n    return this._path;\n  }\n  /**\r\n   * A reference to the collection to which this DocumentReference belongs.\r\n   *\r\n   * @name DocumentReference#parent\r\n   * @type {CollectionReference}\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   * let collectionRef = documentRef.parent;\r\n   *\r\n   * collectionRef.where('foo', '==', 'bar').get().then(results => {\r\n   *   console.log(`Found ${results.size} matches in parent collection`);\r\n   * }):\r\n   * ```\r\n   */\n  get parent() {\n    return new collection_reference_1.CollectionReference(this._firestore, this._path.parent(), this._converter);\n  }\n  /**\r\n   * Reads the document referred to by this DocumentReference.\r\n   *\r\n   * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\r\n   * DocumentSnapshot for the retrieved document on success. For missing\r\n   * documents, DocumentSnapshot.exists will be false. If the get() fails for\r\n   * other reasons, the Promise will be rejected.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(documentSnapshot => {\r\n   *   if (documentSnapshot.exists) {\r\n   *     console.log('Document retrieved successfully.');\r\n   *   }\r\n   * });\r\n   * ```\r\n   */\n  get() {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_GET, () => {\n      return this._firestore.getAll(this).then(([result]) => result);\n    });\n  }\n  /**\r\n   * Gets a [CollectionReference]{@link CollectionReference} instance\r\n   * that refers to the collection at the specified path.\r\n   *\r\n   * @param {string} collectionPath A slash-separated path to a collection.\r\n   * @returns {CollectionReference} A reference to the new\r\n   * subcollection.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   * let subcollection = documentRef.collection('subcollection');\r\n   * console.log(`Path to subcollection: ${subcollection.path}`);\r\n   * ```\r\n   */\n  collection(collectionPath) {\n    (0, path_1.validateResourcePath)('collectionPath', collectionPath);\n    const path = this._path.append(collectionPath);\n    if (!path.isCollection) {\n      throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n    }\n    return new collection_reference_1.CollectionReference(this._firestore, path);\n  }\n  /**\r\n   * Fetches the subcollections that are direct children of this document.\r\n   *\r\n   * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\r\n   * with an array of CollectionReferences.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.listCollections().then(collections => {\r\n   *   for (let collection of collections) {\r\n   *     console.log(`Found subcollection with id: ${collection.id}`);\r\n   *   }\r\n   * });\r\n   * ```\r\n   */\n  listCollections() {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_LIST_COLLECTIONS, () => {\n      const tag = (0, util_1.requestTag)();\n      return this.firestore.initializeIfNeeded(tag).then(() => {\n        const request = {\n          parent: this.formattedName,\n          // Setting `pageSize` to an arbitrarily large value lets the backend cap\n          // the page size (currently to 300). Note that the backend rejects\n          // MAX_INT32 (b/146883794).\n          pageSize: Math.pow(2, 16) - 1\n        };\n        return this._firestore.request('listCollectionIds', request, tag).then(collectionIds => {\n          const collections = [];\n          // We can just sort this list using the default comparator since it\n          // will only contain collection ids.\n          collectionIds.sort();\n          for (const collectionId of collectionIds) {\n            collections.push(this.collection(collectionId));\n          }\n          return collections;\n        });\n      });\n    });\n  }\n  /**\r\n   * Create a document with the provided object values. This will fail the write\r\n   * if a document exists at its location.\r\n   *\r\n   * @param {DocumentData} data An object that contains the fields and data to\r\n   * serialize as the document.\r\n   * @throws {Error} If the provided input is not a valid Firestore document or if the document already exists.\r\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\r\n   * write time of this create.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.collection('col').doc();\r\n   *\r\n   * documentRef.create({foo: 'bar'}).then((res) => {\r\n   *   console.log(`Document created at ${res.updateTime}`);\r\n   * }).catch((err) => {\r\n   *   console.log(`Failed to create document: ${err}`);\r\n   * });\r\n   * ```\r\n   */\n  create(data) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_CREATE, () => {\n      const writeBatch = new index_1.WriteBatch(this._firestore);\n      return writeBatch.create(this, data).commit().then(([writeResult]) => writeResult);\n    });\n  }\n  /**\r\n   * Deletes the document referred to by this `DocumentReference`.\r\n   *\r\n   * A delete for a non-existing document is treated as a success (unless\r\n   * lastUptimeTime is provided).\r\n   *\r\n   * @param {Precondition=} precondition A precondition to enforce for this\r\n   * delete.\r\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n   * document was last updated at lastUpdateTime. Fails the delete if the\r\n   * document was last updated at a different time.\r\n   * @param {boolean=} precondition.exists If set, enforces that the target\r\n   * document must or must not exist.\r\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\r\n   * delete time.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.delete().then(() => {\r\n   *   console.log('Document successfully deleted.');\r\n   * });\r\n   * ```\r\n   */\n  delete(precondition) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_DELETE, () => {\n      const writeBatch = new index_1.WriteBatch(this._firestore);\n      return writeBatch.delete(this, precondition).commit().then(([writeResult]) => writeResult);\n    });\n  }\n  /**\r\n   * Writes to the document referred to by this DocumentReference. If the\r\n   * document does not yet exist, it will be created. If you pass\r\n   * [SetOptions]{@link SetOptions}, the provided data can be merged into an\r\n   * existing document.\r\n   *\r\n   * @param {T|Partial<AppModelType>} data A map of the fields and values for\r\n   * the document.\r\n   * @param {SetOptions=} options An object to configure the set behavior.\r\n   * @param {boolean=} options.merge If true, set() merges the values specified\r\n   * in its data argument. Fields omitted from this set() call remain untouched.\r\n   * If your input sets any field to an empty map, all nested fields are\r\n   * overwritten.\r\n   * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\r\n   * set() only replaces the specified field paths. Any field path that is not\r\n   * specified is ignored and remains untouched. If your input sets any field to\r\n   * an empty map, all nested fields are overwritten.\r\n   * @throws {Error} If the provided input is not a valid Firestore document.\r\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\r\n   * write time of this set.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.set({foo: 'bar'}).then(res => {\r\n   *   console.log(`Document written at ${res.updateTime}`);\r\n   * });\r\n   * ```\r\n   */\n  set(data, options) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_SET, () => {\n      let writeBatch = new index_1.WriteBatch(this._firestore);\n      if (options) {\n        writeBatch = writeBatch.set(this, data, options);\n      } else {\n        writeBatch = writeBatch.set(this, data);\n      }\n      return writeBatch.commit().then(([writeResult]) => writeResult);\n    });\n  }\n  /**\r\n   * Updates fields in the document referred to by this DocumentReference.\r\n   * If the document doesn't yet exist, the update fails and the returned\r\n   * Promise will be rejected.\r\n   *\r\n   * The update() method accepts either an object with field paths encoded as\r\n   * keys and field values encoded as values, or a variable number of arguments\r\n   * that alternate between field paths and field values.\r\n   *\r\n   * A Precondition restricting this update can be specified as the last\r\n   * argument.\r\n   *\r\n   * @param {UpdateData|string|FieldPath} dataOrField An object containing the\r\n   * fields and values with which to update the document or the path of the\r\n   * first field to update.\r\n   * @param {\r\n   * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\r\n   * list of field paths and values to update or a Precondition to restrict\r\n   * this update.\r\n   * @throws {Error} If the provided input is not valid Firestore data.\r\n   * @returns {Promise.<WriteResult>} A Promise that resolves once the\r\n   * data has been successfully written to the backend.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.update({foo: 'bar'}).then(res => {\r\n   *   console.log(`Document updated at ${res.updateTime}`);\r\n   * });\r\n   * ```\r\n   */\n  update(dataOrField, ...preconditionOrValues) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_UPDATE, () => {\n      // eslint-disable-next-line prefer-rest-params\n      (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);\n      const writeBatch = new index_1.WriteBatch(this._firestore);\n      return writeBatch.update(this, dataOrField, ...preconditionOrValues).commit().then(([writeResult]) => writeResult);\n    });\n  }\n  /**\r\n   * Attaches a listener for DocumentSnapshot events.\r\n   *\r\n   * @param {documentSnapshotCallback} onNext A callback to be called every\r\n   * time a new `DocumentSnapshot` is available.\r\n   * @param {errorCallback=} onError A callback to be called if the listen fails\r\n   * or is cancelled. No further callbacks will occur. If unset, errors will be\r\n   * logged to the console.\r\n   *\r\n   * @returns {function()} An unsubscribe function that can be called to cancel\r\n   * the snapshot listener.\r\n   *\r\n   * @example\r\n   * ```\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\r\n   *   if (documentSnapshot.exists) {\r\n   *     console.log(documentSnapshot.data());\r\n   *   }\r\n   * }, err => {\r\n   *   console.log(`Encountered error: ${err}`);\r\n   * });\r\n   *\r\n   * // Remove this listener.\r\n   * unsubscribe();\r\n   * ```\r\n   */\n  onSnapshot(onNext, onError) {\n    (0, validate_1.validateFunction)('onNext', onNext);\n    (0, validate_1.validateFunction)('onError', onError, {\n      optional: true\n    });\n    const watch = new (require('../watch').DocumentWatch)(this.firestore, this);\n    return watch.onSnapshot((readTime, size, docs) => {\n      for (const document of docs()) {\n        if (document.ref.path === this.path) {\n          onNext(document);\n          return;\n        }\n      }\n      // The document is missing.\n      const ref = new DocumentReference(this._firestore, this._path, this._converter);\n      const document = new document_1.DocumentSnapshotBuilder(ref);\n      document.readTime = readTime;\n      onNext(document.build());\n    }, onError || console.error);\n  }\n  /**\r\n   * Returns true if this `DocumentReference` is equal to the provided value.\r\n   *\r\n   * @param {*} other The value to compare against.\r\n   * @return {boolean} true if this `DocumentReference` is equal to the provided\r\n   * value.\r\n   */\n  isEqual(other) {\n    return this === other || other instanceof DocumentReference && this._firestore === other._firestore && this._path.isEqual(other._path) && this._converter === other._converter;\n  }\n  /**\r\n   * Converts this DocumentReference to the Firestore Proto representation.\r\n   *\r\n   * @private\r\n   * @internal\r\n   */\n  toProto() {\n    return {\n      referenceValue: this.formattedName\n    };\n  }\n  /**\r\n   * Applies a custom data converter to this DocumentReference, allowing you to\r\n   * use your own custom model objects with Firestore. When you call set(),\r\n   * get(), etc. on the returned DocumentReference instance, the provided\r\n   * converter will convert between Firestore data of type `NewDbModelType` and\r\n   * your custom type `NewAppModelType`.\r\n   *\r\n   * Using the converter allows you to specify generic type arguments when\r\n   * storing and retrieving objects from Firestore.\r\n   *\r\n   * Passing in `null` as the converter parameter removes the current\r\n   * converter.\r\n   *\r\n   * @example\r\n   * ```\r\n   * class Post {\r\n   *   constructor(readonly title: string, readonly author: string) {}\r\n   *\r\n   *   toString(): string {\r\n   *     return this.title + ', by ' + this.author;\r\n   *   }\r\n   * }\r\n   *\r\n   * const postConverter = {\r\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\r\n   *     return {title: post.title, author: post.author};\r\n   *   },\r\n   *   fromFirestore(\r\n   *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\r\n   *   ): Post {\r\n   *     const data = snapshot.data();\r\n   *     return new Post(data.title, data.author);\r\n   *   }\r\n   * };\r\n   *\r\n   * const postSnap = await Firestore()\r\n   *   .collection('posts')\r\n   *   .withConverter(postConverter)\r\n   *   .doc().get();\r\n   * const post = postSnap.data();\r\n   * if (post !== undefined) {\r\n   *   post.title; // string\r\n   *   post.toString(); // Should be defined\r\n   *   post.someNonExistentProperty; // TS error\r\n   * }\r\n   *\r\n   * ```\r\n   * @param {FirestoreDataConverter | null} converter Converts objects to and\r\n   * from Firestore. Passing in `null` removes the current converter.\r\n   * @return A DocumentReference that uses the provided converter.\r\n   */\n  withConverter(converter) {\n    return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\n  }\n}\nexports.DocumentReference = DocumentReference;","map":{"version":3,"names":["Object","defineProperty","exports","value","DocumentReference","index_1","require","path_1","types_1","collection_reference_1","util_1","validate_1","document_1","trace_util_1","constructor","_firestore","_path","_converter","defaultConverter","formattedName","projectId","firestore","databaseId","toQualifiedResourcePath","path","relativeName","id","_resourcePath","parent","CollectionReference","get","_traceUtil","startActiveSpan","SPAN_NAME_DOC_REF_GET","getAll","then","result","collection","collectionPath","validateResourcePath","append","isCollection","Error","listCollections","SPAN_NAME_DOC_REF_LIST_COLLECTIONS","tag","requestTag","initializeIfNeeded","request","pageSize","Math","pow","collectionIds","collections","sort","collectionId","push","create","data","SPAN_NAME_DOC_REF_CREATE","writeBatch","WriteBatch","commit","writeResult","delete","precondition","SPAN_NAME_DOC_REF_DELETE","set","options","SPAN_NAME_DOC_REF_SET","update","dataOrField","preconditionOrValues","SPAN_NAME_DOC_REF_UPDATE","validateMinNumberOfArguments","arguments","onSnapshot","onNext","onError","validateFunction","optional","watch","DocumentWatch","readTime","size","docs","document","ref","DocumentSnapshotBuilder","build","console","error","isEqual","other","toProto","referenceValue","withConverter","converter"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js"],"sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2024 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DocumentReference = void 0;\r\nconst index_1 = require(\"../index\");\r\nconst path_1 = require(\"../path\");\r\nconst types_1 = require(\"../types\");\r\nconst collection_reference_1 = require(\"./collection-reference\");\r\nconst util_1 = require(\"../util\");\r\nconst validate_1 = require(\"../validate\");\r\nconst document_1 = require(\"../document\");\r\nconst trace_util_1 = require(\"../telemetry/trace-util\");\r\n/**\r\n * A DocumentReference refers to a document location in a Firestore database\r\n * and can be used to write, read, or listen to the location. The document at\r\n * the referenced location may or may not exist. A DocumentReference can\r\n * also be used to create a\r\n * [CollectionReference]{@link CollectionReference} to a\r\n * subcollection.\r\n *\r\n * @class DocumentReference\r\n */\r\nclass DocumentReference {\r\n    /**\r\n     * @private\r\n     * @internal\r\n     * @param _firestore The Firestore Database client.\r\n     * @param _path The Path of this reference.\r\n     * @param _converter The converter to use when serializing data.\r\n     */\r\n    constructor(_firestore, \r\n    /**\r\n     * @private\r\n     * @internal\r\n     **/\r\n    _path, \r\n    /**\r\n     * @internal\r\n     * @private\r\n     **/\r\n    _converter = (0, types_1.defaultConverter)()) {\r\n        this._firestore = _firestore;\r\n        this._path = _path;\r\n        this._converter = _converter;\r\n    }\r\n    /**\r\n     * The string representation of the DocumentReference's location.\r\n     * @private\r\n     * @internal\r\n     * @type {string}\r\n     * @name DocumentReference#formattedName\r\n     */\r\n    get formattedName() {\r\n        const projectId = this.firestore.projectId;\r\n        const databaseId = this.firestore.databaseId;\r\n        return this._path.toQualifiedResourcePath(projectId, databaseId)\r\n            .formattedName;\r\n    }\r\n    /**\r\n     * The [Firestore]{@link Firestore} instance for the Firestore\r\n     * database (useful for performing transactions, etc.).\r\n     *\r\n     * @type {Firestore}\r\n     * @name DocumentReference#firestore\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * ```\r\n     * let collectionRef = firestore.collection('col');\r\n     *\r\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\r\n     *   let firestore = documentReference.firestore;\r\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\r\n     * });\r\n     * ```\r\n     */\r\n    get firestore() {\r\n        return this._firestore;\r\n    }\r\n    /**\r\n     * A string representing the path of the referenced document (relative\r\n     * to the root of the database).\r\n     *\r\n     * @type {string}\r\n     * @name DocumentReference#path\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * ```\r\n     * let collectionRef = firestore.collection('col');\r\n     *\r\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\r\n     *   console.log(`Added document at '${documentReference.path}'`);\r\n     * });\r\n     * ```\r\n     */\r\n    get path() {\r\n        return this._path.relativeName;\r\n    }\r\n    /**\r\n     * The last path element of the referenced document.\r\n     *\r\n     * @type {string}\r\n     * @name DocumentReference#id\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * ```\r\n     * let collectionRef = firestore.collection('col');\r\n     *\r\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\r\n     *   console.log(`Added document with name '${documentReference.id}'`);\r\n     * });\r\n     * ```\r\n     */\r\n    get id() {\r\n        return this._path.id;\r\n    }\r\n    /**\r\n     * Returns a resource path for this document.\r\n     * @private\r\n     * @internal\r\n     */\r\n    get _resourcePath() {\r\n        return this._path;\r\n    }\r\n    /**\r\n     * A reference to the collection to which this DocumentReference belongs.\r\n     *\r\n     * @name DocumentReference#parent\r\n     * @type {CollectionReference}\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     * let collectionRef = documentRef.parent;\r\n     *\r\n     * collectionRef.where('foo', '==', 'bar').get().then(results => {\r\n     *   console.log(`Found ${results.size} matches in parent collection`);\r\n     * }):\r\n     * ```\r\n     */\r\n    get parent() {\r\n        return new collection_reference_1.CollectionReference(this._firestore, this._path.parent(), this._converter);\r\n    }\r\n    /**\r\n     * Reads the document referred to by this DocumentReference.\r\n     *\r\n     * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\r\n     * DocumentSnapshot for the retrieved document on success. For missing\r\n     * documents, DocumentSnapshot.exists will be false. If the get() fails for\r\n     * other reasons, the Promise will be rejected.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(documentSnapshot => {\r\n     *   if (documentSnapshot.exists) {\r\n     *     console.log('Document retrieved successfully.');\r\n     *   }\r\n     * });\r\n     * ```\r\n     */\r\n    get() {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_GET, () => {\r\n            return this._firestore.getAll(this).then(([result]) => result);\r\n        });\r\n    }\r\n    /**\r\n     * Gets a [CollectionReference]{@link CollectionReference} instance\r\n     * that refers to the collection at the specified path.\r\n     *\r\n     * @param {string} collectionPath A slash-separated path to a collection.\r\n     * @returns {CollectionReference} A reference to the new\r\n     * subcollection.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     * let subcollection = documentRef.collection('subcollection');\r\n     * console.log(`Path to subcollection: ${subcollection.path}`);\r\n     * ```\r\n     */\r\n    collection(collectionPath) {\r\n        (0, path_1.validateResourcePath)('collectionPath', collectionPath);\r\n        const path = this._path.append(collectionPath);\r\n        if (!path.isCollection) {\r\n            throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\r\n        }\r\n        return new collection_reference_1.CollectionReference(this._firestore, path);\r\n    }\r\n    /**\r\n     * Fetches the subcollections that are direct children of this document.\r\n     *\r\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\r\n     * with an array of CollectionReferences.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.listCollections().then(collections => {\r\n     *   for (let collection of collections) {\r\n     *     console.log(`Found subcollection with id: ${collection.id}`);\r\n     *   }\r\n     * });\r\n     * ```\r\n     */\r\n    listCollections() {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_LIST_COLLECTIONS, () => {\r\n            const tag = (0, util_1.requestTag)();\r\n            return this.firestore.initializeIfNeeded(tag).then(() => {\r\n                const request = {\r\n                    parent: this.formattedName,\r\n                    // Setting `pageSize` to an arbitrarily large value lets the backend cap\r\n                    // the page size (currently to 300). Note that the backend rejects\r\n                    // MAX_INT32 (b/146883794).\r\n                    pageSize: Math.pow(2, 16) - 1,\r\n                };\r\n                return this._firestore\r\n                    .request('listCollectionIds', request, tag)\r\n                    .then(collectionIds => {\r\n                    const collections = [];\r\n                    // We can just sort this list using the default comparator since it\r\n                    // will only contain collection ids.\r\n                    collectionIds.sort();\r\n                    for (const collectionId of collectionIds) {\r\n                        collections.push(this.collection(collectionId));\r\n                    }\r\n                    return collections;\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Create a document with the provided object values. This will fail the write\r\n     * if a document exists at its location.\r\n     *\r\n     * @param {DocumentData} data An object that contains the fields and data to\r\n     * serialize as the document.\r\n     * @throws {Error} If the provided input is not a valid Firestore document or if the document already exists.\r\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\r\n     * write time of this create.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.collection('col').doc();\r\n     *\r\n     * documentRef.create({foo: 'bar'}).then((res) => {\r\n     *   console.log(`Document created at ${res.updateTime}`);\r\n     * }).catch((err) => {\r\n     *   console.log(`Failed to create document: ${err}`);\r\n     * });\r\n     * ```\r\n     */\r\n    create(data) {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_CREATE, () => {\r\n            const writeBatch = new index_1.WriteBatch(this._firestore);\r\n            return writeBatch\r\n                .create(this, data)\r\n                .commit()\r\n                .then(([writeResult]) => writeResult);\r\n        });\r\n    }\r\n    /**\r\n     * Deletes the document referred to by this `DocumentReference`.\r\n     *\r\n     * A delete for a non-existing document is treated as a success (unless\r\n     * lastUptimeTime is provided).\r\n     *\r\n     * @param {Precondition=} precondition A precondition to enforce for this\r\n     * delete.\r\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n     * document was last updated at lastUpdateTime. Fails the delete if the\r\n     * document was last updated at a different time.\r\n     * @param {boolean=} precondition.exists If set, enforces that the target\r\n     * document must or must not exist.\r\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\r\n     * delete time.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.delete().then(() => {\r\n     *   console.log('Document successfully deleted.');\r\n     * });\r\n     * ```\r\n     */\r\n    delete(precondition) {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_DELETE, () => {\r\n            const writeBatch = new index_1.WriteBatch(this._firestore);\r\n            return writeBatch\r\n                .delete(this, precondition)\r\n                .commit()\r\n                .then(([writeResult]) => writeResult);\r\n        });\r\n    }\r\n    /**\r\n     * Writes to the document referred to by this DocumentReference. If the\r\n     * document does not yet exist, it will be created. If you pass\r\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into an\r\n     * existing document.\r\n     *\r\n     * @param {T|Partial<AppModelType>} data A map of the fields and values for\r\n     * the document.\r\n     * @param {SetOptions=} options An object to configure the set behavior.\r\n     * @param {boolean=} options.merge If true, set() merges the values specified\r\n     * in its data argument. Fields omitted from this set() call remain untouched.\r\n     * If your input sets any field to an empty map, all nested fields are\r\n     * overwritten.\r\n     * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\r\n     * set() only replaces the specified field paths. Any field path that is not\r\n     * specified is ignored and remains untouched. If your input sets any field to\r\n     * an empty map, all nested fields are overwritten.\r\n     * @throws {Error} If the provided input is not a valid Firestore document.\r\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\r\n     * write time of this set.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.set({foo: 'bar'}).then(res => {\r\n     *   console.log(`Document written at ${res.updateTime}`);\r\n     * });\r\n     * ```\r\n     */\r\n    set(data, options) {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_SET, () => {\r\n            let writeBatch = new index_1.WriteBatch(this._firestore);\r\n            if (options) {\r\n                writeBatch = writeBatch.set(this, data, options);\r\n            }\r\n            else {\r\n                writeBatch = writeBatch.set(this, data);\r\n            }\r\n            return writeBatch.commit().then(([writeResult]) => writeResult);\r\n        });\r\n    }\r\n    /**\r\n     * Updates fields in the document referred to by this DocumentReference.\r\n     * If the document doesn't yet exist, the update fails and the returned\r\n     * Promise will be rejected.\r\n     *\r\n     * The update() method accepts either an object with field paths encoded as\r\n     * keys and field values encoded as values, or a variable number of arguments\r\n     * that alternate between field paths and field values.\r\n     *\r\n     * A Precondition restricting this update can be specified as the last\r\n     * argument.\r\n     *\r\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\r\n     * fields and values with which to update the document or the path of the\r\n     * first field to update.\r\n     * @param {\r\n     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\r\n     * list of field paths and values to update or a Precondition to restrict\r\n     * this update.\r\n     * @throws {Error} If the provided input is not valid Firestore data.\r\n     * @returns {Promise.<WriteResult>} A Promise that resolves once the\r\n     * data has been successfully written to the backend.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.update({foo: 'bar'}).then(res => {\r\n     *   console.log(`Document updated at ${res.updateTime}`);\r\n     * });\r\n     * ```\r\n     */\r\n    update(dataOrField, ...preconditionOrValues) {\r\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_UPDATE, () => {\r\n            // eslint-disable-next-line prefer-rest-params\r\n            (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);\r\n            const writeBatch = new index_1.WriteBatch(this._firestore);\r\n            return writeBatch\r\n                .update(this, dataOrField, ...preconditionOrValues)\r\n                .commit()\r\n                .then(([writeResult]) => writeResult);\r\n        });\r\n    }\r\n    /**\r\n     * Attaches a listener for DocumentSnapshot events.\r\n     *\r\n     * @param {documentSnapshotCallback} onNext A callback to be called every\r\n     * time a new `DocumentSnapshot` is available.\r\n     * @param {errorCallback=} onError A callback to be called if the listen fails\r\n     * or is cancelled. No further callbacks will occur. If unset, errors will be\r\n     * logged to the console.\r\n     *\r\n     * @returns {function()} An unsubscribe function that can be called to cancel\r\n     * the snapshot listener.\r\n     *\r\n     * @example\r\n     * ```\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\r\n     *   if (documentSnapshot.exists) {\r\n     *     console.log(documentSnapshot.data());\r\n     *   }\r\n     * }, err => {\r\n     *   console.log(`Encountered error: ${err}`);\r\n     * });\r\n     *\r\n     * // Remove this listener.\r\n     * unsubscribe();\r\n     * ```\r\n     */\r\n    onSnapshot(onNext, onError) {\r\n        (0, validate_1.validateFunction)('onNext', onNext);\r\n        (0, validate_1.validateFunction)('onError', onError, { optional: true });\r\n        const watch = new (require('../watch').DocumentWatch)(this.firestore, this);\r\n        return watch.onSnapshot((readTime, size, docs) => {\r\n            for (const document of docs()) {\r\n                if (document.ref.path === this.path) {\r\n                    onNext(document);\r\n                    return;\r\n                }\r\n            }\r\n            // The document is missing.\r\n            const ref = new DocumentReference(this._firestore, this._path, this._converter);\r\n            const document = new document_1.DocumentSnapshotBuilder(ref);\r\n            document.readTime = readTime;\r\n            onNext(document.build());\r\n        }, onError || console.error);\r\n    }\r\n    /**\r\n     * Returns true if this `DocumentReference` is equal to the provided value.\r\n     *\r\n     * @param {*} other The value to compare against.\r\n     * @return {boolean} true if this `DocumentReference` is equal to the provided\r\n     * value.\r\n     */\r\n    isEqual(other) {\r\n        return (this === other ||\r\n            (other instanceof DocumentReference &&\r\n                this._firestore === other._firestore &&\r\n                this._path.isEqual(other._path) &&\r\n                this._converter === other._converter));\r\n    }\r\n    /**\r\n     * Converts this DocumentReference to the Firestore Proto representation.\r\n     *\r\n     * @private\r\n     * @internal\r\n     */\r\n    toProto() {\r\n        return { referenceValue: this.formattedName };\r\n    }\r\n    /**\r\n     * Applies a custom data converter to this DocumentReference, allowing you to\r\n     * use your own custom model objects with Firestore. When you call set(),\r\n     * get(), etc. on the returned DocumentReference instance, the provided\r\n     * converter will convert between Firestore data of type `NewDbModelType` and\r\n     * your custom type `NewAppModelType`.\r\n     *\r\n     * Using the converter allows you to specify generic type arguments when\r\n     * storing and retrieving objects from Firestore.\r\n     *\r\n     * Passing in `null` as the converter parameter removes the current\r\n     * converter.\r\n     *\r\n     * @example\r\n     * ```\r\n     * class Post {\r\n     *   constructor(readonly title: string, readonly author: string) {}\r\n     *\r\n     *   toString(): string {\r\n     *     return this.title + ', by ' + this.author;\r\n     *   }\r\n     * }\r\n     *\r\n     * const postConverter = {\r\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\r\n     *     return {title: post.title, author: post.author};\r\n     *   },\r\n     *   fromFirestore(\r\n     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\r\n     *   ): Post {\r\n     *     const data = snapshot.data();\r\n     *     return new Post(data.title, data.author);\r\n     *   }\r\n     * };\r\n     *\r\n     * const postSnap = await Firestore()\r\n     *   .collection('posts')\r\n     *   .withConverter(postConverter)\r\n     *   .doc().get();\r\n     * const post = postSnap.data();\r\n     * if (post !== undefined) {\r\n     *   post.title; // string\r\n     *   post.toString(); // Should be defined\r\n     *   post.someNonExistentProperty; // TS error\r\n     * }\r\n     *\r\n     * ```\r\n     * @param {FirestoreDataConverter | null} converter Converts objects to and\r\n     * from Firestore. Passing in `null` removes the current converter.\r\n     * @return A DocumentReference that uses the provided converter.\r\n     */\r\n    withConverter(converter) {\r\n        return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\r\n    }\r\n}\r\nexports.DocumentReference = DocumentReference;\r\n//# sourceMappingURL=document-reference.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,iBAAiB,GAAG,KAAK,CAAC;AAClC,MAAMC,OAAO,GAAGC,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMC,MAAM,GAAGD,OAAO,CAAC,SAAS,CAAC;AACjC,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMG,sBAAsB,GAAGH,OAAO,CAAC,wBAAwB,CAAC;AAChE,MAAMI,MAAM,GAAGJ,OAAO,CAAC,SAAS,CAAC;AACjC,MAAMK,UAAU,GAAGL,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMM,UAAU,GAAGN,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMO,YAAY,GAAGP,OAAO,CAAC,yBAAyB,CAAC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMF,iBAAiB,CAAC;EACpB;AACJ;AACA;AACA;AACA;AACA;AACA;EACIU,WAAWA,CAACC,UAAU;EACtB;AACJ;AACA;AACA;EACIC,KAAK;EACL;AACJ;AACA;AACA;EACIC,UAAU,GAAG,CAAC,CAAC,EAAET,OAAO,CAACU,gBAAgB,EAAE,CAAC,EAAE;IAC1C,IAAI,CAACH,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,UAAU,GAAGA,UAAU;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIE,aAAaA,CAAA,EAAG;IAChB,MAAMC,SAAS,GAAG,IAAI,CAACC,SAAS,CAACD,SAAS;IAC1C,MAAME,UAAU,GAAG,IAAI,CAACD,SAAS,CAACC,UAAU;IAC5C,OAAO,IAAI,CAACN,KAAK,CAACO,uBAAuB,CAACH,SAAS,EAAEE,UAAU,CAAC,CAC3DH,aAAa;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIE,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACN,UAAU;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIS,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACR,KAAK,CAACS,YAAY;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,EAAEA,CAAA,EAAG;IACL,OAAO,IAAI,CAACV,KAAK,CAACU,EAAE;EACxB;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIC,aAAaA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACX,KAAK;EACrB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIY,MAAMA,CAAA,EAAG;IACT,OAAO,IAAInB,sBAAsB,CAACoB,mBAAmB,CAAC,IAAI,CAACd,UAAU,EAAE,IAAI,CAACC,KAAK,CAACY,MAAM,CAAC,CAAC,EAAE,IAAI,CAACX,UAAU,CAAC;EAChH;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIa,GAAGA,CAAA,EAAG;IACF,OAAO,IAAI,CAACf,UAAU,CAACgB,UAAU,CAACC,eAAe,CAACnB,YAAY,CAACoB,qBAAqB,EAAE,MAAM;MACxF,OAAO,IAAI,CAAClB,UAAU,CAACmB,MAAM,CAAC,IAAI,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,MAAM,CAAC,KAAKA,MAAM,CAAC;IAClE,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,UAAUA,CAACC,cAAc,EAAE;IACvB,CAAC,CAAC,EAAE/B,MAAM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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}