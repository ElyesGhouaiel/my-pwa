{"ast":null,"code":"/*! firebase-admin v13.0.1 */\n\"use strict\";\n\n/*!\r\n * Copyright 2021 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseAuth = void 0;\nexports.createFirebaseTokenGenerator = createFirebaseTokenGenerator;\nconst error_1 = require(\"../utils/error\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst validator = require(\"../utils/validator\");\nconst auth_api_request_1 = require(\"./auth-api-request\");\nconst token_generator_1 = require(\"./token-generator\");\nconst token_verifier_1 = require(\"./token-verifier\");\nconst auth_config_1 = require(\"./auth-config\");\nconst user_record_1 = require(\"./user-record\");\nconst identifier_1 = require(\"./identifier\");\nconst crypto_signer_1 = require(\"../utils/crypto-signer\");\n/**\r\n * @internal\r\n */\nfunction createFirebaseTokenGenerator(app, tenantId) {\n  try {\n    const signer = (0, auth_api_request_1.useEmulator)() ? new token_generator_1.EmulatedSigner() : (0, crypto_signer_1.cryptoSignerFromApp)(app);\n    return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);\n  } catch (err) {\n    throw (0, token_generator_1.handleCryptoSignerError)(err);\n  }\n}\n/**\r\n * Common parent interface for both `Auth` and `TenantAwareAuth` APIs.\r\n */\nclass BaseAuth {\n  /**\r\n   * The BaseAuth class constructor.\r\n   *\r\n   * @param app - The FirebaseApp to associate with this Auth instance.\r\n   * @param authRequestHandler - The RPC request handler for this instance.\r\n   * @param tokenGenerator - Optional token generator. If not specified, a\r\n   *     (non-tenant-aware) instance will be created. Use this paramter to\r\n   *     specify a tenant-aware tokenGenerator.\r\n   * @constructor\r\n   * @internal\r\n   */\n  constructor(app, /** @internal */authRequestHandler, tokenGenerator) {\n    this.authRequestHandler = authRequestHandler;\n    if (tokenGenerator) {\n      this.tokenGenerator = tokenGenerator;\n    } else {\n      this.tokenGenerator = createFirebaseTokenGenerator(app);\n    }\n    this.sessionCookieVerifier = (0, token_verifier_1.createSessionCookieVerifier)(app);\n    this.idTokenVerifier = (0, token_verifier_1.createIdTokenVerifier)(app);\n    this.authBlockingTokenVerifier = (0, token_verifier_1.createAuthBlockingTokenVerifier)(app);\n  }\n  /**\r\n   * Creates a new Firebase custom token (JWT) that can be sent back to a client\r\n   * device to use to sign in with the client SDKs' `signInWithCustomToken()`\r\n   * methods. (Tenant-aware instances will also embed the tenant ID in the\r\n   * token.)\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/create-custom-tokens | Create Custom Tokens}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param uid - The `uid` to use as the custom token's subject.\r\n   * @param developerClaims - Optional additional claims to include\r\n   *   in the custom token's payload.\r\n   *\r\n   * @returns A promise fulfilled with a custom token for the\r\n   *   provided `uid` and payload.\r\n   */\n  createCustomToken(uid, developerClaims) {\n    return this.tokenGenerator.createCustomToken(uid, developerClaims);\n  }\n  /**\r\n   * Verifies a Firebase ID token (JWT). If the token is valid, the promise is\r\n   * fulfilled with the token's decoded claims; otherwise, the promise is\r\n   * rejected.\r\n   *\r\n   * If `checkRevoked` is set to true, first verifies whether the corresponding\r\n   * user is disabled. If yes, an `auth/user-disabled` error is thrown. If no,\r\n   * verifies if the session corresponding to the ID token was revoked. If the\r\n   * corresponding user's session was invalidated, an `auth/id-token-revoked`\r\n   * error is thrown. If not specified the check is not applied.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/verify-id-tokens | Verify ID Tokens}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param idToken - The ID token to verify.\r\n   * @param checkRevoked - Whether to check if the ID token was revoked.\r\n   *   This requires an extra request to the Firebase Auth backend to check\r\n   *   the `tokensValidAfterTime` time for the corresponding user.\r\n   *   When not specified, this additional check is not applied.\r\n   *\r\n   * @returns A promise fulfilled with the\r\n   *   token's decoded claims if the ID token is valid; otherwise, a rejected\r\n   *   promise.\r\n   */\n  verifyIdToken(idToken, checkRevoked = false) {\n    const isEmulator = (0, auth_api_request_1.useEmulator)();\n    return this.idTokenVerifier.verifyJWT(idToken, isEmulator).then(decodedIdToken => {\n      // Whether to check if the token was revoked.\n      if (checkRevoked || isEmulator) {\n        return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n      }\n      return decodedIdToken;\n    });\n  }\n  /**\r\n   * Gets the user data for the user corresponding to a given `uid`.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param uid - The `uid` corresponding to the user whose data to fetch.\r\n   *\r\n   * @returns A promise fulfilled with the user\r\n   *   data corresponding to the provided `uid`.\r\n   */\n  getUser(uid) {\n    return this.authRequestHandler.getAccountInfoByUid(uid).then(response => {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  }\n  /**\r\n   * Gets the user data for the user corresponding to a given email.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param email - The email corresponding to the user whose data to\r\n   *   fetch.\r\n   *\r\n   * @returns A promise fulfilled with the user\r\n   *   data corresponding to the provided email.\r\n   */\n  getUserByEmail(email) {\n    return this.authRequestHandler.getAccountInfoByEmail(email).then(response => {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  }\n  /**\r\n   * Gets the user data for the user corresponding to a given phone number. The\r\n   * phone number has to conform to the E.164 specification.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param phoneNumber - The phone number corresponding to the user whose\r\n   *   data to fetch.\r\n   *\r\n   * @returns A promise fulfilled with the user\r\n   *   data corresponding to the provided phone number.\r\n   */\n  getUserByPhoneNumber(phoneNumber) {\n    return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber).then(response => {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  }\n  /**\r\n   * Gets the user data for the user corresponding to a given provider id.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param providerId - The provider ID, for example, \"google.com\" for the\r\n   *   Google provider.\r\n   * @param uid - The user identifier for the given provider.\r\n   *\r\n   * @returns A promise fulfilled with the user data corresponding to the\r\n   *   given provider id.\r\n   */\n  getUserByProviderUid(providerId, uid) {\n    // Although we don't really advertise it, we want to also handle\n    // non-federated idps with this call. So if we detect one of them, we'll\n    // reroute this request appropriately.\n    if (providerId === 'phone') {\n      return this.getUserByPhoneNumber(uid);\n    } else if (providerId === 'email') {\n      return this.getUserByEmail(uid);\n    }\n    return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid).then(response => {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  }\n  /**\r\n   * Gets the user data corresponding to the specified identifiers.\r\n   *\r\n   * There are no ordering guarantees; in particular, the nth entry in the result list is not\r\n   * guaranteed to correspond to the nth entry in the input parameters list.\r\n   *\r\n   * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,\r\n   * this method throws a FirebaseAuthError.\r\n   *\r\n   * @param identifiers - The identifiers used to indicate which user records should be returned.\r\n   *     Must not have more than 100 entries.\r\n   * @returns A promise that resolves to the corresponding user records.\r\n   * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100\r\n   *     identifiers are specified.\r\n   */\n  getUsers(identifiers) {\n    if (!validator.isArray(identifiers)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');\n    }\n    return this.authRequestHandler.getAccountInfoByIdentifiers(identifiers).then(response => {\n      /**\r\n       * Checks if the specified identifier is within the list of\r\n       * UserRecords.\r\n       */\n      const isUserFound = (id, userRecords) => {\n        return !!userRecords.find(userRecord => {\n          if ((0, identifier_1.isUidIdentifier)(id)) {\n            return id.uid === userRecord.uid;\n          } else if ((0, identifier_1.isEmailIdentifier)(id)) {\n            return id.email === userRecord.email;\n          } else if ((0, identifier_1.isPhoneIdentifier)(id)) {\n            return id.phoneNumber === userRecord.phoneNumber;\n          } else if ((0, identifier_1.isProviderIdentifier)(id)) {\n            const matchingUserInfo = userRecord.providerData.find(userInfo => {\n              return id.providerId === userInfo.providerId;\n            });\n            return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;\n          } else {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');\n          }\n        });\n      };\n      const users = response.users ? response.users.map(user => new user_record_1.UserRecord(user)) : [];\n      const notFound = identifiers.filter(id => !isUserFound(id, users));\n      return {\n        users,\n        notFound\n      };\n    });\n  }\n  /**\r\n   * Retrieves a list of users (single batch only) with a size of `maxResults`\r\n   * starting from the offset as specified by `pageToken`. This is used to\r\n   * retrieve all the users of a specified project in batches.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#list_all_users | List all users}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param maxResults - The page size, 1000 if undefined. This is also\r\n   *   the maximum allowed limit.\r\n   * @param pageToken - The next page token. If not specified, returns\r\n   *   users starting without any offset.\r\n   * @returns A promise that resolves with\r\n   *   the current batch of downloaded users and the next page token.\r\n   */\n  listUsers(maxResults, pageToken) {\n    return this.authRequestHandler.downloadAccount(maxResults, pageToken).then(response => {\n      // List of users to return.\n      const users = [];\n      // Convert each user response to a UserRecord.\n      response.users.forEach(userResponse => {\n        users.push(new user_record_1.UserRecord(userResponse));\n      });\n      // Return list of user records and the next page token if available.\n      const result = {\n        users,\n        pageToken: response.nextPageToken\n      };\n      // Delete result.pageToken if undefined.\n      if (typeof result.pageToken === 'undefined') {\n        delete result.pageToken;\n      }\n      return result;\n    });\n  }\n  /**\r\n   * Creates a new user.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#create_a_user | Create a user}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param properties - The properties to set on the\r\n   *   new user record to be created.\r\n   *\r\n   * @returns A promise fulfilled with the user\r\n   *   data corresponding to the newly created user.\r\n   */\n  createUser(properties) {\n    return this.authRequestHandler.createNewAccount(properties).then(uid => {\n      // Return the corresponding user record.\n      return this.getUser(uid);\n    }).catch(error => {\n      if (error.code === 'auth/user-not-found') {\n        // Something must have happened after creating the user and then retrieving it.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n      }\n      throw error;\n    });\n  }\n  /**\r\n   * Deletes an existing user.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#delete_a_user | Delete a user}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param uid - The `uid` corresponding to the user to delete.\r\n   *\r\n   * @returns An empty promise fulfilled once the user has been\r\n   *   deleted.\r\n   */\n  deleteUser(uid) {\n    return this.authRequestHandler.deleteAccount(uid).then(() => {\n      // Return nothing on success.\n    });\n  }\n  /**\r\n   * Deletes the users specified by the given uids.\r\n   *\r\n   * Deleting a non-existing user won't generate an error (i.e. this method\r\n   * is idempotent.) Non-existing users are considered to be successfully\r\n   * deleted, and are therefore counted in the\r\n   * `DeleteUsersResult.successCount` value.\r\n   *\r\n   * Only a maximum of 1000 identifiers may be supplied. If more than 1000\r\n   * identifiers are supplied, this method throws a FirebaseAuthError.\r\n   *\r\n   * This API is currently rate limited at the server to 1 QPS. If you exceed\r\n   * this, you may get a quota exceeded error. Therefore, if you want to\r\n   * delete more than 1000 users, you may need to add a delay to ensure you\r\n   * don't go over this limit.\r\n   *\r\n   * @param uids - The `uids` corresponding to the users to delete.\r\n   *\r\n   * @returns A Promise that resolves to the total number of successful/failed\r\n   *     deletions, as well as the array of errors that corresponds to the\r\n   *     failed deletions.\r\n   */\n  deleteUsers(uids) {\n    if (!validator.isArray(uids)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');\n    }\n    return this.authRequestHandler.deleteAccounts(uids, /*force=*/true).then(batchDeleteAccountsResponse => {\n      const result = {\n        failureCount: 0,\n        successCount: uids.length,\n        errors: []\n      };\n      if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {\n        return result;\n      }\n      result.failureCount = batchDeleteAccountsResponse.errors.length;\n      result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;\n      result.errors = batchDeleteAccountsResponse.errors.map(batchDeleteErrorInfo => {\n        if (batchDeleteErrorInfo.index === undefined) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');\n        }\n        const errMsgToError = msg => {\n          // We unconditionally set force=true, so the 'NOT_DISABLED' error\n          // should not be possible.\n          const code = msg && msg.startsWith('NOT_DISABLED') ? error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;\n          return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);\n        };\n        return {\n          index: batchDeleteErrorInfo.index,\n          error: errMsgToError(batchDeleteErrorInfo.message)\n        };\n      });\n      return result;\n    });\n  }\n  /**\r\n   * Updates an existing user.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#update_a_user | Update a user}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param uid - The `uid` corresponding to the user to update.\r\n   * @param properties - The properties to update on\r\n   *   the provided user.\r\n   *\r\n   * @returns A promise fulfilled with the\r\n   *   updated user data.\r\n   */\n  updateUser(uid, properties) {\n    // Although we don't really advertise it, we want to also handle linking of\n    // non-federated idps with this call. So if we detect one of them, we'll\n    // adjust the properties parameter appropriately. This *does* imply that a\n    // conflict could arise, e.g. if the user provides a phoneNumber property,\n    // but also provides a providerToLink with a 'phone' provider id. In that\n    // case, we'll throw an error.\n    properties = (0, deep_copy_1.deepCopy)(properties);\n    if (properties?.providerToLink) {\n      if (properties.providerToLink.providerId === 'email') {\n        if (typeof properties.email !== 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To \" + 'link to the email/password provider, only specify the UpdateRequest.email field.');\n        }\n        properties.email = properties.providerToLink.uid;\n        delete properties.providerToLink;\n      } else if (properties.providerToLink.providerId === 'phone') {\n        if (typeof properties.phoneNumber !== 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To \" + 'link to a phone provider, only specify the UpdateRequest.phoneNumber field.');\n        }\n        properties.phoneNumber = properties.providerToLink.uid;\n        delete properties.providerToLink;\n      }\n    }\n    if (properties?.providersToUnlink) {\n      if (properties.providersToUnlink.indexOf('phone') !== -1) {\n        // If we've been told to unlink the phone provider both via setting\n        // phoneNumber to null *and* by setting providersToUnlink to include\n        // 'phone', then we'll reject that. Though it might also be reasonable\n        // to relax this restriction and just unlink it.\n        if (properties.phoneNumber === null) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To \" + 'unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.');\n        }\n      }\n    }\n    return this.authRequestHandler.updateExistingAccount(uid, properties).then(existingUid => {\n      // Return the corresponding user record.\n      return this.getUser(existingUid);\n    });\n  }\n  /**\r\n   * Sets additional developer claims on an existing user identified by the\r\n   * provided `uid`, typically used to define user roles and levels of\r\n   * access. These claims should propagate to all devices where the user is\r\n   * already signed in (after token expiration or when token refresh is forced)\r\n   * and the next time the user signs in. If a reserved OIDC claim name\r\n   * is used (sub, iat, iss, etc), an error is thrown. They are set on the\r\n   * authenticated user's ID token JWT.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/custom-claims |\r\n   * Defining user roles and access levels}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param uid - The `uid` of the user to edit.\r\n   * @param customUserClaims - The developer claims to set. If null is\r\n   *   passed, existing custom claims are deleted. Passing a custom claims payload\r\n   *   larger than 1000 bytes will throw an error. Custom claims are added to the\r\n   *   user's ID token which is transmitted on every authenticated request.\r\n   *   For profile non-access related user attributes, use database or other\r\n   *   separate storage systems.\r\n   * @returns A promise that resolves when the operation completes\r\n   *   successfully.\r\n   */\n  setCustomUserClaims(uid, customUserClaims) {\n    return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims).then(() => {\n      // Return nothing on success.\n    });\n  }\n  /**\r\n   * Revokes all refresh tokens for an existing user.\r\n   *\r\n   * This API will update the user's {@link UserRecord.tokensValidAfterTime} to\r\n   * the current UTC. It is important that the server on which this is called has\r\n   * its clock set correctly and synchronized.\r\n   *\r\n   * While this will revoke all sessions for a specified user and disable any\r\n   * new ID tokens for existing sessions from getting minted, existing ID tokens\r\n   * may remain active until their natural expiration (one hour). To verify that\r\n   * ID tokens are revoked, use {@link BaseAuth.verifyIdToken}\r\n   * where `checkRevoked` is set to true.\r\n   *\r\n   * @param uid - The `uid` corresponding to the user whose refresh tokens\r\n   *   are to be revoked.\r\n   *\r\n   * @returns An empty promise fulfilled once the user's refresh\r\n   *   tokens have been revoked.\r\n   */\n  revokeRefreshTokens(uid) {\n    return this.authRequestHandler.revokeRefreshTokens(uid).then(() => {\n      // Return nothing on success.\n    });\n  }\n  /**\r\n   * Imports the provided list of users into Firebase Auth.\r\n   * A maximum of 1000 users are allowed to be imported one at a time.\r\n   * When importing users with passwords,\r\n   * {@link UserImportOptions} are required to be\r\n   * specified.\r\n   * This operation is optimized for bulk imports and will ignore checks on `uid`,\r\n   * `email` and other identifier uniqueness which could result in duplications.\r\n   *\r\n   * @param users - The list of user records to import to Firebase Auth.\r\n   * @param options - The user import options, required when the users provided include\r\n   *   password credentials.\r\n   * @returns A promise that resolves when\r\n   *   the operation completes with the result of the import. This includes the\r\n   *   number of successful imports, the number of failed imports and their\r\n   *   corresponding errors.\r\n  */\n  importUsers(users, options) {\n    return this.authRequestHandler.uploadAccount(users, options);\n  }\n  /**\r\n   * Creates a new Firebase session cookie with the specified options. The created\r\n   * JWT string can be set as a server-side session cookie with a custom cookie\r\n   * policy, and be used for session management. The session cookie JWT will have\r\n   * the same payload claims as the provided ID token.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies | Manage Session Cookies}\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param idToken - The Firebase ID token to exchange for a session\r\n   *   cookie.\r\n   * @param sessionCookieOptions - The session\r\n   *   cookie options which includes custom session duration.\r\n   *\r\n   * @returns A promise that resolves on success with the\r\n   *   created session cookie.\r\n   */\n  createSessionCookie(idToken, sessionCookieOptions) {\n    // Return rejected promise if expiresIn is not available.\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    }\n    return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n  }\n  /**\r\n   * Verifies a Firebase session cookie. Returns a Promise with the cookie claims.\r\n   * Rejects the promise if the cookie could not be verified.\r\n   *\r\n   * If `checkRevoked` is set to true, first verifies whether the corresponding\r\n   * user is disabled: If yes, an `auth/user-disabled` error is thrown. If no,\r\n   * verifies if the session corresponding to the session cookie was revoked.\r\n   * If the corresponding user's session was invalidated, an\r\n   * `auth/session-cookie-revoked` error is thrown. If not specified the check\r\n   * is not performed.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies#verify_session_cookie_and_check_permissions |\r\n   * Verify Session Cookies}\r\n   * for code samples and detailed documentation\r\n   *\r\n   * @param sessionCookie - The session cookie to verify.\r\n   * @param checkForRevocation -  Whether to check if the session cookie was\r\n   *   revoked. This requires an extra request to the Firebase Auth backend to\r\n   *   check the `tokensValidAfterTime` time for the corresponding user.\r\n   *   When not specified, this additional check is not performed.\r\n   *\r\n   * @returns A promise fulfilled with the\r\n   *   session cookie's decoded claims if the session cookie is valid; otherwise,\r\n   *   a rejected promise.\r\n   */\n  verifySessionCookie(sessionCookie, checkRevoked = false) {\n    const isEmulator = (0, auth_api_request_1.useEmulator)();\n    return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator).then(decodedIdToken => {\n      // Whether to check if the token was revoked.\n      if (checkRevoked || isEmulator) {\n        return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n      }\n      return decodedIdToken;\n    });\n  }\n  /**\r\n   * Generates the out of band email action link to reset a user's password.\r\n   * The link is generated for the user with the specified email address. The\r\n   * optional  {@link ActionCodeSettings} object\r\n   * defines whether the link is to be handled by a mobile app or browser and the\r\n   * additional state information to be passed in the deep link, etc.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * var actionCodeSettings = {\r\n   *   url: 'https://www.example.com/?email=user@example.com',\r\n   *   iOS: {\r\n   *     bundleId: 'com.example.ios'\r\n   *   },\r\n   *   android: {\r\n   *     packageName: 'com.example.android',\r\n   *     installApp: true,\r\n   *     minimumVersion: '12'\r\n   *   },\r\n   *   handleCodeInApp: true,\r\n   *   dynamicLinkDomain: 'custom.page.link'\r\n   * };\r\n   * admin.auth()\r\n   *     .generatePasswordResetLink('user@example.com', actionCodeSettings)\r\n   *     .then(function(link) {\r\n   *       // The link was successfully generated.\r\n   *     })\r\n   *     .catch(function(error) {\r\n   *       // Some error occurred, you can inspect the code: error.code\r\n   *     });\r\n   * ```\r\n   *\r\n   * @param email - The email address of the user whose password is to be\r\n   *   reset.\r\n   * @param actionCodeSettings - The action\r\n   *     code settings. If specified, the state/continue URL is set as the\r\n   *     \"continueUrl\" parameter in the password reset link. The default password\r\n   *     reset landing page will use this to display a link to go back to the app\r\n   *     if it is installed.\r\n   *     If the actionCodeSettings is not specified, no URL is appended to the\r\n   *     action URL.\r\n   *     The state URL provided must belong to a domain that is whitelisted by the\r\n   *     developer in the console. Otherwise an error is thrown.\r\n   *     Mobile app redirects are only applicable if the developer configures\r\n   *     and accepts the Firebase Dynamic Links terms of service.\r\n   *     The Android package name and iOS bundle ID are respected only if they\r\n   *     are configured in the same Firebase Auth project.\r\n   * @returns A promise that resolves with the generated link.\r\n   */\n  generatePasswordResetLink(email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n  }\n  /**\r\n   * Generates the out of band email action link to verify the user's ownership\r\n   * of the specified email. The {@link ActionCodeSettings} object provided\r\n   * as an argument to this method defines whether the link is to be handled by a\r\n   * mobile app or browser along with additional state information to be passed in\r\n   * the deep link, etc.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * var actionCodeSettings = {\r\n   *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\r\n   *   iOS: {\r\n   *     bundleId: 'com.example.ios'\r\n   *   },\r\n   *   android: {\r\n   *     packageName: 'com.example.android',\r\n   *     installApp: true,\r\n   *     minimumVersion: '12'\r\n   *   },\r\n   *   handleCodeInApp: true,\r\n   *   dynamicLinkDomain: 'custom.page.link'\r\n   * };\r\n   * admin.auth()\r\n   *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\r\n   *     .then(function(link) {\r\n   *       // The link was successfully generated.\r\n   *     })\r\n   *     .catch(function(error) {\r\n   *       // Some error occurred, you can inspect the code: error.code\r\n   *     });\r\n   * ```\r\n   *\r\n   * @param email - The email account to verify.\r\n   * @param actionCodeSettings - The action\r\n   *     code settings. If specified, the state/continue URL is set as the\r\n   *     \"continueUrl\" parameter in the email verification link. The default email\r\n   *     verification landing page will use this to display a link to go back to\r\n   *     the app if it is installed.\r\n   *     If the actionCodeSettings is not specified, no URL is appended to the\r\n   *     action URL.\r\n   *     The state URL provided must belong to a domain that is whitelisted by the\r\n   *     developer in the console. Otherwise an error is thrown.\r\n   *     Mobile app redirects are only applicable if the developer configures\r\n   *     and accepts the Firebase Dynamic Links terms of service.\r\n   *     The Android package name and iOS bundle ID are respected only if they\r\n   *     are configured in the same Firebase Auth project.\r\n   * @returns A promise that resolves with the generated link.\r\n   */\n  generateEmailVerificationLink(email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n  }\n  /**\r\n   * Generates an out-of-band email action link to verify the user's ownership\r\n   * of the specified email. The {@link ActionCodeSettings} object provided\r\n   * as an argument to this method defines whether the link is to be handled by a\r\n   * mobile app or browser along with additional state information to be passed in\r\n   * the deep link, etc.\r\n   *\r\n   * @param email - The current email account.\r\n   * @param newEmail - The email address the account is being updated to.\r\n   * @param actionCodeSettings - The action\r\n   *     code settings. If specified, the state/continue URL is set as the\r\n   *     \"continueUrl\" parameter in the email verification link. The default email\r\n   *     verification landing page will use this to display a link to go back to\r\n   *     the app if it is installed.\r\n   *     If the actionCodeSettings is not specified, no URL is appended to the\r\n   *     action URL.\r\n   *     The state URL provided must belong to a domain that is authorized\r\n   *     in the console, or an error will be thrown.\r\n   *     Mobile app redirects are only applicable if the developer configures\r\n   *     and accepts the Firebase Dynamic Links terms of service.\r\n   *     The Android package name and iOS bundle ID are respected only if they\r\n   *     are configured in the same Firebase Auth project.\r\n   * @returns A promise that resolves with the generated link.\r\n   */\n  generateVerifyAndChangeEmailLink(email, newEmail, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('VERIFY_AND_CHANGE_EMAIL', email, actionCodeSettings, newEmail);\n  }\n  /**\r\n   * Generates the out of band email action link to verify the user's ownership\r\n   * of the specified email. The {@link ActionCodeSettings} object provided\r\n   * as an argument to this method defines whether the link is to be handled by a\r\n   * mobile app or browser along with additional state information to be passed in\r\n   * the deep link, etc.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * var actionCodeSettings = {\r\n   *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\r\n   *   iOS: {\r\n   *     bundleId: 'com.example.ios'\r\n   *   },\r\n   *   android: {\r\n   *     packageName: 'com.example.android',\r\n   *     installApp: true,\r\n   *     minimumVersion: '12'\r\n   *   },\r\n   *   handleCodeInApp: true,\r\n   *   dynamicLinkDomain: 'custom.page.link'\r\n   * };\r\n   * admin.auth()\r\n   *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\r\n   *     .then(function(link) {\r\n   *       // The link was successfully generated.\r\n   *     })\r\n   *     .catch(function(error) {\r\n   *       // Some error occurred, you can inspect the code: error.code\r\n   *     });\r\n   * ```\r\n   *\r\n   * @param email - The email account to verify.\r\n   * @param actionCodeSettings - The action\r\n   *     code settings. If specified, the state/continue URL is set as the\r\n   *     \"continueUrl\" parameter in the email verification link. The default email\r\n   *     verification landing page will use this to display a link to go back to\r\n   *     the app if it is installed.\r\n   *     If the actionCodeSettings is not specified, no URL is appended to the\r\n   *     action URL.\r\n   *     The state URL provided must belong to a domain that is whitelisted by the\r\n   *     developer in the console. Otherwise an error is thrown.\r\n   *     Mobile app redirects are only applicable if the developer configures\r\n   *     and accepts the Firebase Dynamic Links terms of service.\r\n   *     The Android package name and iOS bundle ID are respected only if they\r\n   *     are configured in the same Firebase Auth project.\r\n   * @returns A promise that resolves with the generated link.\r\n   */\n  generateSignInWithEmailLink(email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n  }\n  /**\r\n   * Returns the list of existing provider configurations matching the filter\r\n   * provided. At most, 100 provider configs can be listed at a time.\r\n   *\r\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\r\n   * (GCIP). To learn more about GCIP, including pricing and features,\r\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\r\n   *\r\n   * @param options - The provider config filter to apply.\r\n   * @returns A promise that resolves with the list of provider configs meeting the\r\n   *   filter requirements.\r\n   */\n  listProviderConfigs(options) {\n    const processResponse = (response, providerConfigs) => {\n      // Return list of provider configuration and the next page token if available.\n      const result = {\n        providerConfigs\n      };\n      // Delete result.pageToken if undefined.\n      if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {\n        result.pageToken = response.nextPageToken;\n      }\n      return result;\n    };\n    if (options && options.type === 'oidc') {\n      return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken).then(response => {\n        // List of provider configurations to return.\n        const providerConfigs = [];\n        // Convert each provider config response to a OIDCConfig.\n        response.oauthIdpConfigs.forEach(configResponse => {\n          providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\n        });\n        // Return list of provider configuration and the next page token if available.\n        return processResponse(response, providerConfigs);\n      });\n    } else if (options && options.type === 'saml') {\n      return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken).then(response => {\n        // List of provider configurations to return.\n        const providerConfigs = [];\n        // Convert each provider config response to a SAMLConfig.\n        response.inboundSamlConfigs.forEach(configResponse => {\n          providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\n        });\n        // Return list of provider configuration and the next page token if available.\n        return processResponse(response, providerConfigs);\n      });\n    }\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"AuthProviderConfigFilter.type\" must be either \"saml\" or \"oidc\"'));\n  }\n  /**\r\n   * Looks up an Auth provider configuration by the provided ID.\r\n   * Returns a promise that resolves with the provider configuration\r\n   * corresponding to the provider ID specified. If the specified ID does not\r\n   * exist, an `auth/configuration-not-found` error is thrown.\r\n   *\r\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\r\n   * (GCIP). To learn more about GCIP, including pricing and features,\r\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\r\n   *\r\n   * @param providerId - The provider ID corresponding to the provider\r\n   *     config to return.\r\n   * @returns A promise that resolves\r\n   *     with the configuration corresponding to the provided ID.\r\n   */\n  getProviderConfig(providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getOAuthIdpConfig(providerId).then(response => {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getInboundSamlConfig(providerId).then(response => {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  }\n  /**\r\n   * Deletes the provider configuration corresponding to the provider ID passed.\r\n   * If the specified ID does not exist, an `auth/configuration-not-found` error\r\n   * is thrown.\r\n   *\r\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\r\n   * (GCIP). To learn more about GCIP, including pricing and features,\r\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\r\n   *\r\n   * @param providerId - The provider ID corresponding to the provider\r\n   *     config to delete.\r\n   * @returns A promise that resolves on completion.\r\n   */\n  deleteProviderConfig(providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteInboundSamlConfig(providerId);\n    }\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  }\n  /**\r\n   * Returns a promise that resolves with the updated `AuthProviderConfig`\r\n   * corresponding to the provider ID specified.\r\n   * If the specified ID does not exist, an `auth/configuration-not-found` error\r\n   * is thrown.\r\n   *\r\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\r\n   * (GCIP). To learn more about GCIP, including pricing and features,\r\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\r\n   *\r\n   * @param providerId - The provider ID corresponding to the provider\r\n   *     config to update.\r\n   * @param updatedConfig - The updated configuration.\r\n   * @returns A promise that resolves with the updated provider configuration.\r\n   */\n  updateProviderConfig(providerId, updatedConfig) {\n    if (!validator.isNonNullObject(updatedConfig)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\n    }\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig).then(response => {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig).then(response => {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  }\n  /**\r\n   * Returns a promise that resolves with the newly created `AuthProviderConfig`\r\n   * when the new provider configuration is created.\r\n   *\r\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\r\n   * (GCIP). To learn more about GCIP, including pricing and features,\r\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\r\n   *\r\n   * @param config - The provider configuration to create.\r\n   * @returns A promise that resolves with the created provider configuration.\r\n   */\n  createProviderConfig(config) {\n    if (!validator.isNonNullObject(config)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\n    }\n    if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createOAuthIdpConfig(config).then(response => {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createInboundSamlConfig(config).then(response => {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  }\n  /** @alpha */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  _verifyAuthBlockingToken(token, audience) {\n    const isEmulator = (0, auth_api_request_1.useEmulator)();\n    return this.authBlockingTokenVerifier._verifyAuthBlockingToken(token, isEmulator, audience).then(decodedAuthBlockingToken => {\n      return decodedAuthBlockingToken;\n    });\n  }\n  /**\r\n   * Verifies the decoded Firebase issued JWT is not revoked or disabled. Returns a promise that\r\n   * resolves with the decoded claims on success. Rejects the promise with revocation error if revoked\r\n   * or user disabled.\r\n   *\r\n   * @param decodedIdToken - The JWT's decoded claims.\r\n   * @param revocationErrorInfo - The revocation error info to throw on revocation\r\n   *     detection.\r\n   * @returns A promise that will be fulfilled after a successful verification.\r\n   */\n  verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, revocationErrorInfo) {\n    // Get tokens valid after time for the corresponding user.\n    return this.getUser(decodedIdToken.sub).then(user => {\n      if (user.disabled) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_DISABLED, 'The user record is disabled.');\n      }\n      // If no tokens valid after time available, token is not revoked.\n      if (user.tokensValidAfterTime) {\n        // Get the ID token authentication time and convert to milliseconds UTC.\n        const authTimeUtc = decodedIdToken.auth_time * 1000;\n        // Get user tokens valid after time in milliseconds UTC.\n        const validSinceUtc = new Date(user.tokensValidAfterTime).getTime();\n        // Check if authentication time is older than valid since time.\n        if (authTimeUtc < validSinceUtc) {\n          throw new error_1.FirebaseAuthError(revocationErrorInfo);\n        }\n      }\n      // All checks above passed. Return the decoded token.\n      return decodedIdToken;\n    });\n  }\n}\nexports.BaseAuth = BaseAuth;","map":{"version":3,"names":["Object","defineProperty","exports","value","BaseAuth","createFirebaseTokenGenerator","error_1","require","deep_copy_1","validator","auth_api_request_1","token_generator_1","token_verifier_1","auth_config_1","user_record_1","identifier_1","crypto_signer_1","app","tenantId","signer","useEmulator","EmulatedSigner","cryptoSignerFromApp","FirebaseTokenGenerator","err","handleCryptoSignerError","constructor","authRequestHandler","tokenGenerator","sessionCookieVerifier","createSessionCookieVerifier","idTokenVerifier","createIdTokenVerifier","authBlockingTokenVerifier","createAuthBlockingTokenVerifier","createCustomToken","uid","developerClaims","verifyIdToken","idToken","checkRevoked","isEmulator","verifyJWT","then","decodedIdToken","verifyDecodedJWTNotRevokedOrDisabled","AuthClientErrorCode","ID_TOKEN_REVOKED","getUser","getAccountInfoByUid","response","UserRecord","users","getUserByEmail","email","getAccountInfoByEmail","getUserByPhoneNumber","phoneNumber","getAccountInfoByPhoneNumber","getUserByProviderUid","providerId","getAccountInfoByFederatedUid","getUsers","identifiers","isArray","FirebaseAuthError","INVALID_ARGUMENT","getAccountInfoByIdentifiers","isUserFound","id","userRecords","find","userRecord","isUidIdentifier","isEmailIdentifier","isPhoneIdentifier","isProviderIdentifier","matchingUserInfo","providerData","userInfo","providerUid","INTERNAL_ERROR","map","user","notFound","filter","listUsers","maxResults","pageToken","downloadAccount","forEach","userResponse","push","result","nextPageToken","createUser","properties","createNewAccount","catch","error","code","deleteUser","deleteAccount","deleteUsers","uids","deleteAccounts","batchDeleteAccountsResponse","failureCount","successCount","length","errors","isNonEmptyArray","batchDeleteErrorInfo","index","undefined","errMsgToError","msg","startsWith","USER_NOT_DISABLED","message","updateUser","deepCopy","providerToLink","providersToUnlink","indexOf","updateExistingAccount","existingUid","setCustomUserClaims","customUserClaims","revokeRefreshTokens","importUsers","options","uploadAccount","createSessionCookie","sessionCookieOptions","isNonNullObject","isNumber","expiresIn","Promise","reject","INVALID_SESSION_COOKIE_DURATION","verifySessionCookie","sessionCookie","SESSION_COOKIE_REVOKED","generatePasswordResetLink","actionCodeSettings","getEmailActionLink","generateEmailVerificationLink","generateVerifyAndChangeEmailLink","newEmail","generateSignInWithEmailLink","listProviderConfigs","processResponse","providerConfigs","prototype","hasOwnProperty","call","type","listOAuthIdpConfigs","oauthIdpConfigs","configResponse","OIDCConfig","listInboundSamlConfigs","inboundSamlConfigs","SAMLConfig","getProviderConfig","isProviderId","getOAuthIdpConfig","getInboundSamlConfig","INVALID_PROVIDER_ID","deleteProviderConfig","deleteOAuthIdpConfig","deleteInboundSamlConfig","updateProviderConfig","updatedConfig","INVALID_CONFIG","updateOAuthIdpConfig","updateInboundSamlConfig","createProviderConfig","config","createOAuthIdpConfig","createInboundSamlConfig","_verifyAuthBlockingToken","token","audience","decodedAuthBlockingToken","revocationErrorInfo","sub","disabled","USER_DISABLED","tokensValidAfterTime","authTimeUtc","auth_time","validSinceUtc","Date","getTime"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/firebase-admin/lib/auth/base-auth.js"],"sourcesContent":["/*! firebase-admin v13.0.1 */\r\n\"use strict\";\r\n/*!\r\n * Copyright 2021 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BaseAuth = void 0;\r\nexports.createFirebaseTokenGenerator = createFirebaseTokenGenerator;\r\nconst error_1 = require(\"../utils/error\");\r\nconst deep_copy_1 = require(\"../utils/deep-copy\");\r\nconst validator = require(\"../utils/validator\");\r\nconst auth_api_request_1 = require(\"./auth-api-request\");\r\nconst token_generator_1 = require(\"./token-generator\");\r\nconst token_verifier_1 = require(\"./token-verifier\");\r\nconst auth_config_1 = require(\"./auth-config\");\r\nconst user_record_1 = require(\"./user-record\");\r\nconst identifier_1 = require(\"./identifier\");\r\nconst crypto_signer_1 = require(\"../utils/crypto-signer\");\r\n/**\r\n * @internal\r\n */\r\nfunction createFirebaseTokenGenerator(app, tenantId) {\r\n    try {\r\n        const signer = (0, auth_api_request_1.useEmulator)() ? new token_generator_1.EmulatedSigner() : (0, crypto_signer_1.cryptoSignerFromApp)(app);\r\n        return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);\r\n    }\r\n    catch (err) {\r\n        throw (0, token_generator_1.handleCryptoSignerError)(err);\r\n    }\r\n}\r\n/**\r\n * Common parent interface for both `Auth` and `TenantAwareAuth` APIs.\r\n */\r\nclass BaseAuth {\r\n    /**\r\n     * The BaseAuth class constructor.\r\n     *\r\n     * @param app - The FirebaseApp to associate with this Auth instance.\r\n     * @param authRequestHandler - The RPC request handler for this instance.\r\n     * @param tokenGenerator - Optional token generator. If not specified, a\r\n     *     (non-tenant-aware) instance will be created. Use this paramter to\r\n     *     specify a tenant-aware tokenGenerator.\r\n     * @constructor\r\n     * @internal\r\n     */\r\n    constructor(app, \r\n    /** @internal */ authRequestHandler, tokenGenerator) {\r\n        this.authRequestHandler = authRequestHandler;\r\n        if (tokenGenerator) {\r\n            this.tokenGenerator = tokenGenerator;\r\n        }\r\n        else {\r\n            this.tokenGenerator = createFirebaseTokenGenerator(app);\r\n        }\r\n        this.sessionCookieVerifier = (0, token_verifier_1.createSessionCookieVerifier)(app);\r\n        this.idTokenVerifier = (0, token_verifier_1.createIdTokenVerifier)(app);\r\n        this.authBlockingTokenVerifier = (0, token_verifier_1.createAuthBlockingTokenVerifier)(app);\r\n    }\r\n    /**\r\n     * Creates a new Firebase custom token (JWT) that can be sent back to a client\r\n     * device to use to sign in with the client SDKs' `signInWithCustomToken()`\r\n     * methods. (Tenant-aware instances will also embed the tenant ID in the\r\n     * token.)\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/create-custom-tokens | Create Custom Tokens}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param uid - The `uid` to use as the custom token's subject.\r\n     * @param developerClaims - Optional additional claims to include\r\n     *   in the custom token's payload.\r\n     *\r\n     * @returns A promise fulfilled with a custom token for the\r\n     *   provided `uid` and payload.\r\n     */\r\n    createCustomToken(uid, developerClaims) {\r\n        return this.tokenGenerator.createCustomToken(uid, developerClaims);\r\n    }\r\n    /**\r\n     * Verifies a Firebase ID token (JWT). If the token is valid, the promise is\r\n     * fulfilled with the token's decoded claims; otherwise, the promise is\r\n     * rejected.\r\n     *\r\n     * If `checkRevoked` is set to true, first verifies whether the corresponding\r\n     * user is disabled. If yes, an `auth/user-disabled` error is thrown. If no,\r\n     * verifies if the session corresponding to the ID token was revoked. If the\r\n     * corresponding user's session was invalidated, an `auth/id-token-revoked`\r\n     * error is thrown. If not specified the check is not applied.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/verify-id-tokens | Verify ID Tokens}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param idToken - The ID token to verify.\r\n     * @param checkRevoked - Whether to check if the ID token was revoked.\r\n     *   This requires an extra request to the Firebase Auth backend to check\r\n     *   the `tokensValidAfterTime` time for the corresponding user.\r\n     *   When not specified, this additional check is not applied.\r\n     *\r\n     * @returns A promise fulfilled with the\r\n     *   token's decoded claims if the ID token is valid; otherwise, a rejected\r\n     *   promise.\r\n     */\r\n    verifyIdToken(idToken, checkRevoked = false) {\r\n        const isEmulator = (0, auth_api_request_1.useEmulator)();\r\n        return this.idTokenVerifier.verifyJWT(idToken, isEmulator)\r\n            .then((decodedIdToken) => {\r\n            // Whether to check if the token was revoked.\r\n            if (checkRevoked || isEmulator) {\r\n                return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\r\n            }\r\n            return decodedIdToken;\r\n        });\r\n    }\r\n    /**\r\n     * Gets the user data for the user corresponding to a given `uid`.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param uid - The `uid` corresponding to the user whose data to fetch.\r\n     *\r\n     * @returns A promise fulfilled with the user\r\n     *   data corresponding to the provided `uid`.\r\n     */\r\n    getUser(uid) {\r\n        return this.authRequestHandler.getAccountInfoByUid(uid)\r\n            .then((response) => {\r\n            // Returns the user record populated with server response.\r\n            return new user_record_1.UserRecord(response.users[0]);\r\n        });\r\n    }\r\n    /**\r\n     * Gets the user data for the user corresponding to a given email.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param email - The email corresponding to the user whose data to\r\n     *   fetch.\r\n     *\r\n     * @returns A promise fulfilled with the user\r\n     *   data corresponding to the provided email.\r\n     */\r\n    getUserByEmail(email) {\r\n        return this.authRequestHandler.getAccountInfoByEmail(email)\r\n            .then((response) => {\r\n            // Returns the user record populated with server response.\r\n            return new user_record_1.UserRecord(response.users[0]);\r\n        });\r\n    }\r\n    /**\r\n     * Gets the user data for the user corresponding to a given phone number. The\r\n     * phone number has to conform to the E.164 specification.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param phoneNumber - The phone number corresponding to the user whose\r\n     *   data to fetch.\r\n     *\r\n     * @returns A promise fulfilled with the user\r\n     *   data corresponding to the provided phone number.\r\n     */\r\n    getUserByPhoneNumber(phoneNumber) {\r\n        return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber)\r\n            .then((response) => {\r\n            // Returns the user record populated with server response.\r\n            return new user_record_1.UserRecord(response.users[0]);\r\n        });\r\n    }\r\n    /**\r\n     * Gets the user data for the user corresponding to a given provider id.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param providerId - The provider ID, for example, \"google.com\" for the\r\n     *   Google provider.\r\n     * @param uid - The user identifier for the given provider.\r\n     *\r\n     * @returns A promise fulfilled with the user data corresponding to the\r\n     *   given provider id.\r\n     */\r\n    getUserByProviderUid(providerId, uid) {\r\n        // Although we don't really advertise it, we want to also handle\r\n        // non-federated idps with this call. So if we detect one of them, we'll\r\n        // reroute this request appropriately.\r\n        if (providerId === 'phone') {\r\n            return this.getUserByPhoneNumber(uid);\r\n        }\r\n        else if (providerId === 'email') {\r\n            return this.getUserByEmail(uid);\r\n        }\r\n        return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid)\r\n            .then((response) => {\r\n            // Returns the user record populated with server response.\r\n            return new user_record_1.UserRecord(response.users[0]);\r\n        });\r\n    }\r\n    /**\r\n     * Gets the user data corresponding to the specified identifiers.\r\n     *\r\n     * There are no ordering guarantees; in particular, the nth entry in the result list is not\r\n     * guaranteed to correspond to the nth entry in the input parameters list.\r\n     *\r\n     * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,\r\n     * this method throws a FirebaseAuthError.\r\n     *\r\n     * @param identifiers - The identifiers used to indicate which user records should be returned.\r\n     *     Must not have more than 100 entries.\r\n     * @returns A promise that resolves to the corresponding user records.\r\n     * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100\r\n     *     identifiers are specified.\r\n     */\r\n    getUsers(identifiers) {\r\n        if (!validator.isArray(identifiers)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');\r\n        }\r\n        return this.authRequestHandler\r\n            .getAccountInfoByIdentifiers(identifiers)\r\n            .then((response) => {\r\n            /**\r\n             * Checks if the specified identifier is within the list of\r\n             * UserRecords.\r\n             */\r\n            const isUserFound = ((id, userRecords) => {\r\n                return !!userRecords.find((userRecord) => {\r\n                    if ((0, identifier_1.isUidIdentifier)(id)) {\r\n                        return id.uid === userRecord.uid;\r\n                    }\r\n                    else if ((0, identifier_1.isEmailIdentifier)(id)) {\r\n                        return id.email === userRecord.email;\r\n                    }\r\n                    else if ((0, identifier_1.isPhoneIdentifier)(id)) {\r\n                        return id.phoneNumber === userRecord.phoneNumber;\r\n                    }\r\n                    else if ((0, identifier_1.isProviderIdentifier)(id)) {\r\n                        const matchingUserInfo = userRecord.providerData.find((userInfo) => {\r\n                            return id.providerId === userInfo.providerId;\r\n                        });\r\n                        return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;\r\n                    }\r\n                    else {\r\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');\r\n                    }\r\n                });\r\n            });\r\n            const users = response.users ? response.users.map((user) => new user_record_1.UserRecord(user)) : [];\r\n            const notFound = identifiers.filter((id) => !isUserFound(id, users));\r\n            return { users, notFound };\r\n        });\r\n    }\r\n    /**\r\n     * Retrieves a list of users (single batch only) with a size of `maxResults`\r\n     * starting from the offset as specified by `pageToken`. This is used to\r\n     * retrieve all the users of a specified project in batches.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#list_all_users | List all users}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param maxResults - The page size, 1000 if undefined. This is also\r\n     *   the maximum allowed limit.\r\n     * @param pageToken - The next page token. If not specified, returns\r\n     *   users starting without any offset.\r\n     * @returns A promise that resolves with\r\n     *   the current batch of downloaded users and the next page token.\r\n     */\r\n    listUsers(maxResults, pageToken) {\r\n        return this.authRequestHandler.downloadAccount(maxResults, pageToken)\r\n            .then((response) => {\r\n            // List of users to return.\r\n            const users = [];\r\n            // Convert each user response to a UserRecord.\r\n            response.users.forEach((userResponse) => {\r\n                users.push(new user_record_1.UserRecord(userResponse));\r\n            });\r\n            // Return list of user records and the next page token if available.\r\n            const result = {\r\n                users,\r\n                pageToken: response.nextPageToken,\r\n            };\r\n            // Delete result.pageToken if undefined.\r\n            if (typeof result.pageToken === 'undefined') {\r\n                delete result.pageToken;\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new user.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#create_a_user | Create a user}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param properties - The properties to set on the\r\n     *   new user record to be created.\r\n     *\r\n     * @returns A promise fulfilled with the user\r\n     *   data corresponding to the newly created user.\r\n     */\r\n    createUser(properties) {\r\n        return this.authRequestHandler.createNewAccount(properties)\r\n            .then((uid) => {\r\n            // Return the corresponding user record.\r\n            return this.getUser(uid);\r\n        })\r\n            .catch((error) => {\r\n            if (error.code === 'auth/user-not-found') {\r\n                // Something must have happened after creating the user and then retrieving it.\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\r\n            }\r\n            throw error;\r\n        });\r\n    }\r\n    /**\r\n     * Deletes an existing user.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#delete_a_user | Delete a user}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param uid - The `uid` corresponding to the user to delete.\r\n     *\r\n     * @returns An empty promise fulfilled once the user has been\r\n     *   deleted.\r\n     */\r\n    deleteUser(uid) {\r\n        return this.authRequestHandler.deleteAccount(uid)\r\n            .then(() => {\r\n            // Return nothing on success.\r\n        });\r\n    }\r\n    /**\r\n     * Deletes the users specified by the given uids.\r\n     *\r\n     * Deleting a non-existing user won't generate an error (i.e. this method\r\n     * is idempotent.) Non-existing users are considered to be successfully\r\n     * deleted, and are therefore counted in the\r\n     * `DeleteUsersResult.successCount` value.\r\n     *\r\n     * Only a maximum of 1000 identifiers may be supplied. If more than 1000\r\n     * identifiers are supplied, this method throws a FirebaseAuthError.\r\n     *\r\n     * This API is currently rate limited at the server to 1 QPS. If you exceed\r\n     * this, you may get a quota exceeded error. Therefore, if you want to\r\n     * delete more than 1000 users, you may need to add a delay to ensure you\r\n     * don't go over this limit.\r\n     *\r\n     * @param uids - The `uids` corresponding to the users to delete.\r\n     *\r\n     * @returns A Promise that resolves to the total number of successful/failed\r\n     *     deletions, as well as the array of errors that corresponds to the\r\n     *     failed deletions.\r\n     */\r\n    deleteUsers(uids) {\r\n        if (!validator.isArray(uids)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');\r\n        }\r\n        return this.authRequestHandler.deleteAccounts(uids, /*force=*/ true)\r\n            .then((batchDeleteAccountsResponse) => {\r\n            const result = {\r\n                failureCount: 0,\r\n                successCount: uids.length,\r\n                errors: [],\r\n            };\r\n            if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {\r\n                return result;\r\n            }\r\n            result.failureCount = batchDeleteAccountsResponse.errors.length;\r\n            result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;\r\n            result.errors = batchDeleteAccountsResponse.errors.map((batchDeleteErrorInfo) => {\r\n                if (batchDeleteErrorInfo.index === undefined) {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');\r\n                }\r\n                const errMsgToError = (msg) => {\r\n                    // We unconditionally set force=true, so the 'NOT_DISABLED' error\r\n                    // should not be possible.\r\n                    const code = msg && msg.startsWith('NOT_DISABLED') ?\r\n                        error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;\r\n                    return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);\r\n                };\r\n                return {\r\n                    index: batchDeleteErrorInfo.index,\r\n                    error: errMsgToError(batchDeleteErrorInfo.message),\r\n                };\r\n            });\r\n            return result;\r\n        });\r\n    }\r\n    /**\r\n     * Updates an existing user.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#update_a_user | Update a user}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param uid - The `uid` corresponding to the user to update.\r\n     * @param properties - The properties to update on\r\n     *   the provided user.\r\n     *\r\n     * @returns A promise fulfilled with the\r\n     *   updated user data.\r\n     */\r\n    updateUser(uid, properties) {\r\n        // Although we don't really advertise it, we want to also handle linking of\r\n        // non-federated idps with this call. So if we detect one of them, we'll\r\n        // adjust the properties parameter appropriately. This *does* imply that a\r\n        // conflict could arise, e.g. if the user provides a phoneNumber property,\r\n        // but also provides a providerToLink with a 'phone' provider id. In that\r\n        // case, we'll throw an error.\r\n        properties = (0, deep_copy_1.deepCopy)(properties);\r\n        if (properties?.providerToLink) {\r\n            if (properties.providerToLink.providerId === 'email') {\r\n                if (typeof properties.email !== 'undefined') {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To \"\r\n                        + 'link to the email/password provider, only specify the UpdateRequest.email field.');\r\n                }\r\n                properties.email = properties.providerToLink.uid;\r\n                delete properties.providerToLink;\r\n            }\r\n            else if (properties.providerToLink.providerId === 'phone') {\r\n                if (typeof properties.phoneNumber !== 'undefined') {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To \"\r\n                        + 'link to a phone provider, only specify the UpdateRequest.phoneNumber field.');\r\n                }\r\n                properties.phoneNumber = properties.providerToLink.uid;\r\n                delete properties.providerToLink;\r\n            }\r\n        }\r\n        if (properties?.providersToUnlink) {\r\n            if (properties.providersToUnlink.indexOf('phone') !== -1) {\r\n                // If we've been told to unlink the phone provider both via setting\r\n                // phoneNumber to null *and* by setting providersToUnlink to include\r\n                // 'phone', then we'll reject that. Though it might also be reasonable\r\n                // to relax this restriction and just unlink it.\r\n                if (properties.phoneNumber === null) {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To \"\r\n                        + 'unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.');\r\n                }\r\n            }\r\n        }\r\n        return this.authRequestHandler.updateExistingAccount(uid, properties)\r\n            .then((existingUid) => {\r\n            // Return the corresponding user record.\r\n            return this.getUser(existingUid);\r\n        });\r\n    }\r\n    /**\r\n     * Sets additional developer claims on an existing user identified by the\r\n     * provided `uid`, typically used to define user roles and levels of\r\n     * access. These claims should propagate to all devices where the user is\r\n     * already signed in (after token expiration or when token refresh is forced)\r\n     * and the next time the user signs in. If a reserved OIDC claim name\r\n     * is used (sub, iat, iss, etc), an error is thrown. They are set on the\r\n     * authenticated user's ID token JWT.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/custom-claims |\r\n     * Defining user roles and access levels}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param uid - The `uid` of the user to edit.\r\n     * @param customUserClaims - The developer claims to set. If null is\r\n     *   passed, existing custom claims are deleted. Passing a custom claims payload\r\n     *   larger than 1000 bytes will throw an error. Custom claims are added to the\r\n     *   user's ID token which is transmitted on every authenticated request.\r\n     *   For profile non-access related user attributes, use database or other\r\n     *   separate storage systems.\r\n     * @returns A promise that resolves when the operation completes\r\n     *   successfully.\r\n     */\r\n    setCustomUserClaims(uid, customUserClaims) {\r\n        return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims)\r\n            .then(() => {\r\n            // Return nothing on success.\r\n        });\r\n    }\r\n    /**\r\n     * Revokes all refresh tokens for an existing user.\r\n     *\r\n     * This API will update the user's {@link UserRecord.tokensValidAfterTime} to\r\n     * the current UTC. It is important that the server on which this is called has\r\n     * its clock set correctly and synchronized.\r\n     *\r\n     * While this will revoke all sessions for a specified user and disable any\r\n     * new ID tokens for existing sessions from getting minted, existing ID tokens\r\n     * may remain active until their natural expiration (one hour). To verify that\r\n     * ID tokens are revoked, use {@link BaseAuth.verifyIdToken}\r\n     * where `checkRevoked` is set to true.\r\n     *\r\n     * @param uid - The `uid` corresponding to the user whose refresh tokens\r\n     *   are to be revoked.\r\n     *\r\n     * @returns An empty promise fulfilled once the user's refresh\r\n     *   tokens have been revoked.\r\n     */\r\n    revokeRefreshTokens(uid) {\r\n        return this.authRequestHandler.revokeRefreshTokens(uid)\r\n            .then(() => {\r\n            // Return nothing on success.\r\n        });\r\n    }\r\n    /**\r\n     * Imports the provided list of users into Firebase Auth.\r\n     * A maximum of 1000 users are allowed to be imported one at a time.\r\n     * When importing users with passwords,\r\n     * {@link UserImportOptions} are required to be\r\n     * specified.\r\n     * This operation is optimized for bulk imports and will ignore checks on `uid`,\r\n     * `email` and other identifier uniqueness which could result in duplications.\r\n     *\r\n     * @param users - The list of user records to import to Firebase Auth.\r\n     * @param options - The user import options, required when the users provided include\r\n     *   password credentials.\r\n     * @returns A promise that resolves when\r\n     *   the operation completes with the result of the import. This includes the\r\n     *   number of successful imports, the number of failed imports and their\r\n     *   corresponding errors.\r\n    */\r\n    importUsers(users, options) {\r\n        return this.authRequestHandler.uploadAccount(users, options);\r\n    }\r\n    /**\r\n     * Creates a new Firebase session cookie with the specified options. The created\r\n     * JWT string can be set as a server-side session cookie with a custom cookie\r\n     * policy, and be used for session management. The session cookie JWT will have\r\n     * the same payload claims as the provided ID token.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies | Manage Session Cookies}\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param idToken - The Firebase ID token to exchange for a session\r\n     *   cookie.\r\n     * @param sessionCookieOptions - The session\r\n     *   cookie options which includes custom session duration.\r\n     *\r\n     * @returns A promise that resolves on success with the\r\n     *   created session cookie.\r\n     */\r\n    createSessionCookie(idToken, sessionCookieOptions) {\r\n        // Return rejected promise if expiresIn is not available.\r\n        if (!validator.isNonNullObject(sessionCookieOptions) ||\r\n            !validator.isNumber(sessionCookieOptions.expiresIn)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\r\n        }\r\n        return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\r\n    }\r\n    /**\r\n     * Verifies a Firebase session cookie. Returns a Promise with the cookie claims.\r\n     * Rejects the promise if the cookie could not be verified.\r\n     *\r\n     * If `checkRevoked` is set to true, first verifies whether the corresponding\r\n     * user is disabled: If yes, an `auth/user-disabled` error is thrown. If no,\r\n     * verifies if the session corresponding to the session cookie was revoked.\r\n     * If the corresponding user's session was invalidated, an\r\n     * `auth/session-cookie-revoked` error is thrown. If not specified the check\r\n     * is not performed.\r\n     *\r\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies#verify_session_cookie_and_check_permissions |\r\n     * Verify Session Cookies}\r\n     * for code samples and detailed documentation\r\n     *\r\n     * @param sessionCookie - The session cookie to verify.\r\n     * @param checkForRevocation -  Whether to check if the session cookie was\r\n     *   revoked. This requires an extra request to the Firebase Auth backend to\r\n     *   check the `tokensValidAfterTime` time for the corresponding user.\r\n     *   When not specified, this additional check is not performed.\r\n     *\r\n     * @returns A promise fulfilled with the\r\n     *   session cookie's decoded claims if the session cookie is valid; otherwise,\r\n     *   a rejected promise.\r\n     */\r\n    verifySessionCookie(sessionCookie, checkRevoked = false) {\r\n        const isEmulator = (0, auth_api_request_1.useEmulator)();\r\n        return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator)\r\n            .then((decodedIdToken) => {\r\n            // Whether to check if the token was revoked.\r\n            if (checkRevoked || isEmulator) {\r\n                return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\r\n            }\r\n            return decodedIdToken;\r\n        });\r\n    }\r\n    /**\r\n     * Generates the out of band email action link to reset a user's password.\r\n     * The link is generated for the user with the specified email address. The\r\n     * optional  {@link ActionCodeSettings} object\r\n     * defines whether the link is to be handled by a mobile app or browser and the\r\n     * additional state information to be passed in the deep link, etc.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var actionCodeSettings = {\r\n     *   url: 'https://www.example.com/?email=user@example.com',\r\n     *   iOS: {\r\n     *     bundleId: 'com.example.ios'\r\n     *   },\r\n     *   android: {\r\n     *     packageName: 'com.example.android',\r\n     *     installApp: true,\r\n     *     minimumVersion: '12'\r\n     *   },\r\n     *   handleCodeInApp: true,\r\n     *   dynamicLinkDomain: 'custom.page.link'\r\n     * };\r\n     * admin.auth()\r\n     *     .generatePasswordResetLink('user@example.com', actionCodeSettings)\r\n     *     .then(function(link) {\r\n     *       // The link was successfully generated.\r\n     *     })\r\n     *     .catch(function(error) {\r\n     *       // Some error occurred, you can inspect the code: error.code\r\n     *     });\r\n     * ```\r\n     *\r\n     * @param email - The email address of the user whose password is to be\r\n     *   reset.\r\n     * @param actionCodeSettings - The action\r\n     *     code settings. If specified, the state/continue URL is set as the\r\n     *     \"continueUrl\" parameter in the password reset link. The default password\r\n     *     reset landing page will use this to display a link to go back to the app\r\n     *     if it is installed.\r\n     *     If the actionCodeSettings is not specified, no URL is appended to the\r\n     *     action URL.\r\n     *     The state URL provided must belong to a domain that is whitelisted by the\r\n     *     developer in the console. Otherwise an error is thrown.\r\n     *     Mobile app redirects are only applicable if the developer configures\r\n     *     and accepts the Firebase Dynamic Links terms of service.\r\n     *     The Android package name and iOS bundle ID are respected only if they\r\n     *     are configured in the same Firebase Auth project.\r\n     * @returns A promise that resolves with the generated link.\r\n     */\r\n    generatePasswordResetLink(email, actionCodeSettings) {\r\n        return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\r\n    }\r\n    /**\r\n     * Generates the out of band email action link to verify the user's ownership\r\n     * of the specified email. The {@link ActionCodeSettings} object provided\r\n     * as an argument to this method defines whether the link is to be handled by a\r\n     * mobile app or browser along with additional state information to be passed in\r\n     * the deep link, etc.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var actionCodeSettings = {\r\n     *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\r\n     *   iOS: {\r\n     *     bundleId: 'com.example.ios'\r\n     *   },\r\n     *   android: {\r\n     *     packageName: 'com.example.android',\r\n     *     installApp: true,\r\n     *     minimumVersion: '12'\r\n     *   },\r\n     *   handleCodeInApp: true,\r\n     *   dynamicLinkDomain: 'custom.page.link'\r\n     * };\r\n     * admin.auth()\r\n     *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\r\n     *     .then(function(link) {\r\n     *       // The link was successfully generated.\r\n     *     })\r\n     *     .catch(function(error) {\r\n     *       // Some error occurred, you can inspect the code: error.code\r\n     *     });\r\n     * ```\r\n     *\r\n     * @param email - The email account to verify.\r\n     * @param actionCodeSettings - The action\r\n     *     code settings. If specified, the state/continue URL is set as the\r\n     *     \"continueUrl\" parameter in the email verification link. The default email\r\n     *     verification landing page will use this to display a link to go back to\r\n     *     the app if it is installed.\r\n     *     If the actionCodeSettings is not specified, no URL is appended to the\r\n     *     action URL.\r\n     *     The state URL provided must belong to a domain that is whitelisted by the\r\n     *     developer in the console. Otherwise an error is thrown.\r\n     *     Mobile app redirects are only applicable if the developer configures\r\n     *     and accepts the Firebase Dynamic Links terms of service.\r\n     *     The Android package name and iOS bundle ID are respected only if they\r\n     *     are configured in the same Firebase Auth project.\r\n     * @returns A promise that resolves with the generated link.\r\n     */\r\n    generateEmailVerificationLink(email, actionCodeSettings) {\r\n        return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\r\n    }\r\n    /**\r\n     * Generates an out-of-band email action link to verify the user's ownership\r\n     * of the specified email. The {@link ActionCodeSettings} object provided\r\n     * as an argument to this method defines whether the link is to be handled by a\r\n     * mobile app or browser along with additional state information to be passed in\r\n     * the deep link, etc.\r\n     *\r\n     * @param email - The current email account.\r\n     * @param newEmail - The email address the account is being updated to.\r\n     * @param actionCodeSettings - The action\r\n     *     code settings. If specified, the state/continue URL is set as the\r\n     *     \"continueUrl\" parameter in the email verification link. The default email\r\n     *     verification landing page will use this to display a link to go back to\r\n     *     the app if it is installed.\r\n     *     If the actionCodeSettings is not specified, no URL is appended to the\r\n     *     action URL.\r\n     *     The state URL provided must belong to a domain that is authorized\r\n     *     in the console, or an error will be thrown.\r\n     *     Mobile app redirects are only applicable if the developer configures\r\n     *     and accepts the Firebase Dynamic Links terms of service.\r\n     *     The Android package name and iOS bundle ID are respected only if they\r\n     *     are configured in the same Firebase Auth project.\r\n     * @returns A promise that resolves with the generated link.\r\n     */\r\n    generateVerifyAndChangeEmailLink(email, newEmail, actionCodeSettings) {\r\n        return this.authRequestHandler.getEmailActionLink('VERIFY_AND_CHANGE_EMAIL', email, actionCodeSettings, newEmail);\r\n    }\r\n    /**\r\n     * Generates the out of band email action link to verify the user's ownership\r\n     * of the specified email. The {@link ActionCodeSettings} object provided\r\n     * as an argument to this method defines whether the link is to be handled by a\r\n     * mobile app or browser along with additional state information to be passed in\r\n     * the deep link, etc.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var actionCodeSettings = {\r\n     *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\r\n     *   iOS: {\r\n     *     bundleId: 'com.example.ios'\r\n     *   },\r\n     *   android: {\r\n     *     packageName: 'com.example.android',\r\n     *     installApp: true,\r\n     *     minimumVersion: '12'\r\n     *   },\r\n     *   handleCodeInApp: true,\r\n     *   dynamicLinkDomain: 'custom.page.link'\r\n     * };\r\n     * admin.auth()\r\n     *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\r\n     *     .then(function(link) {\r\n     *       // The link was successfully generated.\r\n     *     })\r\n     *     .catch(function(error) {\r\n     *       // Some error occurred, you can inspect the code: error.code\r\n     *     });\r\n     * ```\r\n     *\r\n     * @param email - The email account to verify.\r\n     * @param actionCodeSettings - The action\r\n     *     code settings. If specified, the state/continue URL is set as the\r\n     *     \"continueUrl\" parameter in the email verification link. The default email\r\n     *     verification landing page will use this to display a link to go back to\r\n     *     the app if it is installed.\r\n     *     If the actionCodeSettings is not specified, no URL is appended to the\r\n     *     action URL.\r\n     *     The state URL provided must belong to a domain that is whitelisted by the\r\n     *     developer in the console. Otherwise an error is thrown.\r\n     *     Mobile app redirects are only applicable if the developer configures\r\n     *     and accepts the Firebase Dynamic Links terms of service.\r\n     *     The Android package name and iOS bundle ID are respected only if they\r\n     *     are configured in the same Firebase Auth project.\r\n     * @returns A promise that resolves with the generated link.\r\n     */\r\n    generateSignInWithEmailLink(email, actionCodeSettings) {\r\n        return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\r\n    }\r\n    /**\r\n     * Returns the list of existing provider configurations matching the filter\r\n     * provided. At most, 100 provider configs can be listed at a time.\r\n     *\r\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\r\n     * (GCIP). To learn more about GCIP, including pricing and features,\r\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\r\n     *\r\n     * @param options - The provider config filter to apply.\r\n     * @returns A promise that resolves with the list of provider configs meeting the\r\n     *   filter requirements.\r\n     */\r\n    listProviderConfigs(options) {\r\n        const processResponse = (response, providerConfigs) => {\r\n            // Return list of provider configuration and the next page token if available.\r\n            const result = {\r\n                providerConfigs,\r\n            };\r\n            // Delete result.pageToken if undefined.\r\n            if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {\r\n                result.pageToken = response.nextPageToken;\r\n            }\r\n            return result;\r\n        };\r\n        if (options && options.type === 'oidc') {\r\n            return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken)\r\n                .then((response) => {\r\n                // List of provider configurations to return.\r\n                const providerConfigs = [];\r\n                // Convert each provider config response to a OIDCConfig.\r\n                response.oauthIdpConfigs.forEach((configResponse) => {\r\n                    providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\r\n                });\r\n                // Return list of provider configuration and the next page token if available.\r\n                return processResponse(response, providerConfigs);\r\n            });\r\n        }\r\n        else if (options && options.type === 'saml') {\r\n            return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken)\r\n                .then((response) => {\r\n                // List of provider configurations to return.\r\n                const providerConfigs = [];\r\n                // Convert each provider config response to a SAMLConfig.\r\n                response.inboundSamlConfigs.forEach((configResponse) => {\r\n                    providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\r\n                });\r\n                // Return list of provider configuration and the next page token if available.\r\n                return processResponse(response, providerConfigs);\r\n            });\r\n        }\r\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"AuthProviderConfigFilter.type\" must be either \"saml\" or \"oidc\"'));\r\n    }\r\n    /**\r\n     * Looks up an Auth provider configuration by the provided ID.\r\n     * Returns a promise that resolves with the provider configuration\r\n     * corresponding to the provider ID specified. If the specified ID does not\r\n     * exist, an `auth/configuration-not-found` error is thrown.\r\n     *\r\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\r\n     * (GCIP). To learn more about GCIP, including pricing and features,\r\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\r\n     *\r\n     * @param providerId - The provider ID corresponding to the provider\r\n     *     config to return.\r\n     * @returns A promise that resolves\r\n     *     with the configuration corresponding to the provided ID.\r\n     */\r\n    getProviderConfig(providerId) {\r\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.getOAuthIdpConfig(providerId)\r\n                .then((response) => {\r\n                return new auth_config_1.OIDCConfig(response);\r\n            });\r\n        }\r\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.getInboundSamlConfig(providerId)\r\n                .then((response) => {\r\n                return new auth_config_1.SAMLConfig(response);\r\n            });\r\n        }\r\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n    }\r\n    /**\r\n     * Deletes the provider configuration corresponding to the provider ID passed.\r\n     * If the specified ID does not exist, an `auth/configuration-not-found` error\r\n     * is thrown.\r\n     *\r\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\r\n     * (GCIP). To learn more about GCIP, including pricing and features,\r\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\r\n     *\r\n     * @param providerId - The provider ID corresponding to the provider\r\n     *     config to delete.\r\n     * @returns A promise that resolves on completion.\r\n     */\r\n    deleteProviderConfig(providerId) {\r\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\r\n        }\r\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.deleteInboundSamlConfig(providerId);\r\n        }\r\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n    }\r\n    /**\r\n     * Returns a promise that resolves with the updated `AuthProviderConfig`\r\n     * corresponding to the provider ID specified.\r\n     * If the specified ID does not exist, an `auth/configuration-not-found` error\r\n     * is thrown.\r\n     *\r\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\r\n     * (GCIP). To learn more about GCIP, including pricing and features,\r\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\r\n     *\r\n     * @param providerId - The provider ID corresponding to the provider\r\n     *     config to update.\r\n     * @param updatedConfig - The updated configuration.\r\n     * @returns A promise that resolves with the updated provider configuration.\r\n     */\r\n    updateProviderConfig(providerId, updatedConfig) {\r\n        if (!validator.isNonNullObject(updatedConfig)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\r\n        }\r\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig)\r\n                .then((response) => {\r\n                return new auth_config_1.OIDCConfig(response);\r\n            });\r\n        }\r\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig)\r\n                .then((response) => {\r\n                return new auth_config_1.SAMLConfig(response);\r\n            });\r\n        }\r\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n    }\r\n    /**\r\n     * Returns a promise that resolves with the newly created `AuthProviderConfig`\r\n     * when the new provider configuration is created.\r\n     *\r\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\r\n     * (GCIP). To learn more about GCIP, including pricing and features,\r\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\r\n     *\r\n     * @param config - The provider configuration to create.\r\n     * @returns A promise that resolves with the created provider configuration.\r\n     */\r\n    createProviderConfig(config) {\r\n        if (!validator.isNonNullObject(config)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\r\n        }\r\n        if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\r\n            return this.authRequestHandler.createOAuthIdpConfig(config)\r\n                .then((response) => {\r\n                return new auth_config_1.OIDCConfig(response);\r\n            });\r\n        }\r\n        else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\r\n            return this.authRequestHandler.createInboundSamlConfig(config)\r\n                .then((response) => {\r\n                return new auth_config_1.SAMLConfig(response);\r\n            });\r\n        }\r\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n    }\r\n    /** @alpha */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    _verifyAuthBlockingToken(token, audience) {\r\n        const isEmulator = (0, auth_api_request_1.useEmulator)();\r\n        return this.authBlockingTokenVerifier._verifyAuthBlockingToken(token, isEmulator, audience)\r\n            .then((decodedAuthBlockingToken) => {\r\n            return decodedAuthBlockingToken;\r\n        });\r\n    }\r\n    /**\r\n     * Verifies the decoded Firebase issued JWT is not revoked or disabled. Returns a promise that\r\n     * resolves with the decoded claims on success. Rejects the promise with revocation error if revoked\r\n     * or user disabled.\r\n     *\r\n     * @param decodedIdToken - The JWT's decoded claims.\r\n     * @param revocationErrorInfo - The revocation error info to throw on revocation\r\n     *     detection.\r\n     * @returns A promise that will be fulfilled after a successful verification.\r\n     */\r\n    verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, revocationErrorInfo) {\r\n        // Get tokens valid after time for the corresponding user.\r\n        return this.getUser(decodedIdToken.sub)\r\n            .then((user) => {\r\n            if (user.disabled) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_DISABLED, 'The user record is disabled.');\r\n            }\r\n            // If no tokens valid after time available, token is not revoked.\r\n            if (user.tokensValidAfterTime) {\r\n                // Get the ID token authentication time and convert to milliseconds UTC.\r\n                const authTimeUtc = decodedIdToken.auth_time * 1000;\r\n                // Get user tokens valid after time in milliseconds UTC.\r\n                const validSinceUtc = new Date(user.tokensValidAfterTime).getTime();\r\n                // Check if authentication time is older than valid since time.\r\n                if (authTimeUtc < validSinceUtc) {\r\n                    throw new error_1.FirebaseAuthError(revocationErrorInfo);\r\n                }\r\n            }\r\n            // All checks above passed. Return the decoded token.\r\n            return decodedIdToken;\r\n        });\r\n    }\r\n}\r\nexports.BaseAuth = BaseAuth;\r\n"],"mappings":"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AIC,UAAU,EAAE;QAC5B,OAAO,IAAI,CAACI,oCAAoC,CAACD,cAAc,EAAEtC,OAAO,CAACwC,mBAAmB,CAACiG,sBAAsB,CAAC;MACxH;MACA,OAAOnG,cAAc;IACzB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIoG,yBAAyBA,CAAC1F,KAAK,EAAE2F,kBAAkB,EAAE;IACjD,OAAO,IAAI,CAACtH,kBAAkB,CAACuH,kBAAkB,CAAC,gBAAgB,EAAE5F,KAAK,EAAE2F,kBAAkB,CAAC;EAClG;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,6BAA6BA,CAAC7F,KAAK,EAAE2F,kBAAkB,EAAE;IACrD,OAAO,IAAI,CAACtH,kBAAkB,CAACuH,kBAAkB,CAAC,cAAc,EAAE5F,KAAK,EAAE2F,kBAAkB,CAAC;EAChG;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,gCAAgCA,CAAC9F,KAAK,EAAE+F,QAAQ,EAAEJ,kBAAkB,EAAE;IAClE,OAAO,IAAI,CAACtH,kBAAkB,CAACuH,kBAAkB,CAAC,yBAAyB,EAAE5F,KAAK,EAAE2F,kBAAkB,EAAEI,QAAQ,CAAC;EACrH;EACA;AACJ;AACA;AA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}