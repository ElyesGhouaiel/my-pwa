{"ast":null,"code":"'use strict';\n\n/**\r\n * Copyright Brian White. All rights reserved.\r\n *\r\n * @see https://github.com/mscdex/streamsearch\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to\r\n * deal in the Software without restriction, including without limitation the\r\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n * sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n * IN THE SOFTWARE.\r\n *\r\n * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\r\n * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\r\n */\nconst {\n  EventEmitter\n} = require('node:events');\nconst {\n  inherits\n} = require('node:util');\nfunction SBMH(needle) {\n  if (typeof needle === 'string') {\n    needle = Buffer.from(needle);\n  }\n  if (!Buffer.isBuffer(needle)) {\n    throw new TypeError('The needle has to be a String or a Buffer.');\n  }\n  const needleLength = needle.length;\n  if (needleLength === 0) {\n    throw new Error('The needle cannot be an empty String/Buffer.');\n  }\n  if (needleLength > 256) {\n    throw new Error('The needle cannot have a length bigger than 256.');\n  }\n  this.maxMatches = Infinity;\n  this.matches = 0;\n  this._occ = new Array(256).fill(needleLength); // Initialize occurrence table.\n  this._lookbehind_size = 0;\n  this._needle = needle;\n  this._bufpos = 0;\n  this._lookbehind = Buffer.alloc(needleLength);\n\n  // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n  for (var i = 0; i < needleLength - 1; ++i) {\n    // eslint-disable-line no-var\n    this._occ[needle[i]] = needleLength - 1 - i;\n  }\n}\ninherits(SBMH, EventEmitter);\nSBMH.prototype.reset = function () {\n  this._lookbehind_size = 0;\n  this.matches = 0;\n  this._bufpos = 0;\n};\nSBMH.prototype.push = function (chunk, pos) {\n  if (!Buffer.isBuffer(chunk)) {\n    chunk = Buffer.from(chunk, 'binary');\n  }\n  const chlen = chunk.length;\n  this._bufpos = pos || 0;\n  let r;\n  while (r !== chlen && this.matches < this.maxMatches) {\n    r = this._sbmh_feed(chunk);\n  }\n  return r;\n};\nSBMH.prototype._sbmh_feed = function (data) {\n  const len = data.length;\n  const needle = this._needle;\n  const needleLength = needle.length;\n  const lastNeedleChar = needle[needleLength - 1];\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n  let pos = -this._lookbehind_size;\n  let ch;\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needleLength) {\n      ch = this._sbmh_lookup_char(data, pos + needleLength - 1);\n      if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {\n        this._lookbehind_size = 0;\n        ++this.matches;\n        this.emit('info', true);\n        return this._bufpos = pos + needleLength;\n      }\n      pos += this._occ[ch];\n    }\n\n    // No match.\n\n    if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {\n        ++pos;\n      }\n    }\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, this._lookbehind, 0, this._lookbehind_size);\n      this._lookbehind_size = 0;\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      const bytesToCutOff = this._lookbehind_size + pos;\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, this._lookbehind, 0, bytesToCutOff);\n      }\n      this._lookbehind_size -= bytesToCutOff;\n      this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size);\n      data.copy(this._lookbehind, this._lookbehind_size);\n      this._lookbehind_size += len;\n      this._bufpos = len;\n      return len;\n    }\n  }\n\n  // Lookbehind buffer is now empty. We only need to check if the\n  // needle is in the haystack.\n  pos = data.indexOf(needle, pos + (pos >= 0) * this._bufpos);\n  if (pos !== -1) {\n    ++this.matches;\n    if (pos > 0) {\n      this.emit('info', true, data, this._bufpos, pos);\n    } else {\n      this.emit('info', true);\n    }\n    return this._bufpos = pos + needleLength;\n  }\n  pos = len - needleLength;\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  while (pos < len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0)) {\n    ++pos;\n  }\n  if (pos < len) {\n    data.copy(this._lookbehind, 0, pos, pos + (len - pos));\n    this._lookbehind_size = len - pos;\n  }\n\n  // Everything until pos is guaranteed not to contain needle data.\n  if (pos > 0) {\n    this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\n  }\n  this._bufpos = len;\n  return len;\n};\nSBMH.prototype._sbmh_lookup_char = function (data, pos) {\n  return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];\n};\nSBMH.prototype._sbmh_memcmp = function (data, pos, len) {\n  for (var i = 0; i < len; ++i) {\n    // eslint-disable-line no-var\n    if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {\n      return false;\n    }\n  }\n  return true;\n};\nmodule.exports = SBMH;","map":{"version":3,"names":["EventEmitter","require","inherits","SBMH","needle","Buffer","from","isBuffer","TypeError","needleLength","length","Error","maxMatches","Infinity","matches","_occ","Array","fill","_lookbehind_size","_needle","_bufpos","_lookbehind","alloc","i","prototype","reset","push","chunk","pos","chlen","r","_sbmh_feed","data","len","lastNeedleChar","ch","_sbmh_lookup_char","_sbmh_memcmp","emit","bytesToCutOff","copy","indexOf","compare","subarray","module","exports"],"sources":["C:/Users/yujir/Documents/ynov/app pwa/mypwafinal/my-pwa/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"],"sourcesContent":["'use strict'\r\n\r\n/**\r\n * Copyright Brian White. All rights reserved.\r\n *\r\n * @see https://github.com/mscdex/streamsearch\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to\r\n * deal in the Software without restriction, including without limitation the\r\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n * sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n * IN THE SOFTWARE.\r\n *\r\n * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\r\n * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\r\n */\r\n\r\nconst { EventEmitter } = require('node:events')\r\nconst { inherits } = require('node:util')\r\n\r\nfunction SBMH (needle) {\r\n  if (typeof needle === 'string') {\r\n    needle = Buffer.from(needle)\r\n  }\r\n\r\n  if (!Buffer.isBuffer(needle)) {\r\n    throw new TypeError('The needle has to be a String or a Buffer.')\r\n  }\r\n\r\n  const needleLength = needle.length\r\n\r\n  if (needleLength === 0) {\r\n    throw new Error('The needle cannot be an empty String/Buffer.')\r\n  }\r\n\r\n  if (needleLength > 256) {\r\n    throw new Error('The needle cannot have a length bigger than 256.')\r\n  }\r\n\r\n  this.maxMatches = Infinity\r\n  this.matches = 0\r\n\r\n  this._occ = new Array(256)\r\n    .fill(needleLength) // Initialize occurrence table.\r\n  this._lookbehind_size = 0\r\n  this._needle = needle\r\n  this._bufpos = 0\r\n\r\n  this._lookbehind = Buffer.alloc(needleLength)\r\n\r\n  // Populate occurrence table with analysis of the needle,\r\n  // ignoring last letter.\r\n  for (var i = 0; i < needleLength - 1; ++i) { // eslint-disable-line no-var\r\n    this._occ[needle[i]] = needleLength - 1 - i\r\n  }\r\n}\r\ninherits(SBMH, EventEmitter)\r\n\r\nSBMH.prototype.reset = function () {\r\n  this._lookbehind_size = 0\r\n  this.matches = 0\r\n  this._bufpos = 0\r\n}\r\n\r\nSBMH.prototype.push = function (chunk, pos) {\r\n  if (!Buffer.isBuffer(chunk)) {\r\n    chunk = Buffer.from(chunk, 'binary')\r\n  }\r\n  const chlen = chunk.length\r\n  this._bufpos = pos || 0\r\n  let r\r\n  while (r !== chlen && this.matches < this.maxMatches) { r = this._sbmh_feed(chunk) }\r\n  return r\r\n}\r\n\r\nSBMH.prototype._sbmh_feed = function (data) {\r\n  const len = data.length\r\n  const needle = this._needle\r\n  const needleLength = needle.length\r\n  const lastNeedleChar = needle[needleLength - 1]\r\n\r\n  // Positive: points to a position in `data`\r\n  //           pos == 3 points to data[3]\r\n  // Negative: points to a position in the lookbehind buffer\r\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\r\n  let pos = -this._lookbehind_size\r\n  let ch\r\n\r\n  if (pos < 0) {\r\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\r\n    // search with character lookup code that considers both the\r\n    // lookbehind buffer and the current round's haystack data.\r\n    //\r\n    // Loop until\r\n    //   there is a match.\r\n    // or until\r\n    //   we've moved past the position that requires the\r\n    //   lookbehind buffer. In this case we switch to the\r\n    //   optimized loop.\r\n    // or until\r\n    //   the character to look at lies outside the haystack.\r\n    while (pos < 0 && pos <= len - needleLength) {\r\n      ch = this._sbmh_lookup_char(data, pos + needleLength - 1)\r\n\r\n      if (\r\n        ch === lastNeedleChar &&\r\n        this._sbmh_memcmp(data, pos, needleLength - 1)\r\n      ) {\r\n        this._lookbehind_size = 0\r\n        ++this.matches\r\n        this.emit('info', true)\r\n\r\n        return (this._bufpos = pos + needleLength)\r\n      }\r\n      pos += this._occ[ch]\r\n    }\r\n\r\n    // No match.\r\n\r\n    if (pos < 0) {\r\n      // There's too few data for Boyer-Moore-Horspool to run,\r\n      // so let's use a different algorithm to skip as much as\r\n      // we can.\r\n      // Forward pos until\r\n      //   the trailing part of lookbehind + data\r\n      //   looks like the beginning of the needle\r\n      // or until\r\n      //   pos == 0\r\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) { ++pos }\r\n    }\r\n\r\n    if (pos >= 0) {\r\n      // Discard lookbehind buffer.\r\n      this.emit('info', false, this._lookbehind, 0, this._lookbehind_size)\r\n      this._lookbehind_size = 0\r\n    } else {\r\n      // Cut off part of the lookbehind buffer that has\r\n      // been processed and append the entire haystack\r\n      // into it.\r\n      const bytesToCutOff = this._lookbehind_size + pos\r\n      if (bytesToCutOff > 0) {\r\n        // The cut off data is guaranteed not to contain the needle.\r\n        this.emit('info', false, this._lookbehind, 0, bytesToCutOff)\r\n      }\r\n\r\n      this._lookbehind_size -= bytesToCutOff\r\n      this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size)\r\n\r\n      data.copy(this._lookbehind, this._lookbehind_size)\r\n      this._lookbehind_size += len\r\n\r\n      this._bufpos = len\r\n      return len\r\n    }\r\n  }\r\n\r\n  // Lookbehind buffer is now empty. We only need to check if the\r\n  // needle is in the haystack.\r\n  pos = data.indexOf(needle, pos + ((pos >= 0) * this._bufpos))\r\n\r\n  if (pos !== -1) {\r\n    ++this.matches\r\n    if (pos > 0) { this.emit('info', true, data, this._bufpos, pos) } else { this.emit('info', true) }\r\n    return (this._bufpos = pos + needleLength)\r\n  }\r\n\r\n  pos = len - needleLength\r\n\r\n  // There was no match. If there's trailing haystack data that we cannot\r\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\r\n  // data is less than the needle size) then match using a modified\r\n  // algorithm that starts matching from the beginning instead of the end.\r\n  // Whatever trailing data is left after running this algorithm is added to\r\n  // the lookbehind buffer.\r\n  while (\r\n    pos < len &&\r\n    (\r\n      data[pos] !== needle[0] ||\r\n      Buffer.compare(\r\n        data.subarray(pos, pos + len - pos),\r\n        needle.subarray(0, len - pos)\r\n      ) !== 0\r\n    )\r\n  ) {\r\n    ++pos\r\n  }\r\n  if (pos < len) {\r\n    data.copy(this._lookbehind, 0, pos, pos + (len - pos))\r\n    this._lookbehind_size = len - pos\r\n  }\r\n\r\n  // Everything until pos is guaranteed not to contain needle data.\r\n  if (pos > 0) { this.emit('info', false, data, this._bufpos, pos < len ? pos : len) }\r\n\r\n  this._bufpos = len\r\n  return len\r\n}\r\n\r\nSBMH.prototype._sbmh_lookup_char = function (data, pos) {\r\n  return pos < 0\r\n    ? this._lookbehind[this._lookbehind_size + pos]\r\n    : data[pos]\r\n}\r\n\r\nSBMH.prototype._sbmh_memcmp = function (data, pos, len) {\r\n  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var\r\n    if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) { return false }\r\n  }\r\n  return true\r\n}\r\n\r\nmodule.exports = SBMH\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}